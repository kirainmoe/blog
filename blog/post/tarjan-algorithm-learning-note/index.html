<!DOCTYPE html>
<html><head>
<title>【学习笔记】Tarjan 算法</title>

<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="google-site-verification" content="">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta content="telephone=no" name="format-detection">
<meta name="renderer" content="webkit">
<meta name="theme-color" content="#ffffff">




<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-111347233-1', 'auto');
	
	ga('send', 'pageview');
}
</script>



<script src="/vendor/js/jquery.min.js" ></script>
<script src="/vendor/js/popper.min.js" ></script>
<script src="/vendor/js/bootstrap.min.js" ></script>
<script src="/vendor/js/smooth-scroll.polyfills.min.js" ></script>
<link type="text/css" rel="stylesheet" href="/vendor/css/bootstrap.min.css">
<script src="/vendor/js/vue.min.js" ></script>




<link rel="stylesheet" href="https://kirainmoe.com/scss/journal.min.d1b323a5bdb0e7b05730834eb664c761432cfb57d618b4efeb5a9417a66a4b44.css" integrity="sha256-0bMjpb2w57BXMINOtmTHYUMs&#43;1fWGLTv61qUF6ZqS0Q=" media="screen">

<script src="https://kirainmoe.com//js/loadCSS.js"></script>
<script src="https://kirainmoe.com//js/table.js"></script>


<script src="https://kirainmoe.com//js/toc.js"></script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      showProcessingMessages: false,
      messageStyle: "none", 
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [["$", "$"], ["\\(", "\\)"]],
        displayMath: [["$$", "$$"], ["\\[", "\\]"]],
        skipTags: ["script", "noscript", "style", "textarea", "pre", "code", "a"]
      },
      "HTML-CSS": {
        availableFonts: ["STIX", "TeX"], 
        showMathMenu: false
      }
  });
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script src="https://unpkg.com/muse-player/dist/assets/muse-player.js"></script>

<script>
    loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Noto+Serif+SC|Material+Icons");
</script>

</head><body>
    	<div id="app"><div ref="sideContainer" class="side-container">
    
    <a class="a-block nav-head false" href="https://kirainmoe.com/">
    
        <div class="nav-title">
            宇宙よりも遠い場所
        </div>
        
    </a>

    <div class="nav-link-list">
        
        
            
                
                
                <a class="a-block nav-link-item false" href="/pages/guestbook">
                    留言板
                </a>
        
            
                
                
                <a class="a-block nav-link-item false" href="/pages/friends">
                    友情链接
                </a>
        
            
                
                
                <a class="a-block nav-link-item false" href="/tags">
                    标签
                </a>
        
            
                
                
                <a class="a-block nav-link-item false" href="/pages/about">
                    关于
                </a>
        
    </div>

    

    <div class="nav-footer">
        &copy;
	
	2016-2020 宇宙よりも遠い場所
	

/

<a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC-BY-SA 4.0</a>

<br>

Published with <a href="https://gohugo.io">Hugo</a> / Theme <a href="https://github.com/amazingrise/hugo-theme-diary" title="Author: Rise @ amazingrise.net">Diary</a>

    </div>
    
</div><div ref="extraContainer" class="extra-container">
    
    <div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }">


	<div class="toc-content">
	
		
		
		
		<center>- CATALOG -</center>
			
				
				
					
						
						
							<ul>
						
						
								<li>
				 					<a href="#0x00-tarjan-%e7%ae%97%e6%b3%95%e7%9a%84%e7%94%a8%e9%80%94" v-on:click="closeDrawer" id="0x00-tarjan-算法的用途-nav">
										 0x00 Tarjan 算法的用途
									</a>
								</li>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
						
								<li>
				 					<a href="#0x01-%e6%a6%82%e5%bf%b5" v-on:click="closeDrawer" id="0x01-概念-nav">
										 0x01 概念
									</a>
								</li>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e5%89%b2%e7%82%b9%e4%b8%8e%e5%89%b2%e8%be%b9%e6%a1%a5" v-on:click="closeDrawer" id="割点与割边桥-nav">
										 割点与割边（桥）
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e6%90%9c%e7%b4%a2%e6%a0%91" v-on:click="closeDrawer" id="搜索树-nav">
										 搜索树
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e6%97%b6%e9%97%b4%e6%88%b3aka-dfs-%e5%ba%8f" v-on:click="closeDrawer" id="时间戳aka-dfs-序-nav">
										 时间戳（aka. DFS 序）
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e8%bf%bd%e6%ba%af%e5%80%bc" v-on:click="closeDrawer" id="追溯值-nav">
										 追溯值
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e6%97%a0%e5%90%91%e5%9b%be%e5%8f%8c%e8%bf%9e%e9%80%9a%e5%88%86%e9%87%8f" v-on:click="closeDrawer" id="无向图双连通分量-nav">
										 （无向图）双连通分量
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e7%bc%a9%e7%82%b9" v-on:click="closeDrawer" id="缩点-nav">
										 缩点
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e6%b5%81%e5%9b%be-flow-graph" v-on:click="closeDrawer" id="流图-flow-graph-nav">
										 流图 (Flow Graph)
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e5%bc%ba%e8%bf%9e%e9%80%9a%e5%88%86%e9%87%8f%e6%9c%89%e5%90%91%e5%9b%be" v-on:click="closeDrawer" id="强连通分量有向图-nav">
										 强连通分量（有向图）
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e6%9c%89%e5%90%91%e5%9b%be%e7%9a%84%e5%bf%85%e7%bb%8f%e7%82%b9%e4%b8%8e%e5%bf%85%e7%bb%8f%e8%be%b9" v-on:click="closeDrawer" id="有向图的必经点与必经边-nav">
										 有向图的必经点与必经边
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
						
								<li>
				 					<a href="#0x02-tarjan-%e5%9c%a8%e6%97%a0%e5%90%91%e5%9b%be%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8" v-on:click="closeDrawer" id="0x02-tarjan-在无向图中的应用-nav">
										 0x02 Tarjan 在无向图中的应用
									</a>
								</li>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e6%b1%82%e5%89%b2%e8%be%b9" v-on:click="closeDrawer" id="求割边-nav">
										 求割边
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e6%b1%82%e5%89%b2%e7%82%b9" v-on:click="closeDrawer" id="求割点-nav">
										 求割点
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e6%b1%82%e6%97%a0%e5%90%91%e5%9b%be%e7%9a%84%e5%8f%8c%e8%bf%9e%e9%80%9a%e5%88%86%e9%87%8f" v-on:click="closeDrawer" id="求无向图的双连通分量-nav">
										 求无向图的双连通分量
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e6%b1%82%e6%97%a0%e5%90%91%e5%9b%be%e7%9a%84%e7%82%b9%e5%8f%8c%e8%bf%9e%e9%80%9a%e5%88%86%e9%87%8f-v-dcc" v-on:click="closeDrawer" id="求无向图的点双连通分量-v-dcc-nav">
										 求无向图的点双连通分量 v-DCC
									</a>
								</li>
						
							</ul>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e6%b1%82%e6%97%a0%e5%90%91%e5%9b%be%e7%9a%84-e-dcc" v-on:click="closeDrawer" id="求无向图的-e-dcc-nav">
										 求无向图的 e-DCC
									</a>
								</li>
						
							</ul>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#e-dcc-%e7%9a%84%e7%bc%a9%e7%82%b9" v-on:click="closeDrawer" id="e-dcc-的缩点-nav">
										 e-DCC 的缩点
									</a>
								</li>
						
							</ul>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#v-dcc-%e7%9a%84%e7%bc%a9%e7%82%b9" v-on:click="closeDrawer" id="v-dcc-的缩点-nav">
										 v-DCC 的缩点
									</a>
								</li>
						
							</ul>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
						
								<li>
				 					<a href="#0x03-tarjan-%e5%9c%a8%e6%9c%89%e5%90%91%e5%9b%be%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8" v-on:click="closeDrawer" id="0x03-tarjan-在有向图中的应用-nav">
										 0x03 Tarjan 在有向图中的应用
									</a>
								</li>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e6%b1%82%e6%9c%89%e5%90%91%e5%9b%be%e7%9a%84%e5%bc%ba%e8%bf%9e%e9%80%9a%e5%88%86%e9%87%8f" v-on:click="closeDrawer" id="求有向图的强连通分量-nav">
										 求有向图的强连通分量
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#scc-%e7%9a%84%e7%bc%a9%e7%82%b9" v-on:click="closeDrawer" id="scc-的缩点-nav">
										 SCC 的缩点
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
						
								<li>
				 					<a href="#0x04-one-more-thing---kosaraju" v-on:click="closeDrawer" id="0x04-one-more-thing---kosaraju-nav">
										 0x04 One More Thing - Kosaraju
									</a>
								</li>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
						
								<li>
				 					<a href="#0x05-reference" v-on:click="closeDrawer" id="0x05-reference-nav">
										 0x05 Reference
									</a>
								</li>
						
							</ul>
						
					
				
			
	</div>

</div>
    
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>
        
    </div>
</div><div class="single-column-drawer-container" ref="drawer"
     v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            
            
                
                    
                    
                    <a class="a-block drawer-menu-item false" href="/pages/guestbook">
                        留言板
                    </a>
            
                
                    
                    
                    <a class="a-block drawer-menu-item false" href="/pages/friends">
                        友情链接
                    </a>
            
                
                    
                    
                    <a class="a-block drawer-menu-item false" href="/tags">
                        标签
                    </a>
            
                
                    
                    
                    <a class="a-block drawer-menu-item false" href="/pages/about">
                        关于
                    </a>
            
            
            <div class="toc">


	<div class="toc-content">
	
		
		
		
		<center>- CATALOG -</center>
			
				
				
					
						
						
							<ul>
						
						
								<li>
				 					<a href="#0x00-tarjan-%e7%ae%97%e6%b3%95%e7%9a%84%e7%94%a8%e9%80%94" v-on:click="closeDrawer" id="0x00-tarjan-算法的用途-nav">
										 0x00 Tarjan 算法的用途
									</a>
								</li>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
						
								<li>
				 					<a href="#0x01-%e6%a6%82%e5%bf%b5" v-on:click="closeDrawer" id="0x01-概念-nav">
										 0x01 概念
									</a>
								</li>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e5%89%b2%e7%82%b9%e4%b8%8e%e5%89%b2%e8%be%b9%e6%a1%a5" v-on:click="closeDrawer" id="割点与割边桥-nav">
										 割点与割边（桥）
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e6%90%9c%e7%b4%a2%e6%a0%91" v-on:click="closeDrawer" id="搜索树-nav">
										 搜索树
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e6%97%b6%e9%97%b4%e6%88%b3aka-dfs-%e5%ba%8f" v-on:click="closeDrawer" id="时间戳aka-dfs-序-nav">
										 时间戳（aka. DFS 序）
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e8%bf%bd%e6%ba%af%e5%80%bc" v-on:click="closeDrawer" id="追溯值-nav">
										 追溯值
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e6%97%a0%e5%90%91%e5%9b%be%e5%8f%8c%e8%bf%9e%e9%80%9a%e5%88%86%e9%87%8f" v-on:click="closeDrawer" id="无向图双连通分量-nav">
										 （无向图）双连通分量
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e7%bc%a9%e7%82%b9" v-on:click="closeDrawer" id="缩点-nav">
										 缩点
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e6%b5%81%e5%9b%be-flow-graph" v-on:click="closeDrawer" id="流图-flow-graph-nav">
										 流图 (Flow Graph)
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e5%bc%ba%e8%bf%9e%e9%80%9a%e5%88%86%e9%87%8f%e6%9c%89%e5%90%91%e5%9b%be" v-on:click="closeDrawer" id="强连通分量有向图-nav">
										 强连通分量（有向图）
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e6%9c%89%e5%90%91%e5%9b%be%e7%9a%84%e5%bf%85%e7%bb%8f%e7%82%b9%e4%b8%8e%e5%bf%85%e7%bb%8f%e8%be%b9" v-on:click="closeDrawer" id="有向图的必经点与必经边-nav">
										 有向图的必经点与必经边
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
						
								<li>
				 					<a href="#0x02-tarjan-%e5%9c%a8%e6%97%a0%e5%90%91%e5%9b%be%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8" v-on:click="closeDrawer" id="0x02-tarjan-在无向图中的应用-nav">
										 0x02 Tarjan 在无向图中的应用
									</a>
								</li>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e6%b1%82%e5%89%b2%e8%be%b9" v-on:click="closeDrawer" id="求割边-nav">
										 求割边
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e6%b1%82%e5%89%b2%e7%82%b9" v-on:click="closeDrawer" id="求割点-nav">
										 求割点
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e6%b1%82%e6%97%a0%e5%90%91%e5%9b%be%e7%9a%84%e5%8f%8c%e8%bf%9e%e9%80%9a%e5%88%86%e9%87%8f" v-on:click="closeDrawer" id="求无向图的双连通分量-nav">
										 求无向图的双连通分量
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e6%b1%82%e6%97%a0%e5%90%91%e5%9b%be%e7%9a%84%e7%82%b9%e5%8f%8c%e8%bf%9e%e9%80%9a%e5%88%86%e9%87%8f-v-dcc" v-on:click="closeDrawer" id="求无向图的点双连通分量-v-dcc-nav">
										 求无向图的点双连通分量 v-DCC
									</a>
								</li>
						
							</ul>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e6%b1%82%e6%97%a0%e5%90%91%e5%9b%be%e7%9a%84-e-dcc" v-on:click="closeDrawer" id="求无向图的-e-dcc-nav">
										 求无向图的 e-DCC
									</a>
								</li>
						
							</ul>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#e-dcc-%e7%9a%84%e7%bc%a9%e7%82%b9" v-on:click="closeDrawer" id="e-dcc-的缩点-nav">
										 e-DCC 的缩点
									</a>
								</li>
						
							</ul>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#v-dcc-%e7%9a%84%e7%bc%a9%e7%82%b9" v-on:click="closeDrawer" id="v-dcc-的缩点-nav">
										 v-DCC 的缩点
									</a>
								</li>
						
							</ul>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
						
								<li>
				 					<a href="#0x03-tarjan-%e5%9c%a8%e6%9c%89%e5%90%91%e5%9b%be%e4%b8%ad%e7%9a%84%e5%ba%94%e7%94%a8" v-on:click="closeDrawer" id="0x03-tarjan-在有向图中的应用-nav">
										 0x03 Tarjan 在有向图中的应用
									</a>
								</li>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#%e6%b1%82%e6%9c%89%e5%90%91%e5%9b%be%e7%9a%84%e5%bc%ba%e8%bf%9e%e9%80%9a%e5%88%86%e9%87%8f" v-on:click="closeDrawer" id="求有向图的强连通分量-nav">
										 求有向图的强连通分量
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#scc-%e7%9a%84%e7%bc%a9%e7%82%b9" v-on:click="closeDrawer" id="scc-的缩点-nav">
										 SCC 的缩点
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
						
								<li>
				 					<a href="#0x04-one-more-thing---kosaraju" v-on:click="closeDrawer" id="0x04-one-more-thing---kosaraju-nav">
										 0x04 One More Thing - Kosaraju
									</a>
								</li>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
						
								<li>
				 					<a href="#0x05-reference" v-on:click="closeDrawer" id="0x05-reference-nav">
										 0x05 Reference
									</a>
								</li>
						
							</ul>
						
					
				
			
	</div>

</div>
            
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="https://kirainmoe.com/">
            宇宙よりも遠い場所
        </a>
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead"
     v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="https://kirainmoe.com/">
        <div class="single-column-header-title">宇宙よりも遠い場所</div>
        

    </a>
</div>
            <div id="content">
<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            
            
            

            <div class="post-head-wrapper-text-only"
                 style="background-image: url('/')">
                <div class="post-title">
                    【学习笔记】Tarjan 算法
                    <div class="post-meta">
                        <time itemprop="datePublished">
                            2019-03-18 21:44
                        </time>

                        

                        
                            <i class="material-icons" style="">label</i>
                            
                                <a href="/tags/acm">acm</a>
                                &nbsp;
                            
                                <a href="/tags/algorithm">algorithm</a>
                                &nbsp;
                            
                                <a href="/tags/graph-theory">graph theory</a>
                                &nbsp;
                            
                        
                    </div>
                </div>
            </div>
            
            <div class="post-body-wrapper">
                <div class="post-body">
                    <p>这次，我想用尽量简明的语言，来记录一下 Tarjan 算法的学习。</p>
<p>本文篇幅较长，完整阅读大约需要 15-20 分钟。</p>
<h1 id="0x00-tarjan-算法的用途">0x00 Tarjan 算法的用途</h1>
<p>当我们接触到一个新的算法的时候，首先要知道它的适用场景。Tarjan 是图论中一个重要的算法。对于无向图，Tarjan 算法能在 $O(n)$ 的时间内，求出无向图的<strong>割点</strong>与<strong>割边</strong>，进而求出<strong>无向图的双连通分量</strong>；对于有向图，Tarjan 算法能够求出有向图的<strong>强连通分量</strong>、<strong>必经点与必经边</strong>。</p>
<h1 id="0x01-概念">0x01 概念</h1>
<h2 id="割点与割边桥">割点与割边（桥）</h2>
<p>给定无向图 $G=(V, E)$：</p>
<blockquote>
<p>割点：若对于点 $x \in V$，从 $G$ 中删去 $x$ 及与 $x$ 相连的边之后，$G$ 分成了两个以上不相连的子图，那么 $x$ 称为图 $G$ 的割点。<br>
割边（桥）：若对于边 $e \in E$, 从 $G$ 中删去边 $e$ 后，$G$ 分裂成两个不相连的子图，那么 $e$ 称为图 $G$ 的割边（或桥）。</p>
</blockquote>
<p>简而言之，割点与割边可以理解为<strong>沟通两张不相连的图，使它们成为一张图的枢纽</strong>：</p>
<p><img src="https://wx4.sinaimg.cn/large/9f1137b1gy1g17aks02qaj20t10ibjs7.jpg" alt="割点与割边"></p>
<h2 id="搜索树">搜索树</h2>
<p>在图 $G=(V,E)$ 中，任选顶点 $x$ 作为起点对整张图进行 DFS，每个点只访问一次——此时，每个节点最多有一条入边 $e_{x}$ ，所有在 DFS 过程中经过的边，就构成无向图的搜索树。如果 DFS 的时候遇到了多个分支，我们总是走最左边的那个分支。</p>
<h2 id="时间戳aka-dfs-序">时间戳（aka. DFS 序）</h2>
<p>节点 $i$ 的时间戳（或 DFS 序）是节点在图的 DFS 中被访问的顺序，也就是说深度优先遍历一张图的时候，$i$ 节点是第 $t$ 个被访问的节点，那么 $i$ 的 DFS 序就是 $t$, 记作 $dfn[i] = t$.</p>
<p><img src="https://wx2.sinaimg.cn/large/9f1137b1gy1g17bbtmiu3j20sy0bst9c.jpg" alt="DFS序"></p>
<h2 id="追溯值">追溯值</h2>
<p>追溯值是个比较难理解的东西。在我们对整张图进行 DFS 的过程中，正在访问中的节点会加入一个栈 $s$ 中，节点 $i$ 追溯值的意义是：从节点 $i$ 或其子搜索树中的节点出发，能够追溯到的正在 DFS 栈 $s$ 中的节点序号。而我个人认为比较能理解接受的意义是：<strong>从节点 $i$ 出发，除了走通向 $x$ 的父节点 $p$ 的边 $(p, x)$ 之外，能到达的 dfn 最小的节点的序号。</strong></p>
<p><img src="https://wx3.sinaimg.cn/large/9f1137b1gy1g17bhvael1j20sx0ci74w.jpg" alt="追溯值"></p>
<p>在上图中，考虑节点 2 的追溯值。因为节点 5 可以通过一条不在搜索树上的边到达节点 1，因此 $low[5] = dfn[1] = 1$. 而 5 是 4 的子节点，4 是 3 的子节点……层层向上回溯，最终有 $low[2] = low[3] = low[4] = low[5] = 1.$.</p>
<p>考虑节点 7 的追溯值，因为 7 没有子节点也没有出边，所以 $low[7]$ 只能等于 $dfn[7] = 7$.</p>
<p>考虑节点 6 的追溯值，因为节点 9 可以通过一条不在搜索树上的边到达节点 6，因此 $low[9] = dfn[6] = 6$, 层层回溯最终有 $low[6] = low[8] = low[9] = 6$.</p>
<p>节点 $i$ 的追溯值我们用 $low[i]$ 表示。根据定义，我们计算 $low[i]$ 的方法如下：</p>
<ol>
<li>初始化，首先令 $low[i] = dfn[i]$</li>
<li>考虑 $i$ 的每条出边（不包括通向 $i$ 的父节点的出边）$(i, j)$，如果 $j$ 是 $i$ 在搜索树上的子节点，那么 $low[i] = min(low[i], low[j])$</li>
<li>如果 $j$ 不是 $i$ 在搜索树上的子节点，也不是 $i$ 的父节点，说明 $j$ 不在搜索树上，那么 $low[i] = min(low[i], dfn[j])$</li>
<li>$low[i]$ 应该在 DFS 回溯之前计算，确保 $low[j]$ 在 $low[i]$ 前被计算。</li>
</ol>
<h2 id="无向图双连通分量">（无向图）双连通分量</h2>
<p>点双连通图：不存在割点的图；边双连通图：不存在割边（桥）的图。</p>
<p>点双连通分量 (v-DCC, vertex double connected component): 无向连通图的极大点双连通子图。通俗地讲，就是从一个无向图中选出最多的 $n$ 个点，这些点及其连边构成的图不含有割点，删去 $n$ 个点中的任意一个，其它点仍然连通，图不会分割成多张子图。</p>
<p>类似地，定义边双连通分量（e-DCC, edge double connected component）: 无向连通图的极大边双连通子图。通俗地讲，就是从一个无向图中选出最多的 $n$ 个点及在这些点之间连的 $m$ 条边，构成一张新图，这张新图不含有割边，删去 $m$ 条边中的任意一条，其它点仍然连通，图不会分割成多张子图。</p>
<p>v-DCC 和 e-DCC 统称为双连通分量。注意双连通分量的定义是“极大”的。</p>
<h2 id="缩点">缩点</h2>
<p>e-DCC 的缩点：设无向图 $G$ 中有多个边双连通分量 $G_{e1}, G_{e2}, &hellip;, G_{en}$，把每个 e-DCC 视为独立的节点 $i_{1}, i_{2}, &hellip;, i_{n}$, 把两个 e-DCC 间的割边 $(x, y)$看做连接两个独立节点的边，这样做之后原来的图会变成一棵树 or 森林（取决于原图连通与否）。这种把 e-DCC 中的多个节点和边收缩成一个节点的方法，叫做缩点。如下图所示。</p>
<p><img src="https://wx2.sinaimg.cn/large/9f1137b1gy1g1877ia45gj210k0gk3zf.jpg" alt="e-dcc 的缩点"></p>
<p>v-DCC 的缩点：设无向图 $G$ 中有 $p$ 个点双连通分量 $G_{v1}, G_{v2}, &hellip;, G_{ep}$，把原来的 $p$ 个 v-DCC 视为独立节点 $i_{1}, i_{2}, &hellip;, i_{p}$（如果有点属于多个 v-DCC, 则多个 v-DCC 中都包含该点），在每两个 v-DCC 的公共点部分引入 $t$ 个新节点 $i_{p+1}, i_{p+2}&hellip;, i_{p+t} $，这些节点与 v-DCC 间的连边共同构成一棵树。这样称为 v-DCC 的缩点，如下图所示。</p>
<p><img src="https://ws2.sinaimg.cn/large/9f1137b1gy1g187igrgd7j21060k0400.jpg" alt="v-dcc 的缩点"></p>
<h2 id="流图-flow-graph">流图 (Flow Graph)</h2>
<blockquote>
<p>对有向图 $G = (V, E)$, 若存在点 $r \in V$, 满足从 $r$ 出发，能够到达 $V$ 中的所有点，那么图 $G$ 是一个<strong>流图</strong>，$r$ 称为流图的<strong>源点</strong>.</p>
</blockquote>
<p>流图中的边 $(x, y)$ 有四种类型：</p>
<ol>
<li>树枝边，指 $x$ 为 $y$ 的父节点，这是搜索树中的边；</li>
<li>前向边，指 $x$ 为 $y$ 的祖先节点；</li>
<li>后向边，指 $y$ 为 $x$ 的祖先节点；</li>
<li>横叉边，满足 $dfn[y] &lt; dfn<input checked="" disabled="" type="checkbox">$, 如果一条边不属于上述三种情况之一，那么这条边就是横叉边。</li>
</ol>
<p>如图所示：</p>
<p><img src="https://wx2.sinaimg.cn/large/9f1137b1gy1g188rd2ekkj20x70doq3m.jpg" alt="四种流图边类型"></p>
<h2 id="强连通分量有向图">强连通分量（有向图）</h2>
<blockquote>
<p>强连通图：给定一张有向图 $G=(V,E)$, 若对于图中任意两个节点 $x, y$，既存在 $x$ 到 $y$ 的路径，也存在 $y$ 到 $x$ 的路径，则称该图为<strong>强连通图</strong>。</p>
</blockquote>
<blockquote>
<p>强连通分量 (SCC, strong connected component)：有向图的极大强连通子图称为强连通分量。</p>
</blockquote>
<p>通俗地讲就是从一张有向图中选出最多 $n$ 个点及其连边构成一张新图，这张新图的每两个点都互相可达。根据定义，环一定是一个强连通图。</p>
<h2 id="有向图的必经点与必经边">有向图的必经点与必经边</h2>
<blockquote>
<p>有向图的必经点：给定有向图 $G=(V,E)$，起点为 $s$，终点为 $t$，若从 $s$ 到 $t$ 的<strong>每条路径</strong>都必须经过一个点 $x$，那么 $x$ 就是必经点。<br>
有向图的必经边：若从 $s$ 到 $t$ 的每条路径都经过一条边 $(x,y)$，则 $(x,y)$ 称为必经边或有向图的桥。</p>
</blockquote>
<p>这两个定义基本上都是字面意思。</p>
<h1 id="0x02-tarjan-在无向图中的应用">0x02 Tarjan 在无向图中的应用</h1>
<h2 id="求割边">求割边</h2>
<p>首先引入割边（桥）的判定法则：</p>
<blockquote>
<p>割边判定法则：如果无向边 $(x, y)$ 是桥，当且仅当 x,y 在搜索树上，y 为 x 的子节点，且 $dfn[x] &lt; low[y]$, 即 x 的 DFS 序小于 y 的追溯值。</p>
</blockquote>
<p>证明：根据上面的定义 $low[i]$ 表示由 $i$ 及其子树的节点出发能到达的 $dfn$ 最小的点，如果 $dfn[x] &lt; low[y]$，则说明从点 $y$ 出发，不经过边 $(x, y)$ 无法到达点 $x$ 或比 $x$ 更早访问的节点，此时的图一定分成了两个或以上的部分。</p>
<p>因为搜索树涵盖了每个节点，所以割边（桥）一定是搜索树的边。如果不是的话，那么存在一条不在搜索树上的边 $(x, t)$ 和在搜索树上的边 $(x, y)$ 同时连通两部分，所以割边不可能不在搜索树上。此外，如果有节点相互成环，那么割边也不在环上，因为无论去掉哪条边，环所属的各个点仍然连通。</p>
<p>求出所有的割边，我们可以按照上面的思路，首先计算每个节点的 dfn 和 low 值，然后遍历每个节点 $i$，对于 $i$ 的每条出边 $(i, j)$ 判断，若 $dfn[i] &lt; low[j]$ 则找到了割边。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;        <span style="color:#75715e">// dfs 序计数
</span><span style="color:#75715e"></span><span style="color:#75715e">// tarjan 的主算法，本质是一个 dfs 函数，x 是 dfs 的起点
</span><span style="color:#75715e"></span><span style="color:#75715e">// in_edge 是入边的编号，如果没有入边则编号 0
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tarjan</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> in_edge) {
    dfn[x] <span style="color:#f92672">=</span> low[x] <span style="color:#f92672">=</span> <span style="color:#f92672">+</span><span style="color:#f92672">+</span>cnt;        <span style="color:#75715e">// 初始化
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 遍历 x 的每条出边
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> head[x]; i; i <span style="color:#f92672">=</span> e[i].next) {
        <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> e[i].v;
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dfn[v]) {  <span style="color:#75715e">// 点 y 未被访问
</span><span style="color:#75715e"></span>            tarjan(v, i);
            low[x] <span style="color:#f92672">=</span> std<span style="color:#f92672">:</span><span style="color:#f92672">:</span>min(low[x], low[y]);
            <span style="color:#75715e">// 割边判定法则
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (low[y] <span style="color:#f92672">&gt;</span> dfn[x]) {
                printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">find bridge: %d, %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, e[i].u, e[i].v);
            }
        }
        <span style="color:#75715e">// (in_edge) ^ 1 表示与入边对应的无向边，如果 i 也不是对边对应的无向边那就不在搜索树中
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!</span><span style="color:#f92672">=</span> (in_edge <span style="color:#f92672">^</span> <span style="color:#ae81ff">1</span>)) {
            low[x] <span style="color:#f92672">=</span> std<span style="color:#f92672">:</span><span style="color:#f92672">:</span>min(low[x], dfn[y]);
        }
    }
}
<span style="color:#75715e">// 对每个未访问的点执行主算法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dfn[i])
        tarjan(i, <span style="color:#ae81ff">0</span>);
</code></pre></div><h2 id="求割点">求割点</h2>
<p>割点的判定法则如下，与割边的大同小异：</p>
<blockquote>
<p>若 $x$ 是搜索树的根节点，则 $x$ 是割点当且仅当 $x$ 有 2 个或以上的子节点。<br>
若 $x$ 不是搜索树的根节点，则 $x$ 是割点，当且仅当搜索树上存在 $x$ 的一个子节点 $y$, 满足 $dfn[x] \leq low[y]$。</p>
</blockquote>
<p>证明：若 $x$ 是根节点，显然删掉 $x$ 后，$x$ 的子树分别成独立的图；若 $x$ 不是根节点且满足上述条件，说明从 $y$ 出发无法到达比 $x$ 更早被访问的节点（但是能访问到 $x$，鉴于 $x$ 会被删除，因此访问了也没有关系）。</p>
<p>求割点仍然是先计算每个节点的 dfn 和 low 值，然后遍历每个节点 $i$，若 $i$ 是根节点则判断 $i$ 的子节点数；若不是则对于 $i$ 的每条出边 $(i, j)$ 判断 $dfn[i] \leq low[j]$ 即可。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, root <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tarjan</span>(<span style="color:#66d9ef">int</span> x) {
    dfn[x] <span style="color:#f92672">=</span> low[x] <span style="color:#f92672">=</span> <span style="color:#f92672">+</span><span style="color:#f92672">+</span>cnt;
    <span style="color:#66d9ef">int</span> child_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> head[x]; i; i <span style="color:#f92672">=</span> e[i].next) {
        <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> e[i].v;
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dfn[y]) {
            tarjan(y);
            low[x] <span style="color:#f92672">=</span> std<span style="color:#f92672">:</span><span style="color:#f92672">:</span>min(low[x], low[y]);
            <span style="color:#66d9ef">if</span> (low[y] <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> dfn[x]) {
                child_count<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
                <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">!</span><span style="color:#f92672">=</span> root <span style="color:#f92672">|</span><span style="color:#f92672">|</span> child_count <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>)
                    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">find cut point %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, x);
            }
        } <span style="color:#66d9ef">else</span> {
            low[x] <span style="color:#f92672">=</span> std<span style="color:#f92672">:</span><span style="color:#f92672">:</span>min(low[x], dfn[y]);
        }
    }
}

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dfn[i])
        root <span style="color:#f92672">=</span> i, tarjan(i);
</code></pre></div><h2 id="求无向图的双连通分量">求无向图的双连通分量</h2>
<p>有关于双连通分量的定义，我们在前面探讨过了。接下来我们分别从求 v-DCC 和求 e-DCC 入手。</p>
<h3 id="求无向图的点双连通分量-v-dcc">求无向图的点双连通分量 v-DCC</h3>
<p>首先引入判定一张无向图是否为点双连通图的法则。无向连通图是点双连通图时，当且仅当该图满足以下两个条件之一：</p>
<blockquote>
<ol>
<li>图的顶点数不超过 2，即 $n \leq 2$；</li>
</ol>
</blockquote>
<ol start="2">
<li>图中任意两点同时包含在至少一个简单环（指不自交的环，就是起点终点都是自己的环）中。</li>
</ol>
<p>例如，在上面的图中，我们有四组点双连通分量，分别是 1,2,3,4,5 / 1,6 / 6,7 / 6,7,8. 在这些点双连通分量中，任选其中一个点出发，一定能够到达分量中的其它任意一点。</p>
<p><img src="https://wx4.sinaimg.cn/large/9f1137b1gy1g185h3zmpyj20gz0aeaa7.jpg" alt="v-DCC example"></p>
<p>求无向图的点双连通分量，我们需要额外维护一个栈。按照以下的流程来维护栈中的元素：</p>
<ol>
<li>循环遍历每一个节点，若发现某个节点的 $dfn[i]$ 未被计算，则以该点为入口执行 Tarjan 算法；</li>
<li>当一个节点第一次被访问的时候，将该节点入栈；</li>
<li>遍历节点 $x$ 的每条出边 $(x, y)$，判断 $x$ 是否为割点，即 $dfn<input checked="" disabled="" type="checkbox">\leq low[y]$ 是否成立；</li>
<li>若 $x$ 为割点，则从栈顶不断弹出节点，直到节点 $y$ 被弹出或栈为空；弹出的所有节点与 $x$ 共同构成一个 v-DCC.</li>
</ol>
<p>比如说，在上面的图中，容易看出割点为 1, 6. 我们不妨以 1 为起点开始执行 Tarjan，1-&gt;2-&gt;3-&gt;4-&gt;5，栈中元素为 5,4,3,2,1；然后回溯到 1 时，发现有 $dfn[1] \leq low[2]$，说明 1 是割点。那么此时弹出栈中的元素直到 2 被弹出为止，弹出 5,4,3,2，最后 1 也是 v-DCC 的一部分，将其加入；然后搜索 6，6 往下搜索 7 / 8,9 又分别得到两个新的 v-DCC；最后回溯到点 1 时，发现 $dfn[1] \leq low[6]$，1-6 构成一个双连通分量。那么直接把 6 取出，与 1 一起得到一个新的 v-DCC. 这样我们就找到了全部的四个 v-DCC.</p>
<p>另外需要额外注意处理一下一个点单独孤立的情况，此时这个点自身形成一个 v-DCC. 最后，汇合起来代码如下：</p>
<p>代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">100000</span>;
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span> {
    <span style="color:#66d9ef">int</span> u, v, next;	
} e[MAXN <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>];
<span style="color:#66d9ef">int</span> head[MAXN], cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, n, m;
<span style="color:#66d9ef">int</span> dfn[MAXN], low[MAXN], dcnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, root <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">bool</span> cut[MAXN];      <span style="color:#75715e">// 记录点 i 是不是割点，这个待会会用到
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
std<span style="color:#f92672">:</span><span style="color:#f92672">:</span>stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> s;
std<span style="color:#f92672">:</span><span style="color:#f92672">:</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> dcc[MAXN];
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addEdge</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> v) {
    e[cnt] <span style="color:#f92672">=</span> (Edge) {u, v, head[u]};
    head[u] <span style="color:#f92672">=</span> cnt;
    cnt<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tarjan</span>(<span style="color:#66d9ef">int</span> x) {
    dfn[x] <span style="color:#f92672">=</span> low[x] <span style="color:#f92672">=</span> dcnt<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
    s.push(x);
    <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">=</span><span style="color:#f92672">=</span> root <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> head[x] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {		<span style="color:#75715e">// 孤立点，单独成图 
</span><span style="color:#75715e"></span>        dcc[ans<span style="color:#f92672">+</span><span style="color:#f92672">+</span>].push_back(x);
        <span style="color:#66d9ef">return</span>;
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> head[x]; i; i <span style="color:#f92672">=</span> e[i].next) {
        <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> e[i].v;
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dfn[y]) {
            tarjan(y);
            low[x] <span style="color:#f92672">=</span> std<span style="color:#f92672">:</span><span style="color:#f92672">:</span>min(low[x], low[y]);
            <span style="color:#66d9ef">if</span> (low[y] <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> dfn[x]) {		<span style="color:#75715e">// x 是割点 
</span><span style="color:#75715e"></span>                cut[x] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
                <span style="color:#66d9ef">int</span> tmp;
                <span style="color:#66d9ef">do</span> {
                    tmp <span style="color:#f92672">=</span> s.top();
                    s.pop();
                    dcc[ans].push_back(tmp);
                } <span style="color:#66d9ef">while</span> (tmp <span style="color:#f92672">!</span><span style="color:#f92672">=</span> y);
                dcc[ans].push_back(x);
                ans<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
            }
        } <span style="color:#66d9ef">else</span> {
            low[x] <span style="color:#f92672">=</span> std<span style="color:#f92672">:</span><span style="color:#f92672">:</span>min(low[x], dfn[y]);
        }
    }
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    memset(e, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">sizeof</span> e);
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">int</span> u, v;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>u, <span style="color:#f92672">&amp;</span>v);
        addEdge(u, v);
        addEdge(v, u);
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dfn[i]) {
            root <span style="color:#f92672">=</span> i;
            tarjan(i);
        }
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> ans; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
        printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">v-DCC #%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> dcc[i].size(); j<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)
            printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d </span><span style="color:#e6db74">&#34;</span>, dcc[i][j]);
        printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>测试数据：</p>
<pre><code>9 11
1 2
2 3
3 4
4 5
2 5
1 5
1 6
6 7
6 8
8 9
6 9
</code></pre><h3 id="求无向图的-e-dcc">求无向图的 e-DCC</h3>
<p>求无向图的边双连通分量就比较简单，首先我们使用 Tarjan 算法标记处所有的桥，然后对整个无向图进行一次 DFS，对于节点 $x$ 的出边 $(x, y)$，如果它是割边，则跳过这条边不沿着它往下走；这样我们可以划分出多个连通块，连通块的数目及其包括的节点，就是我们所求的 e-DCC 的数量和包含的节点。</p>
<p>以上面的图为例，图中应该有 2 条割边 (1, 6) 和 (6, 7)，因此有 3 个边双连通分量，如图所示：</p>
<p><img src="https://ws3.sinaimg.cn/large/9f1137b1gy1g186y41wimj20ju0e0t94.jpg" alt="e-dcc example"></p>
<p>我们设置一个新的变量 $c[i]$ 来表示节点 $i$ 所属的 $e-DCC$ 的编号。可以发现，删去割边后，我们在一次 DFS 中访问到的节点都在同一个 e-DCC 中，所以具有相同的 $c[i]$ 值。代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">100000</span>;
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span> {
    <span style="color:#66d9ef">int</span> u, v, next;	
} e[MAXN <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>];
<span style="color:#66d9ef">int</span> head[MAXN], cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>, n, m;		<span style="color:#75715e">// 为了进行异或运算找到边，必须设定前向星 cnt 起点为 2 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> dfn[MAXN], low[MAXN], dcnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">int</span> c[MAXN], dcc <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">bool</span> is_bridge[MAXN];
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addEdge</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> v) {
    e[cnt] <span style="color:#f92672">=</span> (Edge) {u, v, head[u]};
    head[u] <span style="color:#f92672">=</span> cnt;
    cnt<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tarjan</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> in_edge) {
    dfn[x] <span style="color:#f92672">=</span> low[x] <span style="color:#f92672">=</span> dcnt<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> head[x]; i; i <span style="color:#f92672">=</span> e[i].next) {
        <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> e[i].v;
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dfn[y]) {
            tarjan(y, i);
            low[x] <span style="color:#f92672">=</span> std<span style="color:#f92672">:</span><span style="color:#f92672">:</span>min(low[x], low[y]);
            <span style="color:#66d9ef">if</span> (low[y] <span style="color:#f92672">&gt;</span> dfn[x]) {		<span style="color:#75715e">// x 是割边 
</span><span style="color:#75715e"></span>                printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">edge (%d, %d) is bridge.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, x, y);
                is_bridge[i] <span style="color:#f92672">=</span> is_bridge[i <span style="color:#f92672">^</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;	<span style="color:#75715e">// 标记该边及其反向边为桥 
</span><span style="color:#75715e"></span>            }
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">!</span><span style="color:#f92672">=</span> (in_edge <span style="color:#f92672">^</span> <span style="color:#ae81ff">1</span>)) {
            low[x] <span style="color:#f92672">=</span> std<span style="color:#f92672">:</span><span style="color:#f92672">:</span>min(low[x], dfn[y]);
        }
    }
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> x) {
    c[x] <span style="color:#f92672">=</span> dcc;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> head[x]; i; i <span style="color:#f92672">=</span> e[i].next) {
        <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> e[i].v;
        <span style="color:#75715e">// 节点 y 已被访问或者 (x,y) 是桥 
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (c[y] <span style="color:#f92672">|</span><span style="color:#f92672">|</span> is_bridge[i])
            <span style="color:#66d9ef">continue</span>;
        dfs(y);
    }
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    memset(e, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">sizeof</span> e);
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">int</span> u, v;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>u, <span style="color:#f92672">&amp;</span>v);
        addEdge(u, v);
        addEdge(v, u);
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dfn[i]) {
            tarjan(i, <span style="color:#ae81ff">0</span>);
        }
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>c[i]) {
            dcc<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
            dfs(i);
        }
    }
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">There are %d e-DCCs.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dcc);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
        printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">node %d belongs to e-dcc %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> , i, c[i]);
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="e-dcc-的缩点">e-DCC 的缩点</h3>
<p>对无向图的边双连通分量进行缩点很简单，因为我们上面已经求出了每个点所属的 e-DCC, 因此我们只需要遍历每条边 $(x, y)$，如果这条边所连的点 $x, y$ 有 $c[x] = c[y]$，说明他们属于同一个 e-DCC，不需要做任何事情；否则，说明 $(x, y)$ 是割边，将 x, y 加入一张新的图中。完成后新的图就是我们想要的缩完点之后的树或森林。</p>
<p>下面是 e-DCC 缩点的代码，配合上面求 e-DCC 的代码食用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Edge ec[MAXN <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>];
<span style="color:#66d9ef">int</span> hc[MAXN], cecnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_cut_edge</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> v) {
    ec[cecnt] <span style="color:#f92672">=</span> (Edge) {u, v, hc[u]};
    hc[u] <span style="color:#f92672">=</span> cecnt<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
}
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> cnt; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {    <span style="color:#75715e">// cnt 是原图的边数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> e[i].x, y <span style="color:#f92672">=</span> e[i].y;
    <span style="color:#66d9ef">if</span> (c[x] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> c[y])
        <span style="color:#66d9ef">continue</span>;                   <span style="color:#75715e">// x, y 同属一个 e-DCC, 无事可做
</span><span style="color:#75715e"></span>    add_cut_edge(x, y);             <span style="color:#75715e">// 否则将 x, y 加入新树中
</span><span style="color:#75715e"></span>}

printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">finish point reducing operation, new tree/forest has %d nodes and %d edges: </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, dcc, cecnt <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>); <span style="color:#75715e">// 除 2 是因为有重边
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;</span> cecnt; i <span style="color:#f92672">+</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>)
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, e[i].u, e[i].v);
</code></pre></div><h3 id="v-dcc-的缩点">v-DCC 的缩点</h3>
<p>v-DCC 的缩点由于引入了新的关联节点，因此就显得比较复杂。在求完 v-DCC 的基础上，我们的操作步骤是这样的：</p>
<ol>
<li>给每个割点一个新的编号，从 ans+1 开始，ans 表示 v-DCC 的个数。</li>
<li>建立一张新的图，加入每个 v-DCC 和该 v-DCC 所包含的所有割点的连边。</li>
</ol>
<p>大家可以对照着 0x01 的定义部分，模拟一下上面的步骤。下面是代码，<!-- raw HTML omitted -->熟读并背诵即可<!-- raw HTML omitted -->：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 给割点编号
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> new_id[MAXN], num <span style="color:#f92672">=</span> ans;
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)
    <span style="color:#66d9ef">if</span> (cut[i])
        new_id[i] <span style="color:#f92672">=</span> <span style="color:#f92672">+</span><span style="color:#f92672">+</span>num;

<span style="color:#75715e">// 建立新图
</span><span style="color:#75715e"></span>Edge ec[MAXN <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>];
<span style="color:#66d9ef">int</span> hc[MAXN], cdcnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_vdcc_edge</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> v) {
    ec[cdcnt] <span style="color:#f92672">=</span> (Edge) {u, v, hc[u]};
    hc[u] <span style="color:#f92672">=</span> cdcnt<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
}
<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> ans; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {          <span style="color:#75715e">// ans 是 v-DCC 数 -1
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> dcc[i].size(); j<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
        <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> dcc[i][j];
        <span style="color:#66d9ef">if</span> (cut[x]) {
            add_vdcc_edge(i, new_id[x]);
            add_vdcc_edge(new_id[x]. i);
        } <span style="color:#66d9ef">else</span> {
            c[x] <span style="color:#f92672">=</span> i;           <span style="color:#75715e">// 除了割点之外，标记其它的点只属于一个 v-DCC
</span><span style="color:#75715e"></span>        }
    }
}

printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">finish point reducing operation, new tree/forest has %d nodes and %d edges: </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, ans, cdcnt <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>); <span style="color:#75715e">// 除 2 是因为有重边
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;</span> tc; i <span style="color:#f92672">+</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>) {
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, e[i].u, e[i].v);
}
</code></pre></div><h1 id="0x03-tarjan-在有向图中的应用">0x03 Tarjan 在有向图中的应用</h1>
<h2 id="求有向图的强连通分量">求有向图的强连通分量</h2>
<p>在定义一节中我们提到，一个环一定是一个强连通图。因此，Tarjan 算法求解有向图的强连通分量的基本思路，就是对于每个节点 $i$，尽量找到能与它一起成环的所有节点；找到这些节点之后自然就找到了一张原图的极大连通子图，也就是强连通分量 SCC.</p>
<p>刚刚我们提到，一张流图中有四种边，分别为“树枝边”、“前向边”、“后向边”和“横叉边”。现在我们考虑搜索树上的节点加上这些边如何能成环。根据刚才的定义，后向边是由搜索树中的子节点指向祖先节点的边，因此后向边连通的两个点及两个点在 DFS 中经过的节点一定构成环。而横叉边比较特殊，如果存在一条横叉边 $(x,y)$，满足从 $y$ 出发能找到一条路径回到 $x$ 的祖先节点，那么 $(x, y)$ 就是有用的。</p>
<p>接下来就是，如何利用这两类边去找环。我们需要维护一个栈，当 Tarjan 主算法进行 DFS 到节点 $x$ 的时候，栈中需要保存两类节点：第一类是 $anc(x)$，即 $x$ 在搜索树上的祖先节点的<strong>集合</strong>；第二类是节点 $i$ 满足 $vis[i] = 1$ 且 $\exists e_{ij}$ 使 $e_{ij}$ 连接 $i$ 和 $anc(x)$ 中的一点（也就是说已访问过、并且存在一条路径到达 $anc(x)$ 集合元素的节点）。我们分别说说存这两类节点有什么意义。</p>
<p>首先是维护 $anc(x)$ 的意义，设 $y$ 是 $x$ 的一个祖先节点即 $y \in anc(x)$, 如果存在后向边 $(x, y)$，则 $y$ 到 $x$ 的路径与边 $(x, y)$ 共同成环。其次是维护已访问过可达 $anc(x)$ 的点的意义，主要用于处理横叉边，如果有节点 $z$ 满足从 $z$ 出发存在一条路径可以到达 $y \in anc(x)$, 那么如果存在横叉边 $(x,z)$，则 $z \to y$, $y \to x$ 和边 $(x, z)$ 成环。</p>
<p><img src="https://ws3.sinaimg.cn/large/9f1137b1gy1g18dscdjtnj210a0eo0uc.jpg" alt="栈的作用图解"></p>
<p>同样的，我们在有向图的 Tarjan 中也存在追溯值的概念。基本计算方法和无向图的追溯值方法是大同小异的，因为引入了边的方向，所以我们在 DFS 和回溯计算的时候需要特别注意：</p>
<ol>
<li>$dfn$ 与 $low$ 的初始化，与无向图中求追溯值相同，令 $dfn<input checked="" disabled="" type="checkbox">= low<input checked="" disabled="" type="checkbox">= ++order$.</li>
<li>扫描 $x$ 的每条出边 $(x,y)$，如果 $y$ 是搜索树上的节点（$(x, y)$ 是树枝边），那么 $y$ 就没有被访问过，计算完 $low[y], dfn[y]$ 回溯时令 $low<input checked="" disabled="" type="checkbox">= min(low<input checked="" disabled="" type="checkbox">, low[y])$.</li>
<li>如果 $y$ 不是搜索树上的节点，那么 $y$ 一定被访问过，此时 $(x, y)$ 是后向边，令 $low<input checked="" disabled="" type="checkbox">= min(low<input checked="" disabled="" type="checkbox">, dfn[y])$.</li>
<li><strong>从 $x$ 回溯之前判断是否有 $low<input checked="" disabled="" type="checkbox">= dfn<input checked="" disabled="" type="checkbox">$ 成立，如果是的话将栈顶元素弹出直到 $x$ 出栈为止</strong>。</li>
</ol>
<p>可以发现，有向图的 Tarjan 算法相比无向图，在判断 $(x,y)$ 是否为搜索树上的边时，用的是指向的结点是否在栈中的判断法；并且有向图在计算完 $low[x]$ 之后，还需要根据条件 $low[x] = dfn[x]$ 是否成立，将栈顶元素弹出，防止后面的 DFS 过程中误将其它分支的节点当做祖先节点。</p>
<p>以前文的有向图为例计算追溯值，特别注意圈出来的几个节点：因为节点 $5$ 存在通向祖先节点 $2$ 的节点，所以 $low[5] = dfn[2] = 2$，再层层回溯，得到 $low[2] = low[3] = low[4] = low[5] = 2$. 最后在回溯到 $2$ 的时候，发现 $dfn[2] = low[2]$ 成立，那么弹出栈中的元素 $5,4,3,2$.<br>
$6-8-9$ 的搜索也同理。<br>
注意节点 $7$，虽然它有一条指向 $4$ 的横叉边，但是搜索到 $7$ 的时候，$4$ 已经不在栈中了，说明这条横叉边并没有什么存在的意义。注意我们之前说过，横叉边 $(x, y)$，只有从 $y$ 能找到一条通往 $x$ 及其祖先节点的路径，这条边才有用。</p>
<p><img src="https://wx2.sinaimg.cn/large/9f1137b1gy1g18e808hu3j20ij0ecaam.jpg" alt="有向图的追溯值计算示意图"></p>
<p>说了这么多，我们还没有说到用 Tarjan 到底怎么求有向图的强连通分量。其实很简单，在上面的图中我们发现，四个强连通分量是 2,3,4,5 / 6,8,9 / 7 / 1；而这两个强连通分量都是<strong>计算追溯值的第四步中，从栈里弹出来的节点</strong>。也就是说我们得到了 Tarjan 算法中<strong>强连通分量的判定法则：</strong></p>
<blockquote>
<p>在追溯值的计算过程中，若从 $x$ 回溯前，有 $low[x] = dfn[x]$ 即 $x$ 的追溯值=DFS序，那么在栈中，从 $x$到栈顶的所有节点构成一个强连通分量。</p>
</blockquote>
<p>注意我在判定法则前加了一个定语“Tarjan 算法中”，说明这个法则只有在 Tarjan 算法的特定场景下有意义。上述法则的合理性在于，如果 $dfn[x] = low[x]$，说明子节点可以到达 $x$, 但并不能到达比 $x$ 更早被 DFS 的节点，自然不会和更先前的点成环。</p>
<p>模板代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> std<span style="color:#f92672">:</span><span style="color:#f92672">:</span>stack;
<span style="color:#66d9ef">using</span> std<span style="color:#f92672">:</span><span style="color:#f92672">:</span>vector;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">100000</span>;
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span> {
    <span style="color:#66d9ef">int</span> u, v, next;
} e[MAXN <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>];
<span style="color:#66d9ef">int</span> head[MAXN], cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">int</span> dfn[MAXN], low[MAXN], order <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">int</span> c[MAXN];			<span style="color:#75715e">// 缩点的时候会用到，表示节点 i 所属的 scc 编号 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n, m, scccnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">bool</span> instack[MAXN];
vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> scc[MAXN];
stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> s;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addEdge</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> v) {
    e[cnt] <span style="color:#f92672">=</span> (Edge){ u, v, head[u] };
    head[u] <span style="color:#f92672">=</span> cnt<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tarjan</span>(<span style="color:#66d9ef">int</span> x) {
    dfn[x] <span style="color:#f92672">=</span> low[x] <span style="color:#f92672">=</span> order<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
    s.push(x);
    instack[x] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> head[x]; i; i <span style="color:#f92672">=</span> e[i].next) {
        <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> e[i].v;
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dfn[y]) {
            tarjan(y);
            low[x] <span style="color:#f92672">=</span> std<span style="color:#f92672">:</span><span style="color:#f92672">:</span>min(low[x], low[y]);
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (instack[y]) {
            low[x] <span style="color:#f92672">=</span> std<span style="color:#f92672">:</span><span style="color:#f92672">:</span>min(low[x], dfn[y]);
        }
    }
    <span style="color:#66d9ef">if</span> (dfn[x] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> low[x]) {
        <span style="color:#66d9ef">int</span> tmp;
        <span style="color:#66d9ef">do</span> {
            tmp <span style="color:#f92672">=</span> s.top();
            c[tmp] <span style="color:#f92672">=</span> scccnt;
            instack[tmp] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
            s.pop();
            scc[scccnt].push_back(tmp);
        } <span style="color:#66d9ef">while</span> (tmp <span style="color:#f92672">!</span><span style="color:#f92672">=</span> x);
        scccnt<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
    }
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">int</span> u, v;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
        scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>u, <span style="color:#f92672">&amp;</span>v);
        addEdge(u, v);
    }
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dfn[i]) {
            tarjan(i);
        }
    }
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Find %d SCC(s.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, scccnt);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> scccnt; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
        printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">SCC #%d: </span><span style="color:#e6db74">&#34;</span>, i);
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> scc[i].size(); j<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)
            printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d </span><span style="color:#e6db74">&#34;</span>, scc[i][j]);
        printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>测试数据：</p>
<pre><code>9 13
1 2
2 3
3 4
4 5
5 2
1 5
1 6
6 7
7 4
8 7
6 8
8 9
9 6
</code></pre><h2 id="scc-的缩点">SCC 的缩点</h2>
<p>SCC 的缩点和 e-DCC 的缩点比较类似，不过最后得到的应该是一张 DAG(有向无环图)。上面我们用 $c[i]$ 记录了节点 $i$ 所属的 SCC 的编号，我们对原图的每条边 $(x,y)$ 遍历判断，若 $c[x] \neq c[y]$，就在编号为 $c[x]$ 与 $c[y]$ 的 SCC 之间连边。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Edge ec[MAXN];
<span style="color:#66d9ef">int</span> hc[MAXN], ccnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_scc_edge</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> v) {
    ec[ccnt] <span style="color:#f92672">=</span> (Edge) { u, v, hc[u] };
    hc[u] <span style="color:#f92672">=</span> ccnt<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
}

<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; x <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; x<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> head[x]; i; i <span style="color:#f92672">=</span> e[i].next) {
        <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> e[i].v;
        <span style="color:#66d9ef">if</span> (c[x] <span style="color:#f92672">=</span><span style="color:#f92672">=</span> c[y])
            <span style="color:#66d9ef">continue</span>;
        add_scc_edge(c[x], c[y]);
    }
}
</code></pre></div><h1 id="0x04-one-more-thing---kosaraju">0x04 One More Thing - Kosaraju</h1>
<p>到上面为止 Tarjan 算法就讲的差不多了。不知道读者有什么感想，我第一次看这些东西的时候满脑子的 WTF，说好要用简明的语言复述一遍，这样下来我已经混乱了。因为 Tarjan 实在是太复杂了（虽然理解之后，代码量是很小的），这里还是要再讲一种稍微简单些的，用来求有向图的强连通分量的算法——Kosaraju 算法。</p>
<p>Kosaraju 算法也可以在线性时间内求出有向图的强连通分量。虽然 Kosaraju 的时间也是线性的，但是因为 Kosaraju 的算法步骤需要对图进行两次遍历，而 Tarjan 算法只需要遍历一次图中的节点，因此实际运用中 Kosaraju 的效率是要略低于 Tarjan 的，但是 Kosaraju 的原理比 Tarjan 简单的呢。有多简单呢？我们来看一张有向图：</p>
<p><img src="https://wx3.sinaimg.cn/large/9f1137b1gy1g18fj1rk1rj20jg07omx8.jpg" alt="kosaraju-example-1"></p>
<p>在上图中，如果不计单点自己组成的强连通分量，那么很明显有两个强连通的子图：1,2,3 / 5,6,7. 现在我们对这张有向图的边取反（就是把原来的边方向反过来），得到图$G_r$：</p>
<p><img src="https://wx3.sinaimg.cn/large/9f1137b1gy1g18flylwm8j20qw07cdfy.jpg" alt="kosaraju-example-2"></p>
<p>此时，我们任选 $G_r$ 中的一个节点为起点，利用深度优先搜索求出 $G_r$ 的逆后序。什么是逆后序呢？我们的 DFS 节点顺序分为前序、后序、逆后序三种，取决于节点在何时被加入什么样的数据结构中，一般我们定义：</p>
<blockquote>
<p>前序：在<strong>递归调用下一级 DFS 函数之前</strong>，将当前节点加入<strong>队列</strong><br>
后序：在递归调用下一级 DFS 完成<strong>回溯之后</strong>，将当前节点加入<strong>队列</strong><br>
逆后序：在递归调用下一级 DFS 完成<strong>回溯之后</strong>，将当前节点加入<strong>栈</strong></p>
</blockquote>
<p>因此，以 $5$ 为 DFS 起点对 $G_r$ 求逆后序，入栈顺序是：6 7 1 2 3 4 5，而逆后序是从栈顶到栈底的顺序，则逆后序是 5 4 3 2 1 7 6.</p>
<p>接下来，我们按照得到的逆后序，再对原图进行一次 DFS：<strong>在同一个 DFS 递归子程序中访问的点，一定是同属一个连通分量的</strong>，例如对上面的图，如下图所解释：</p>
<p><img src="https://ws2.sinaimg.cn/large/9f1137b1gy1g18imhfryjj20xz0kbmyw.jpg" alt="kosaraju-explanation"></p>
<p>这样就求出有向图的强连通分量啦。让我们来理一遍主算法的思路：</p>
<ol>
<li>对于有向图 $G$, 将其每条边取逆 ($(x, y) \to (y, x)$)，得到一张新图 $G_r$，这是 $G$ 的反向图；</li>
<li>建立一个栈 $s$, 遍历图 $G_r$ 所有的节点，进行 DFS 求逆后序，并标记已访问的节点；</li>
<li>按照 $s$ 栈顶到栈底的节点顺序，对 $G$ 再进行一次 DFS，<strong>同一个 DFS 递归子程序中访问的点同属一个 SCC.</strong></li>
</ol>
<p>代码如下，我实在很难找到网上有的 Kosaraju 的算法 C++ 版本，所以自己撸了一个：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> std<span style="color:#f92672">:</span><span style="color:#f92672">:</span>stack;
<span style="color:#66d9ef">using</span> std<span style="color:#f92672">:</span><span style="color:#f92672">:</span>vector;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">100000</span>;
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Edge</span> {
	<span style="color:#66d9ef">int</span> u, v, next;
} e[MAXN <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>], rev[MAXN <span style="color:#f92672">&lt;</span><span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1</span>];
<span style="color:#66d9ef">int</span> head[MAXN], head_rev[MAXN], cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>, scccnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">int</span> n, m;
<span style="color:#66d9ef">bool</span> vis[MAXN];
vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> scc[MAXN];
stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> reverse_postorder, s2;
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addEdge</span>(<span style="color:#66d9ef">int</span> u, <span style="color:#66d9ef">int</span> v) {
	e[cnt] <span style="color:#f92672">=</span> (Edge){ u, v, head[u] };
	head[u] <span style="color:#f92672">=</span> cnt<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">reverse_graph</span>() {
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span> cnt; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
		rev[i] <span style="color:#f92672">=</span> (Edge){ e[i].v, e[i].u, head_rev[e[i].v] };
		head_rev[e[i].v] <span style="color:#f92672">=</span> i;
	}
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs_reverse_postorder</span>(<span style="color:#66d9ef">int</span> x) {
	vis[x] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> head_rev[x]; i; i <span style="color:#f92672">=</span> rev[i].next) {
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[rev[i].v]) {
			dfs_reverse_postorder(rev[i].v);
		}
	}
	reverse_postorder.push(x);
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dfs</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">bool</span> root) {
	vis[x] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
	s2.push(x);
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> head[x]; i; i <span style="color:#f92672">=</span> e[i].next) {
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[e[i].v]) {
			vis[e[i].v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
			dfs(e[i].v, false);
		}
	}
	<span style="color:#66d9ef">if</span> (root <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> <span style="color:#f92672">!</span>s2.empty() <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> s2.size() <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>) {
		<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>s2.empty()) {
			scc[scccnt].push_back(s2.top());
			s2.pop();
		}
		scccnt<span style="color:#f92672">+</span><span style="color:#f92672">+</span>;
	} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (root) {
		s2.pop();
	}
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>n, <span style="color:#f92672">&amp;</span>m);
	<span style="color:#66d9ef">int</span> u, v;
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> m; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
		scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>u, <span style="color:#f92672">&amp;</span>v);
		addEdge(u, v);
	}
	reverse_graph();
	
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i <span style="color:#f92672">&lt;</span><span style="color:#f92672">=</span> n; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[i]) {
			dfs_reverse_postorder(i);
		}
	}
	
	memset(vis, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span> vis);
	
	<span style="color:#66d9ef">while</span> (<span style="color:#f92672">!</span>reverse_postorder.empty())  {
		<span style="color:#66d9ef">int</span> s <span style="color:#f92672">=</span> reverse_postorder.top();
		reverse_postorder.pop();
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>vis[s])
			dfs(s, <span style="color:#ae81ff">1</span>);
	}
	
	printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Find %d SCC(s).</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, scccnt);
	<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> scccnt; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
		printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">SCC #%d: </span><span style="color:#e6db74">&#34;</span>, i);
		<span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> scc[i].size(); j<span style="color:#f92672">+</span><span style="color:#f92672">+</span>) {
			printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d </span><span style="color:#e6db74">&#34;</span>, scc[i][j]);
		}
		printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
	}
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h1 id="0x05-reference">0x05 Reference</h1>
<p>部分内容和代码参考李煜东的《算法竞赛进阶指南》，在此特别感谢。</p>
                    <HR width="100%" id="EOF">
                    <p style="color:#777;">Last modified on 2019-03-18</p>
                </div>
                
            </div>
            
            
            <nav class="post-pagination">

                
                <a class="newer-posts" href="https://kirainmoe.com/blog/post/tfug-tensorflow-dev-summit-ext/">
                    Next<br>[2019] TF Dev Summit Ext
                </a>
                
                
                
                <a class="older-posts" href="https://kirainmoe.com/blog/post/xmu-acm-training-record-3/">
                    Previous<br>[19-3-16] XMU ACM 集训队笔记(3)
                </a>
                
            </nav>
            <div class="post-comment-wrapper">
                
<div class="post-comment-wrapper">
<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "yume-diary" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>




            </div>
        </div>
    </div>
</div>

            </div><div id="single-column-footer">&copy;
	
	2016-2020 宇宙よりも遠い場所
	

/

<a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC-BY-SA 4.0</a>

<br>

Published with <a href="https://gohugo.io">Hugo</a> / Theme <a href="https://github.com/amazingrise/hugo-theme-diary" title="Author: Rise @ amazingrise.net">Diary</a>
</div>
    	</div>
    <script src="https://kirainmoe.com//js/journal.js"></script>
    </body>
</html>
