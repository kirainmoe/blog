<body class="line-numbers">
  <!DOCTYPE html>
<html lang="en-us">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta content="" name="keywords">
<meta content="每周解题报告 (3rd, 8/14~8/20) - 比宇宙更远的地方" property="og:title">
<title>每周解题报告 (3rd, 8/14~8/20) | 比宇宙更远的地方</title>
<script src="https://unpkg.com/muse-player/dist/assets/muse-player.js"></script>
<link href="https://fonts.googleapis.com/css?family=Poppins" rel="stylesheet">
<link rel="stylesheet" href="https://kirainmoe.com//css/style.css">
<link rel="stylesheet" href="https://kirainmoe.com//css/custom.css">
<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.css" integrity="sha384-9tPv11A+glH/on/wEu99NVwDPwkMQESOocs/ZGXPoIiLE8MU/qkqUcZ3zzL+6DuH" crossorigin="anonymous">
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        showProcessingMessages: false,
        messageStyle: "none", 
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [["$", "$"], ["\\(", "\\)"]],
          displayMath: [["$$", "$$"], ["\\[", "\\]"]],
          skipTags: ["script", "noscript", "style", "textarea", "pre", "code", "a"]
        },
        "HTML-CSS": {
          availableFonts: ["STIX", "TeX"], 
          showMathMenu: false
        }
	  });
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/themes/prism-solarizedlight.min.css">
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/plugins/line-numbers/prism-line-numbers.min.css">

<style type="text/css">
	.nav-left {	display: block; text-align: left; }
	.nav-link { display: inline-block; margin: 0px 20px 0px 0px;  }
	.nav-item { justify-content: flex-start;  }
	.nav-title { margin: 0px; font-size: 28px; font-weight: bold;  }
	.nav-title a { padding: 10px 0px;  }
	@media screen and (max-width: 700px) {
		.nav { display: block; text-align: center;  }
		.nav-title > .nav-item { display: block;  text-align: center; }
		.nav-left { text-align: center;  }
	}
</style>

  <section class="section navigator">
  <div class="navigator-background"></div>
  <div class="container">
    <nav class="nav">
      <div class="nav-left">
        <h1 class="nav-title"><a class="nav-item" href="https://kirainmoe.com/">比宇宙更远的地方</a></h1>
        <div class="nav-links">
          <a class="nav-link" href="/pages/guestbook/">Guestbook</a>
          <a class="nav-link" href="/pages/friends/">Friends</a>        
          <a class="nav-link" href="https://about.me/kirainmoe">About</a>
        </div>
      </div>
      <div class="nav-right">
        <nav class="nav-item level is-mobile">
          
          <a class="level-item" href="https://github.com/kirainmoe">
            <span class="icon">
              <i class="fa fa-github"></i>
            </span>
          </a>
          
          <a class="level-item" href="https://weibo.com/returnnnn">
            <span class="icon">
              <i class="fa fa-weibo"></i>
            </span>
          </a>
          
          <a class="level-item" href="https://acm.kirainmoe.com">
            <span class="icon">
              <i class="fa fa-tumblr"></i>
            </span>
          </a>
          
          <a class="level-item" href="/index.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>
          </a>
          
        </nav>
      </div>
    </nav>
  </div>
</section>

<div class="return-top">
  <i class="fa fa-angle-up"></i>
</div>

<div class="loading-progress"></div>
  <section class="section content-container">
    <div class="container article-here">
      <h2 class="subtitle is-6">August 20, 2017</h2>
      <h1 class="title">每周解题报告 (3rd, 8/14~8/20)</h1>
      
      <div class="tags">
    
        <a class="button is-link" href="/tags/algorithm">algorithm</a>
    
        <a class="button is-link" href="/tags/oi">oi</a>
    
</div>

      
      <div class="content">
        <p>这周主要是尝试了一些新的东西（ 做了一些之前一直想看但是一直没看懂和没做的题目。依旧是做 HDU 的题。虽然写得不是很熟练，不过慢慢来应该也是可以的。
另外下周由于要阶段考试这样子，可能就没有时间做题目了。</p>

<div class="muse-app"></div>

<script type="text/javascript">
var playList = [{
    title: 'やくそく',
    artist: '三森すずこ / 花澤香菜',
    src: 'https://api.kotori.love/netease/mp3?id=488256626',
    cover: 'http://p1.music.126.net/9uq04GzHBnhhJCgQTccq_Q==/19012755067719433.jpg',
    lyric: '[by:lyricshare]\n[00:25.93]さよならじゃない今未来が始まるんだ\n[00:37.23]淡い蕾は花開いて祝福を歌う\n[00:48.93]秘密の場所に埋めたのは\n[00:54.65]密かな夢と宝の地図\n[01:00.94]時間巡りを閉じ込めた\n[01:06.41]小さなガラスの欠片だった\n[01:11.87]あの時 君は君は勇気を得た\n[01:17.79]友を信じ抜く勇気を得た\n[01:23.80]永遠に消えない誇りになるだろう\n[01:29.83]最後の鐘が響き出す\n[01:35.33]たとえ涙が落ちてしまうとしても\n[01:41.03]下を向いたりしないと誓おう\n[01:47.39]そっと重ねた思い出の数だけ\n[01:53.20]光ゆらめいて背中を押した\n[02:05.22]流れ続ける砂時計のような時よ\n[02:16.67]翼広げてさあ飛び立とう地平線の果て\n[02:28.44]あどけなかった横顔が\n[02:34.10]凛々しくなったはいつの日か\n[02:40.03]速まる日々に負けぬよう\n[02:45.85]毎日夢中で追いかけてた\n[02:51.57]あの時君は君は希望を見た\n[02:57.28]暗闇に浮かぶ 希望を見た\n[03:03.14]行き先照らす明かりになるだろう\n[03:09.24]もう迷うことはないんだ\n[03:14.94]いつか傷つくことがあるとしても\n[03:20.64]友がくれた言葉を胸に\n[03:27.03]傷を癒して進み続けるよ\n[03:32.70]きっとその先でまた会えるから\n[04:01.90]あの時君は君は勇気を得た\n[04:07.50]友を信じ抜く勇気を得た\n[04:13.36]永遠に消えない誇りになるだろう\n[04:19.78]最後の鐘が響き出す\n[04:24.82]たとえ 涙が落ちてしまうとしても\n[04:30.82]下を向いたりしないと誓おう\n[04:37.28]そっと重ねた思い出の数だけ\n[04:42.95]光ゆらめいて背中を押した\n[04:54.83]あのね ありがとう またあの場所で',
    translation: '这并不是永别 未来从现在才开始\n含苞待放的花蕾盛开 颂唱祝福之歌\n在秘密场所里埋藏的是\n潜藏于心的梦想与藏宝图\n将反复的时间紧闭门中\n化成了小小的玻璃碎片\n那时候 是你让我获得了勇气\n让我获得了坚信朋友的勇气\n它会成为我永不消逝的骄傲吧\n终结的钟声响起\n让我们发誓 即便再流下眼泪\n也不再低下头\n只有那默默积累下的记忆\n在虚渺的光芒中一直支持着我\n时间仿佛不断流逝的沙漏\n张开双翼 向着地平线的尽头翱翔吧\n你那天真烂漫的侧脸\n不知在何时已变得如此冷酷严峻\n为了不输给忙碌的生活\n每日都不顾一切地追赶\n在那时 是你让我看见了希望\n让我看见了在黑暗中浮现的希望\n它会成为我通向终点的照明灯吧\n我已经不会再次迷失自我了\n即便在未来某刻会受伤\n朋友托付于我的咒语 也会在我心中\n治愈着我的伤痕 让我向前迈进\n一定会在前方再次相遇吧\n那时候 是你让我获得了勇气\n让我获得了坚信朋友的勇气\n它会成为我永不消逝的骄傲吧\n终结的钟声响起\n让我们发誓 即便再流下眼泪\n也不再低下头\n只有那默默积累下的记忆\n在虚渺的光芒中一直支持着我\n我想对你说 谢谢你 让我们再次在那个地方相遇吧'
}];

MUSE.render(playList, document.querySelector('.muse-app'));
</script>

<h1 id="8-200-hdu5489-removed-interval"><sup>8</sup>&frasl;<sub>200</sub>, HDU5489, Removed Interval</h1>

<h2 id="题意-扯淡">题意 &amp; 扯淡</h2>

<p>题意就是已知一个数列，从中删除连续的 n 个数，然后要使得删除完之后它的最长上升子序列最大。n &lt;= 1e5.</p>

<p>这题好像有很多的解法，有用传统 LIS 做的，还有用 LIS + BIT 或者 LIS + Segment Tree 做的……后面两种做法没能理解（说实话，第一种做法也没怎么能理解），所以我还是硬着头皮看了一下直接做的。</p>

<h2 id="所谓题解">所谓题解</h2>

<p>因为要从数列中删除一些数之后求 LIS，然后就是我们枚举删除的数的终点，然后对终点右边的第一个数为起点求一次 LIS
然后再从最左边到删除的起点求一次 <strong>最大的数不超过终点右边第一个数</strong> 的 LIS
从右往左的这个 LIS 必须在枚举起点之前预处理求出，所以：
从右往左求 LIS 可以用负数的方法来做，然后倒着求回来，一直从 n 求到 l 为止。</p>

<h2 id="代码">代码</h2>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt; 
using namespace std;

const int MAXN = 1e5 + 10;
const int INF = 1e9 + 7;

int kases, tmp;
int n, l;
int a[MAXN], b[MAXN], dp[MAXN], LIS[MAXN];

int main()
{
  scanf(&quot;%d&quot;, &amp;kases);
  
  while (kases--)
  {
    tmp++;
    scanf(&quot;%d%d&quot;, &amp;n, &amp;l);
    
    fill(dp, dp + MAXN, INF);
    
    for (int i = 0; i &lt; n; i++)
    {
      scanf(&quot;%d&quot;, &amp;a[i]);
      b[i] = -a[i];
    }
    
    // reverse LIS
    int pos = 0;
    fill(LIS, LIS + MAXN, INF);
    
    for (int i = l; i &gt;= l; i--)
    {
      pos = lower_bound(LIS, LIS + n, b[i]) - LIS;
      LIS[pos] = b[i];
      dp[i] = pos + 1;
    }
    
    int ans = 0, maxlen = 0;
    fill(LIS, LIS + MAXN, INF);
    for (int i = l; i &lt; n; i++)
    {
      pos = lower_bound(LIS, LIS + n, a[i]) - LIS;      // from left to right
      ans = max(ans, pos + 1 + dp[i] - 1);        // &gt;=

      pos = lower_bound(LIS, LIS + n, a[i - l]) - LIS;    // update left LIS
      LIS[pos] = a[i-l];
      maxlen = max(maxlen, pos + 1);
    }
    ans = max(ans, maxlen);
    printf(&quot;Case #%d: %d\n&quot;, tmp, ans);
  }
  
  return 0;
}
</code></pre>

<h1 id="9-200-hdu1074-doing-homework"><sup>9</sup>&frasl;<sub>200</sub>, HDU1074, Doing Homework</h1>

<h2 id="扯淡">扯淡</h2>

<p>DP，而且不是一般的 DP……是状压 DP 的说。这种 DP 也不是很好理解也很难想……主要还是要写题积累经验。算是我的第一道状压吧 QAQ，之前一直以为状压 DP 涉及各种二进制和位操作挺可怕的……看理论什么的也一直看不太懂。</p>

<h2 id="题解">题解</h2>

<p>嘛……这是我有生以来写过的第一道状态压缩 DP 的题……第一眼看到 N &lt;= 15 就有种不好的预感 2333……</p>

<p>状态压缩嘛，就是把 DP 中用到的状态用二进制来表示，然后就这道题目理解了一下状态压缩 DP 的基本的写法，下面是我稍微总结的一下状态压缩 DP 的框架：</p>

<pre><code>const MAXN = 最大的状态点数目
const MAXS = 1 &lt;&lt; MAXN			// 最多的状态数，表示 2^MAXN 个
var dp[MAXS]				// DP 数组

read n

for (i = 1...(1 &lt;&lt; n))			// 枚举每个用二进制表示的状态
    for (j = 0....n)			// 枚举每一个点
        var cur = 1 &lt;&lt; j		// 当前点用二进制表示后的整数
	if (i &amp; cur)			// 判断当前状态是否合法，即当前枚举的状态 (i) 必须包含当前枚举的点 (cur)
            var last = i - cur		// 这一步是可选的，如果你要获得当前状态的上一个状态
					// 那么可以用当前枚举的状态减去当前枚举的点的二进制状态

            dp equation			// 那么现在就可以开始你的 DP 方程了

print dp[(1 &lt;&lt; n) - 1]			// 最终答案就是 dp[(1 &lt;&lt; n) - 1] 了
</code></pre>

<p>然后说回到这一题上吧。题意就是某人要做好多的作业，每个作业有一个上交期限 deadline 和需要花费的时间 cost。如果每超过一天上交就扣一分，然后让你求出扣分最少的方案并输出字典序最小的方案。</p>

<p>由于最多只有 15 个状态点，那么用二进制表示这 15 个状态点的话，十进制的数不会超过 2^15 = 32768，所以我们想到用状压 DP 来解。那么，设整数 i 为用二进制表示了当前状态然后转换后的十进制数，然后我们就可以开一个数组 dp[1&hellip;MAXS] 来表示对于每个状态扣的分最少是多少，这里我们用二进制来表示状态，即用 0 来表示未完成这个作业，1 表示已完成这个作业。然后我们就可以从低位向高位填充来表示是否坐过这个作业了。</p>

<p>例如说有 5 门作业，你做了 第一门、第二门和第五门，那么用二进制表示就是 10011，然后转成十进制数就是 19.</p>

<p>我们用 i 枚举当前状态，然后再枚举一维 j 表示当前枚举的状态点（每一科的作业），当 i 状态包含了当前状态点的时候我们就可以根据我们的 DP 方程对 dp 数组进行更新。具体地，我们可以判断 i &amp; (1 &lt;&lt; j) 是否等于 1 的结果来看，如果等于 1 的话那么 i 状态就完成了第 j 门功课。</p>

<p>dp 方程如下（不要忘记转移的同时更新时间）：</p>

<pre><code>dp[i].score = dp[prev].score + max(dp[prev].time + lesson[j].cost - lesson[j].deadline, 0)
</code></pre>

<p>我们记 curscore = 在完成第 j 门作业前的上一个状态（可以用 i - (1 &lt;&lt; j) 来求得上一个状态）已经花费掉的时间 + 做当前作业需要花费的时间 - 当前作业的 deadline，那么 curscore 有两种情况：1. 当 curscore &gt; 0 的时候，就是当前决策会被扣掉的分数；2. 当 curscore &lt;= 0 的时候，表明当前决策还不会被扣分，但是提早上交作业也不会加分，所以我们要把它设为 0.</p>

<p>然后呢看题目要求除了输出最小代价之外还要输出方案，那么我们可以用一个结构体来表示当个状态，除了记录代价 score 和所用时间 times 外还需要记录上一个状态 prev 和当前的科目 subject. 利用最终答案是 dp[(1 &lt;&lt; n) - 1] 这个性质，我们就可以通过 prev 回溯回去输出方案了，具体的做法就是从最终状态往前搜寻，并把它们加入一个栈中。然后你知道怎么做了。</p>

<p>还有一个要注意的地方就是边界处理，不然会无限 WA。</p>

<h2 id="代码-1">代码</h2>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt; 

using namespace std;

const int MAXN = 15;
const int MAXS = 1 &lt;&lt; MAXN;
const int INF = 1e9 + 7;

struct Lesson {
  int deadline;
  int need;
  char name[105];
};

struct State {
  int day;
  int doing;
  int score;
  int previous;
};

Lesson les[MAXN];
State dp[MAXS];

int cases;
int n, l;

int main()
{
  scanf(&quot;%d&quot;, &amp;cases);
  while (cases--)
  {
    memset(dp, 0, sizeof(dp));
    
    scanf(&quot;%d&quot;, &amp;n);
    
    for (int i = 0; i &lt; n; i++)
    {
      cin &gt;&gt; les[i].name &gt;&gt; les[i].deadline &gt;&gt; les[i].need;
    }
    
    int terminal = 1 &lt;&lt; n;
    
    // state-compressing
    for (int i = 1; i &lt; terminal; i++)
    {
      dp[i].score = INF;
      for (int j = n - 1; j &gt;= 0; j--)
      {
        int current = 1 &lt;&lt; j;
        if (i &amp; current)
        {
          int prev = i - current;     // previous state
          int score = dp[prev].day + les[j].need - les[j].deadline;
          if (score &lt; 0)
            score = 0;
            
          int newState = score + dp[prev].score;
          if (newState &lt; dp[i].score)
          {
            dp[i].score = newState;
            dp[i].day = dp[prev].day + les[j].need;
            dp[i].previous = prev;
            dp[i].doing = j;
          }
        }
      } // for j = n-1 =&gt; 0
    } // for i = 1 =&gt; terminal
    
    printf(&quot;%d\n&quot;, dp[terminal - 1].score);
    
    // print solutions
    stack&lt;int&gt; solutions;
    int cur = terminal - 1;
    while (cur != 0)
    {
      solutions.push(dp[cur].doing);
      cur = dp[cur].previous;
    }
    
    while (!solutions.empty())
    {
      printf(&quot;%s\n&quot;, les[solutions.top()].name);
      solutions.pop();
    }
  }
  
  return 0;
}
</code></pre>

<h1 id="10-100-hdu3192-hamburger-magi"><sup>10</sup>&frasl;<sub>100</sub>, HDU3192, Hamburger Magi</h1>

<h2 id="题意-扯淡-1">题意 &amp; 扯淡</h2>

<p>第二道状压。具体的题意看题解吧，其实这些解题报告都是我把写完一题的时候 YY 出来的题解拼出来的，所以就不想浪费时间排版什么的了，看得懂找得到就行。</p>

<h2 id="题解-1">题解</h2>

<p>感觉状态压缩的题目写的还是不太多，然后就没有那种感觉……不过经过上一题之后看到这道题就有些靠谱的思路了，虽然因为掉进了上一题的思维定式里然后 WA 了好几回 QAQ……</p>

<p>这一题的话，题意大概就是要做汉堡包，然后每个汉堡包有自己的价值 v（下文用 val 表示） 和制作所需要的能量 e（用 cost 表示），总共可以消耗的能量为 E. 再然后就是有些种类的汉堡包可能有“依赖”，也即在做他们之前需要有些汉堡包已经做好了。每种汉堡包最多做一个，然后综合上述条件，求出满足题意的最大价值 maxVal. 1 &lt;= n &lt;= 15.</p>

<p>老规律，看到 n &lt;= 15 就想到状态压缩 DP。这道题和上一题有个比较不一样的地方在于，上一题是根据当前枚举到的状态作为已知，而当前状态的先前一个状态未知，所以是从后向前推的；这道题是把当前枚举到的状态作为已知，当前状态的下一个状态未知，然后要从前向后推。</p>

<p>我们记 i 为当前汉堡种类的状态，用 j 表示下一个状态相较当前状态多做的汉堡种类，在 DP 之前我们先要判断条件是否合适。由于这题当中有一个“依赖”的概念，又有一个能量的限定，所以我们在判断 DP 状态是否合法的时候要注意一下。由于前一个“依赖”的限定是硬性的，也就是这个限制只能在我们 DP 下一个状态之前先判断当前状态能否推出下一个状态；但是对于“能量”这个限定就显得比较宽松，我们既可以边 DP 边剪枝，把所需能量大于总能量的解答直接剪掉；也可以暂时不剪掉，但是记录它们的花费（尽管有时候该花费已经超过了总能量），然后在 DP 完成之后循环一遍 dp 数组，这个时候就可以很方便地根据 dp[i].cost 来判断状态是否合法了，因为这个值已经固定下来不会改变了，所以我们可以在状态合法的前提下更新答案。网上的题解大致也分这两种写法，我觉得后面一种比较好理解也好写，所以我们用第二种做法。</p>

<p>至于判断依赖是否满足的话，我们遍历 j 的每一个依赖 deps[j][x]，如果 (i &amp; (1 &lt;&lt; j 的每一个依赖))，说明当前状态合法，可以由当前状态推向下一个状态；反之则不能从当前状态通过做第 j 个汉堡包达到下一个状态。</p>

<p>DP 方程如下，设 items[j] 为第 j 种汉堡的信息，i 为在 n 个不同的状态点的二进制状态转换成的十进制数，那么：</p>

<pre><code>dp[i | (1 &lt;&lt; j)].val = dp[i].val + items[j].val, dp[i | (1 &lt;&lt; j)].cost = dp[i].cost + items[j].cost;
</code></pre>

<p>这里的 (1 &lt;&lt; j) 表示一个“只做当前枚举的第 j 个汉堡的二进制状态”，i 是当前状态，由于 (1 &lt;&lt; j) 二进制下只有第 j 位是 1 其他都是 0（注意这里 j 的下标是从 0 开始的），所以 i 与 1 &lt;&lt; j 按位或返回的结果就是下一个状态。</p>

<p>做完 DP 之后循环一遍 dp 数组更新 ans 就可以了： <code>ans = max(ans, dp[i].val), 其中 dp[i].cost &lt;= E.</code></p>

<h2 id="代码-2">代码</h2>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;
using namespace std;

const int MAXN = 15;
const int MAXS = 1 &lt;&lt; 15;
const int INF = 1e9 + 7;

struct Hamburger {
  int val;
  int cost;
  int dep;
  int deps[15];
};
Hamburger items[MAXN];

struct State {
  int val;
  int cost;
};
State dp[MAXS];

int cases;
int n, e;

int main()
{
  scanf(&quot;%d&quot;, &amp;cases);
  
  while (cases--)
  {
    memset(items, 0, sizeof(items));
    memset(dp, -1, sizeof(dp));
    
    scanf(&quot;%d%d&quot;, &amp;n, &amp;e);
    for (int i = 0; i &lt; n; i++)
    {
      scanf(&quot;%d&quot;, &amp;items[i].val);
    }
    for (int i = 0; i &lt; n; i++)
    {
      scanf(&quot;%d&quot;, &amp;items[i].cost);
    }
    for (int i = 0; i &lt; n; i++)
    {
      scanf(&quot;%d&quot;, &amp;items[i].dep);
      if (items[i].dep &gt; 0)
      {
        for (int j = 0; j &lt; items[i].dep; j++)
        {
          scanf(&quot;%d&quot;, &amp;items[i].deps[j]);
          items[i].deps[j]--;
        }
      }
    } // end read
    
    int end = 1 &lt;&lt; n;
    int ans = 0;

    dp[0].cost = 0, dp[0].val = 0;

    for (int i = 0; i &lt; end; i++)
    {
      if (dp[i].cost == -1)
        continue;
        
      for (int j = 0; j &lt; n; j++)
      {
        int cur = 1 &lt;&lt; j;
        if (!(i &amp; cur))
        {
          int next = i | cur;
          
          bool flag = true;
          if (items[j].dep &gt; 0)
          {
            for (int x = 0; x &lt; items[j].dep; x++)
            {
              int depState = 1 &lt;&lt; items[j].deps[x];
              if (!(i &amp; depState)) {
                flag = false;
                break;
              }
            } // for x = 0 -&gt; items[j].dep
          } // if items[j].dep &gt; 0
          
          if (flag)
          {
            dp[next].val = dp[i].val + items[j].val;
            dp[next].cost = dp[i].cost + items[j].cost;
          }
          
        } // if i &amp; cur
      } // for j = 0 -&gt; n
    } // for i = 1 -&gt; end

    for (int i = 0; i &lt; end; i++)
    {
      if (dp[i].cost &lt;= e)
        ans = max(ans, dp[i].val);
    }
  
    printf(&quot;%d\n&quot;, ans);

  }
  
  return 0;
}

</code></pre>

<h1 id="11-200-hdu1520-anniversary-party"><sup>11</sup>&frasl;<sub>200</sub>, HDU1520, Anniversary Party</h1>

<h2 id="题意-扯淡-2">题意 &amp; 扯淡</h2>

<p>树形 DP 入门题，是之前突然想学学树形 DP 的时候找到的。题意大概就是一个宴会上要邀请员工，每个员工都有一个开心指数，只有在宴会上见不到自己的直属上司的时候才会开心，然后要求出开心指数的最大值。</p>

<h2 id="题解-2">题解</h2>

<p>这道题有个很坑的地方就是它一个样例有好多个子任务，但是它什！么！都！没！说！
* 然后我交了 7 遍还是不知道为什么 WA 的……找了个 std 一看，卧槽要处理多组数据……</p>

<p>设 dp[i][0] 为不邀请第 i 个人的最大值， dp[i][1] 为邀请第 i 个人的最大值。如果我们邀请了第 i 个人，那么我们就不能邀请第 i 个人的直接下属，但是他的直接下属的下属是可以邀请的……然后按照这个思路转移方程就出来了。</p>

<p>首先要建树，然后这里我采用的是用图的保存方法，直接用了 vector<int>[MAXN] 数组来存第 i 个人的直接下属。首先找到树根，也就是入度为 0 的（没有父亲或者说父亲是本身的）那个节点 Q，然后以此节点为起点做一遍 DFS，边 DFS 边状态转移，之后输出答案就好了。</p>

<p>状态转移方程如下：</p>

<pre><code>dp[i][0] = max(dp[k1][0], dp[k1][1]) + ... + max(dp[kx][0], dp[kx][1])
// 其中 k1 ... kx 是第 i 个员工的所有直属下属的下标

dp[i][1] = dp[k1][0] + dp[k2][0] + ... + dp[kx][0]
// 假如第 i 个员工要出席宴会，这种情况下他的直接下属都不能参加
</code></pre>

<p>然后答案就是 <code>ans = max(dp[Q][0], dp[Q][1]);</code>.</p>

<h2 id="代码-3">代码</h2>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt; 
using namespace std;

const int MAXN = 6010;
int n;
int rate[MAXN], p[MAXN];
int dp[MAXN][2];
vector&lt;int&gt; T[MAXN];

void dfs(int s)
{
  if (T[s].size() == 0)
  {
    dp[s][1] = rate[s];
    dp[s][0] = 0;
    return;
  }
  
  for (int i = 0; i &lt; T[s].size(); i++)
  {
    int cur = T[s][i];
    dfs(cur);
    dp[s][0] += max(dp[cur][1], dp[cur][0]);
    dp[s][1] += dp[cur][0];
  }
  dp[s][1] += rate[s];
  return;
}

int main()
{
  while (scanf(&quot;%d&quot;, &amp;n) != EOF)
  {
    memset(rate, 0, sizeof(rate));
    memset(p, 0, sizeof(p));
    memset(dp, 0, sizeof(dp));
    
    for (int i = 0; i &lt;= MAXN; i++)
    {
      T[i].clear();
    }
    
    for (int i = 1; i &lt;= n; i++)
    {
      scanf(&quot;%d&quot;, &amp;rate[i]);
    }
    
    int x, y;
    while (scanf(&quot;%d%d&quot;, &amp;x, &amp;y) != EOF &amp;&amp; x != 0 &amp;&amp; y != 0)
    {
      T[y].push_back(x);
      p[x] = y;
    }
    
    int s;
    for (int i = 1; i &lt;= n; i++)
    {
      if (p[i] == 0)
      {
        s = i;
        break;
      }
    }
    
    dfs(s);
    int ans = max(dp[s][0], dp[s][1]);
    printf(&quot;%d\n&quot;, ans);    
  }
  return 0;
}

</code></pre>

<h1 id="12-200-hdu1166-敌兵布阵"><sup>12</sup>&frasl;<sub>200</sub>, HDU1166, 敌兵布阵</h1>

<p>题意自己看原题吧 Orz 反正是中文的，这题用 BIT 和单点修改的线段树都可以做，是个裸的板子题。记一下这道题的板子代码以防将来需要。</p>

<h2 id="bit-version">BIT version</h2>

<p>因为只有单点修改，所以用树状数组完全可以胜任。</p>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt;

const int MAXN = 50005;
int n;
int c[MAXN];

int lowbit(int x)
{
  return x &amp; (-x);
}

void add(int i, int value)
{
  while (i &lt;= n)
  {
    c[i] += value;
    i += lowbit(i);
  }
}

int sum(int x)
{
  int res = 0;
  while (x &gt; 0)
  {
    res += c[x];
    x -= lowbit(x);
  }
  return res;
}

int main()
{
  int t;
  scanf(&quot;%d&quot;, &amp;t);
  
  for (int i = t; i &gt; 0; i--)
  {
    printf(&quot;Case %d:\n&quot;, t - i + 1);
    scanf(&quot;%d&quot;, &amp;n);
    memset(c, 0, sizeof(c));
    
    for (int j = 1; j &lt;= n; j++)
    {
      int x;
      scanf(&quot;%d&quot;, &amp;x);
      add(j, x);
    }
    
    char str[10];
    int x, y;
    while (scanf(&quot;%s&quot;, str) != EOF &amp;&amp; str[0] != 'E')
    {
      scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
      
      if (str[0] == 'Q') {
        int res = sum(y) - sum(x-1);
        printf(&quot;%d\n&quot;, res);
      }
      
      if (str[0] == 'A') {
        add(x, y);
      }
      
      if (str[0] == 'S') {
        add(x, -y);
      }
    }
    
  }
  
  return 0;
}

</code></pre>

<h2 id="segment-tree-version">Segment Tree version</h2>

<p>线段树的单点修改区间查询版也可以做这题，如下。写起来会比树状数组的版本麻烦一些。记得一个很重要的地方就是线段树的数组要开到 MAXN 的 4 倍。</p>

<pre><code class="language-cpp">#include &lt;bits/stdc++.h&gt; 
const int MAXN = 50010;

int n;
int kases, tmp;

struct SegTree
{
  int sum[MAXN &lt;&lt; 2];
  
  void pushUp(int root) 
  {
    sum[root] = sum[root * 2] + sum[root * 2 + 1];
  }
  
  void build(int left, int right, int root)
  {
    if (left == right)
    {
      scanf(&quot;%d&quot;, &amp;sum[root]);
      return;
    }
    int middle = (left + right) / 2;
    build(left, middle, root * 2);
    build(middle + 1, right, root * 2 + 1); 
    
    pushUp(root);
  }
  
  void update(int left, int right, int root, int pos, int addVal)
  {
    if (left == right)
    {
      sum[root] += addVal;
      return;
    }
    int middle = (left + right) / 2;
    
    if (pos &lt;= middle)
    {
      update(left, middle, root * 2, pos, addVal);
    }
    else
    {
      update(middle + 1, right, root * 2 + 1, pos, addVal);
    }
    
    pushUp(root);
  }
  
  int query(int from, int to, int left, int right, int root)
  {
    if (from &lt;= left &amp;&amp; right &lt;= to)
    {
      return sum[root];
    }
    
    int middle = (left + right) / 2;
    
    int res = 0;
    if (to &lt;= middle)
    {
      res += query(from, to, left, middle, root * 2);
    }
    else if (from &gt; middle)
    {
      res += query(from, to, middle + 1, right, root * 2 + 1);
    }
    else
    {
      res += query(from, to, left, middle, root * 2) + query(from, to, middle + 1, right, root * 2 + 1);
    }
    
    return res;
  }
  
  void init()
  {
    for (int i = 0; i &lt; MAXN; i++)
    {
      sum[i] = 0;
    }
  }
};

SegTree tree;

int main()
{
  scanf(&quot;%d&quot;, &amp;kases);
  
  while (kases--) 
  {
    tmp++;
    printf(&quot;Case %d:\n&quot;, tmp);
    
    scanf(&quot;%d&quot;, &amp;n);
    
    tree.init();
    tree.build(1, n, 1);
    
    char commands[20];
    while (scanf(&quot;%s&quot;, commands) != EOF &amp;&amp; commands[0] != 'E')
    {
      if (commands[0] == 'Q')
      {
        int x, y;
        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
        
        int res = tree.query(x, y, 1, n, 1);
        printf(&quot;%d\n&quot;, res);
      }
      
      if (commands[0] == 'A')
      {
        int x, y;
        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
        tree.update(1, n, 1, x, y);
      }
      
      if (commands[0] == 'S')
      {
        int x, y;
        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
        tree.update(1, n, 1, x, -y);
      }
    }
  }
  
  return 0;
}

</code></pre>
      </div>
    </div>
  
<section class="section">
  <div class="container">
    <aside><div id="disqus_thread"></div></aside>
    <script type="text/javascript">
      var disqus_shortname = 'yume-diary';
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
  </div>
</section>


  </section>
  <section class="section footblock">
  <img src="https://secure.gravatar.com/avatar/c47187d311099868de825697fa419654?s=200&r=G" width="70px" height="70px" class="avatar">
  <div class="container has-text-centered">
    <p>&copy;2016-2019&nbsp;&nbsp;<a href='https://kirainmoe.com'>宇宙よりも遠い場所</a>  / Published with <a href="https://gohugo.io">Hugo</a> / <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC-BY-SA 4.0</a> Licensed</p>
  </div>
</section>

<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/prism.min.js" integrity="sha256-HWJnMZHGx7U1jmNfxe4yaQedmpo/mtxWSIXvcJkLIf4=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/plugins/autoloader/prism-autoloader.min.js" integrity="sha256-ht8ay6ZTPZfuixYB99I5oRpCLsCq7Do2LjEYLwbe+X8=" crossorigin="anonymous"></script>


<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-go.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-javascript.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-matlab.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-c.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/components/prism-cpp.min.js"></script>


<canvas id="live2d" width="300" height="300"></canvas>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.17.1/plugins/line-numbers/prism-line-numbers.min.js"></script>


<script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script>
<script src="https://kirainmoe.com//index.js"></script>
<script type="text/javascript" src="https://kirainmoe.com//js/live2d.js"></script>
<script type="text/javascript">
  if (!window.mobilecheck())
  loadlive2d("live2d", "https:\/\/kirainmoe.com\//model/aya/model.json");
</script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-111347233-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



</body>
