<!-- Himawari no Yakusoku -->

<!DOCTYPE html>
<html lang="Zh-cn">
<head>
  <meta charset="UTF-8">
  <meta name="theme-color" content="#FF98A8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>每周解题报告 (3rd, 8/14~8/20) [ YumeのDiary ]</title>
  <meta name="description" content="6 年間、共に歩んでくれたあなたへ。">
  <link rel="manifest" href="/manifest.json">
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    
      <link rel="stylesheet" href="/himawari.css">
    
  
</head>
<body>
  
  <!-- infos -->
  <script type="text/json" id="himawari-json">{
  "title": "YumeのDiary",
  "siteTitle": "YumeのDiary",
  "description": "6 年間、共に歩んでくれたあなたへ。",
  "author": "Yume Kankawa",
  "route": "post",
  "format": "blog/:layout/:title/",
  "posts": {
    "title": "每周解题报告 (3rd, 8/14~8/20)",
    "date": "2017-08-20T06:43:46.000Z",
    "modified": "2018-01-07T05:18:35.157Z",
    "content": "<p>这周主要是尝试了一些新的东西（ 做了一些之前一直想看但是一直没看懂和没做的题目。依旧是做 HDU 的题。虽然写得不是很熟练，不过慢慢来应该也是可以的。<br>另外下周由于要阶段考试这样子，可能就没有时间做题目了。<\\/p>\n<a id=\"more\"><\\/a>\n<div class=\"muse-app\"><\\/div>\n\n<script type=\"text\\/javascript\">\nvar playList = [{\n    title: 'やくそく',\n    artist: '三森すずこ \\/ 花澤香菜',\n    src: 'https:\\/\\/api.kotori.love\\/netease\\/mp3?id=488256626',\n    cover: 'http:\\/\\/p1.music.126.net\\/9uq04GzHBnhhJCgQTccq_Q==\\/19012755067719433.jpg',\n    lyric: '[by:lyricshare]\\n[00:25.93]さよならじゃない今未来が始まるんだ\\n[00:37.23]淡い蕾は花開いて祝福を歌う\\n[00:48.93]秘密の場所に埋めたのは\\n[00:54.65]密かな夢と宝の地図\\n[01:00.94]時間巡りを閉じ込めた\\n[01:06.41]小さなガラスの欠片だった\\n[01:11.87]あの時 君は君は勇気を得た\\n[01:17.79]友を信じ抜く勇気を得た\\n[01:23.80]永遠に消えない誇りになるだろう\\n[01:29.83]最後の鐘が響き出す\\n[01:35.33]たとえ涙が落ちてしまうとしても\\n[01:41.03]下を向いたりしないと誓おう\\n[01:47.39]そっと重ねた思い出の数だけ\\n[01:53.20]光ゆらめいて背中を押した\\n[02:05.22]流れ続ける砂時計のような時よ\\n[02:16.67]翼広げてさあ飛び立とう地平線の果て\\n[02:28.44]あどけなかった横顔が\\n[02:34.10]凛々しくなったはいつの日か\\n[02:40.03]速まる日々に負けぬよう\\n[02:45.85]毎日夢中で追いかけてた\\n[02:51.57]あの時君は君は希望を見た\\n[02:57.28]暗闇に浮かぶ 希望を見た\\n[03:03.14]行き先照らす明かりになるだろう\\n[03:09.24]もう迷うことはないんだ\\n[03:14.94]いつか傷つくことがあるとしても\\n[03:20.64]友がくれた言葉を胸に\\n[03:27.03]傷を癒して進み続けるよ\\n[03:32.70]きっとその先でまた会えるから\\n[04:01.90]あの時君は君は勇気を得た\\n[04:07.50]友を信じ抜く勇気を得た\\n[04:13.36]永遠に消えない誇りになるだろう\\n[04:19.78]最後の鐘が響き出す\\n[04:24.82]たとえ 涙が落ちてしまうとしても\\n[04:30.82]下を向いたりしないと誓おう\\n[04:37.28]そっと重ねた思い出の数だけ\\n[04:42.95]光ゆらめいて背中を押した\\n[04:54.83]あのね ありがとう またあの場所で',\n    translation: '这并不是永别 未来从现在才开始\\n含苞待放的花蕾盛开 颂唱祝福之歌\\n在秘密场所里埋藏的是\\n潜藏于心的梦想与藏宝图\\n将反复的时间紧闭门中\\n化成了小小的玻璃碎片\\n那时候 是你让我获得了勇气\\n让我获得了坚信朋友的勇气\\n它会成为我永不消逝的骄傲吧\\n终结的钟声响起\\n让我们发誓 即便再流下眼泪\\n也不再低下头\\n只有那默默积累下的记忆\\n在虚渺的光芒中一直支持着我\\n时间仿佛不断流逝的沙漏\\n张开双翼 向着地平线的尽头翱翔吧\\n你那天真烂漫的侧脸\\n不知在何时已变得如此冷酷严峻\\n为了不输给忙碌的生活\\n每日都不顾一切地追赶\\n在那时 是你让我看见了希望\\n让我看见了在黑暗中浮现的希望\\n它会成为我通向终点的照明灯吧\\n我已经不会再次迷失自我了\\n即便在未来某刻会受伤\\n朋友托付于我的咒语 也会在我心中\\n治愈着我的伤痕 让我向前迈进\\n一定会在前方再次相遇吧\\n那时候 是你让我获得了勇气\\n让我获得了坚信朋友的勇气\\n它会成为我永不消逝的骄傲吧\\n终结的钟声响起\\n让我们发誓 即便再流下眼泪\\n也不再低下头\\n只有那默默积累下的记忆\\n在虚渺的光芒中一直支持着我\\n我想对你说 谢谢你 让我们再次在那个地方相遇吧'\n}];\n\nMUSE.render(playList, document.querySelector('.muse-app'));\n<\\/script>\n\n<h1 id=\"8-200-HDU5489-Removed-Interval\"><a href=\"#8-200-HDU5489-Removed-Interval\" class=\"headerlink\" title=\"8\\/200, HDU5489, Removed Interval\"><\\/a>8\\/200, HDU5489, Removed Interval<\\/h1><h2 id=\"题意-amp-扯淡\"><a href=\"#题意-amp-扯淡\" class=\"headerlink\" title=\"题意 &amp; 扯淡\"><\\/a>题意 &amp; 扯淡<\\/h2><p>题意就是已知一个数列，从中删除连续的 n 个数，然后要使得删除完之后它的最长上升子序列最大。n &lt;= 1e5.<\\/p>\n<p>这题好像有很多的解法，有用传统 LIS 做的，还有用 LIS + BIT 或者 LIS + Segment Tree 做的……后面两种做法没能理解（说实话，第一种做法也没怎么能理解），所以我还是硬着头皮看了一下直接做的。<\\/p>\n<h2 id=\"所谓题解\"><a href=\"#所谓题解\" class=\"headerlink\" title=\"所谓题解\"><\\/a>所谓题解<\\/h2><p>因为要从数列中删除一些数之后求 LIS，然后就是我们枚举删除的数的终点，然后对终点右边的第一个数为起点求一次 LIS<br>然后再从最左边到删除的起点求一次 <strong>最大的数不超过终点右边第一个数<\\/strong> 的 LIS<br>从右往左的这个 LIS 必须在枚举起点之前预处理求出，所以：<br>从右往左求 LIS 可以用负数的方法来做，然后倒着求回来，一直从 n 求到 l 为止。<\\/p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"><\\/a>代码<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nusing namespace std;\n\nconst int MAXN = 1e5 + 10;\nconst int INF = 1e9 + 7;\n\nint kases, tmp;\nint n, l;\nint a[MAXN], b[MAXN], dp[MAXN], LIS[MAXN];\n\nint main()\n{\n  scanf(&quot;%d&quot;, &amp;kases);\n\n  while (kases--)\n  {\n    tmp++;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;l);\n\n    fill(dp, dp + MAXN, INF);\n\n    for (int i = 0; i &lt; n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;a[i]);\n      b[i] = -a[i];\n    }\n\n    \\/\\/ reverse LIS\n    int pos = 0;\n    fill(LIS, LIS + MAXN, INF);\n\n    for (int i = l; i &gt;= l; i--)\n    {\n      pos = lower_bound(LIS, LIS + n, b[i]) - LIS;\n      LIS[pos] = b[i];\n      dp[i] = pos + 1;\n    }\n\n    int ans = 0, maxlen = 0;\n    fill(LIS, LIS + MAXN, INF);\n    for (int i = l; i &lt; n; i++)\n    {\n      pos = lower_bound(LIS, LIS + n, a[i]) - LIS;      \\/\\/ from left to right\n      ans = max(ans, pos + 1 + dp[i] - 1);        \\/\\/ &gt;=\n\n      pos = lower_bound(LIS, LIS + n, a[i - l]) - LIS;    \\/\\/ update left LIS\n      LIS[pos] = a[i-l];\n      maxlen = max(maxlen, pos + 1);\n    }\n    ans = max(ans, maxlen);\n    printf(&quot;Case #%d: %d\\n&quot;, tmp, ans);\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"9-200-HDU1074-Doing-Homework\"><a href=\"#9-200-HDU1074-Doing-Homework\" class=\"headerlink\" title=\"9\\/200, HDU1074, Doing Homework\"><\\/a>9\\/200, HDU1074, Doing Homework<\\/h1><h2 id=\"扯淡\"><a href=\"#扯淡\" class=\"headerlink\" title=\"扯淡\"><\\/a>扯淡<\\/h2><p>DP，而且不是一般的 DP……是状压 DP 的说。这种 DP 也不是很好理解也很难想……主要还是要写题积累经验。算是我的第一道状压吧 QAQ，之前一直以为状压 DP 涉及各种二进制和位操作挺可怕的……看理论什么的也一直看不太懂。<\\/p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"><\\/a>题解<\\/h2><p>嘛……这是我有生以来写过的第一道状态压缩 DP 的题……第一眼看到 N &lt;= 15 就有种不好的预感 2333……<\\/p>\n<p>状态压缩嘛，就是把 DP 中用到的状态用二进制来表示，然后就这道题目理解了一下状态压缩 DP 的基本的写法，下面是我稍微总结的一下状态压缩 DP 的框架：<\\/p>\n<pre><code>const MAXN = 最大的状态点数目\nconst MAXS = 1 &lt;&lt; MAXN            \\/\\/ 最多的状态数，表示 2^MAXN 个\nvar dp[MAXS]                \\/\\/ DP 数组\n\nread n\n\nfor (i = 1...(1 &lt;&lt; n))            \\/\\/ 枚举每个用二进制表示的状态\n    for (j = 0....n)            \\/\\/ 枚举每一个点\n        var cur = 1 &lt;&lt; j        \\/\\/ 当前点用二进制表示后的整数\n    if (i &amp; cur)            \\/\\/ 判断当前状态是否合法，即当前枚举的状态 (i) 必须包含当前枚举的点 (cur)\n            var last = i - cur        \\/\\/ 这一步是可选的，如果你要获得当前状态的上一个状态\n                    \\/\\/ 那么可以用当前枚举的状态减去当前枚举的点的二进制状态\n\n            dp equation            \\/\\/ 那么现在就可以开始你的 DP 方程了\n\nprint dp[(1 &lt;&lt; n) - 1]            \\/\\/ 最终答案就是 dp[(1 &lt;&lt; n) - 1] 了\n<\\/code><\\/pre><p>然后说回到这一题上吧。题意就是某人要做好多的作业，每个作业有一个上交期限 deadline 和需要花费的时间 cost。如果每超过一天上交就扣一分，然后让你求出扣分最少的方案并输出字典序最小的方案。<\\/p>\n<p>由于最多只有 15 个状态点，那么用二进制表示这 15 个状态点的话，十进制的数不会超过 2^15 = 32768，所以我们想到用状压 DP 来解。那么，设整数 i 为用二进制表示了当前状态然后转换后的十进制数，然后我们就可以开一个数组 dp[1…MAXS] 来表示对于每个状态扣的分最少是多少，这里我们用二进制来表示状态，即用 0 来表示未完成这个作业，1 表示已完成这个作业。然后我们就可以从低位向高位填充来表示是否坐过这个作业了。<\\/p>\n<p>例如说有 5 门作业，你做了 第一门、第二门和第五门，那么用二进制表示就是 10011，然后转成十进制数就是 19.<\\/p>\n<p>我们用 i 枚举当前状态，然后再枚举一维 j 表示当前枚举的状态点（每一科的作业），当 i 状态包含了当前状态点的时候我们就可以根据我们的 DP 方程对 dp 数组进行更新。具体地，我们可以判断 i &amp; (1 &lt;&lt; j) 是否等于 1 的结果来看，如果等于 1 的话那么 i 状态就完成了第 j 门功课。<\\/p>\n<p>dp 方程如下（不要忘记转移的同时更新时间）：<\\/p>\n<pre><code>dp[i].score = dp[prev].score + max(dp[prev].time + lesson[j].cost - lesson[j].deadline, 0)\n<\\/code><\\/pre><p>我们记 curscore = 在完成第 j 门作业前的上一个状态（可以用 i - (1 &lt;&lt; j) 来求得上一个状态）已经花费掉的时间 + 做当前作业需要花费的时间 - 当前作业的 deadline，那么 curscore 有两种情况：1. 当 curscore &gt; 0 的时候，就是当前决策会被扣掉的分数；2. 当 curscore &lt;= 0 的时候，表明当前决策还不会被扣分，但是提早上交作业也不会加分，所以我们要把它设为 0.<\\/p>\n<p>然后呢看题目要求除了输出最小代价之外还要输出方案，那么我们可以用一个结构体来表示当个状态，除了记录代价 score 和所用时间 times 外还需要记录上一个状态 prev 和当前的科目 subject. 利用最终答案是 dp[(1 &lt;&lt; n) - 1] 这个性质，我们就可以通过 prev 回溯回去输出方案了，具体的做法就是从最终状态往前搜寻，并把它们加入一个栈中。然后你知道怎么做了。<\\/p>\n<p>还有一个要注意的地方就是边界处理，不然会无限 WA。<\\/p>\n<h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"><\\/a>代码<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \n\nusing namespace std;\n\nconst int MAXN = 15;\nconst int MAXS = 1 &lt;&lt; MAXN;\nconst int INF = 1e9 + 7;\n\nstruct Lesson {\n  int deadline;\n  int need;\n  char name[105];\n};\n\nstruct State {\n  int day;\n  int doing;\n  int score;\n  int previous;\n};\n\nLesson les[MAXN];\nState dp[MAXS];\n\nint cases;\nint n, l;\n\nint main()\n{\n  scanf(&quot;%d&quot;, &amp;cases);\n  while (cases--)\n  {\n    memset(dp, 0, sizeof(dp));\n\n    scanf(&quot;%d&quot;, &amp;n);\n\n    for (int i = 0; i &lt; n; i++)\n    {\n      cin &gt;&gt; les[i].name &gt;&gt; les[i].deadline &gt;&gt; les[i].need;\n    }\n\n    int terminal = 1 &lt;&lt; n;\n\n    \\/\\/ state-compressing\n    for (int i = 1; i &lt; terminal; i++)\n    {\n      dp[i].score = INF;\n      for (int j = n - 1; j &gt;= 0; j--)\n      {\n        int current = 1 &lt;&lt; j;\n        if (i &amp; current)\n        {\n          int prev = i - current;     \\/\\/ previous state\n          int score = dp[prev].day + les[j].need - les[j].deadline;\n          if (score &lt; 0)\n            score = 0;\n\n          int newState = score + dp[prev].score;\n          if (newState &lt; dp[i].score)\n          {\n            dp[i].score = newState;\n            dp[i].day = dp[prev].day + les[j].need;\n            dp[i].previous = prev;\n            dp[i].doing = j;\n          }\n        }\n      } \\/\\/ for j = n-1 =&gt; 0\n    } \\/\\/ for i = 1 =&gt; terminal\n\n    printf(&quot;%d\\n&quot;, dp[terminal - 1].score);\n\n    \\/\\/ print solutions\n    stack&lt;int&gt; solutions;\n    int cur = terminal - 1;\n    while (cur != 0)\n    {\n      solutions.push(dp[cur].doing);\n      cur = dp[cur].previous;\n    }\n\n    while (!solutions.empty())\n    {\n      printf(&quot;%s\\n&quot;, les[solutions.top()].name);\n      solutions.pop();\n    }\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"10-100-HDU3192-Hamburger-Magi\"><a href=\"#10-100-HDU3192-Hamburger-Magi\" class=\"headerlink\" title=\"10\\/100, HDU3192, Hamburger Magi\"><\\/a>10\\/100, HDU3192, Hamburger Magi<\\/h1><h2 id=\"题意-amp-扯淡-1\"><a href=\"#题意-amp-扯淡-1\" class=\"headerlink\" title=\"题意 &amp; 扯淡\"><\\/a>题意 &amp; 扯淡<\\/h2><p>第二道状压。具体的题意看题解吧，其实这些解题报告都是我把写完一题的时候 YY 出来的题解拼出来的，所以就不想浪费时间排版什么的了，看得懂找得到就行。<\\/p>\n<h2 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"><\\/a>题解<\\/h2><p>感觉状态压缩的题目写的还是不太多，然后就没有那种感觉……不过经过上一题之后看到这道题就有些靠谱的思路了，虽然因为掉进了上一题的思维定式里然后 WA 了好几回 QAQ……<\\/p>\n<p>这一题的话，题意大概就是要做汉堡包，然后每个汉堡包有自己的价值 v（下文用 val 表示） 和制作所需要的能量 e（用 cost 表示），总共可以消耗的能量为 E. 再然后就是有些种类的汉堡包可能有“依赖”，也即在做他们之前需要有些汉堡包已经做好了。每种汉堡包最多做一个，然后综合上述条件，求出满足题意的最大价值 maxVal. 1 &lt;= n &lt;= 15.<\\/p>\n<p>老规律，看到 n &lt;= 15 就想到状态压缩 DP。这道题和上一题有个比较不一样的地方在于，上一题是根据当前枚举到的状态作为已知，而当前状态的先前一个状态未知，所以是从后向前推的；这道题是把当前枚举到的状态作为已知，当前状态的下一个状态未知，然后要从前向后推。<\\/p>\n<p>我们记 i 为当前汉堡种类的状态，用 j 表示下一个状态相较当前状态多做的汉堡种类，在 DP 之前我们先要判断条件是否合适。由于这题当中有一个“依赖”的概念，又有一个能量的限定，所以我们在判断 DP 状态是否合法的时候要注意一下。由于前一个“依赖”的限定是硬性的，也就是这个限制只能在我们 DP 下一个状态之前先判断当前状态能否推出下一个状态；但是对于“能量”这个限定就显得比较宽松，我们既可以边 DP 边剪枝，把所需能量大于总能量的解答直接剪掉；也可以暂时不剪掉，但是记录它们的花费（尽管有时候该花费已经超过了总能量），然后在 DP 完成之后循环一遍 dp 数组，这个时候就可以很方便地根据 dp[i].cost 来判断状态是否合法了，因为这个值已经固定下来不会改变了，所以我们可以在状态合法的前提下更新答案。网上的题解大致也分这两种写法，我觉得后面一种比较好理解也好写，所以我们用第二种做法。<\\/p>\n<p>至于判断依赖是否满足的话，我们遍历 j 的每一个依赖 deps[j][x]，如果 (i &amp; (1 &lt;&lt; j 的每一个依赖))，说明当前状态合法，可以由当前状态推向下一个状态；反之则不能从当前状态通过做第 j 个汉堡包达到下一个状态。<\\/p>\n<p>DP 方程如下，设 items[j] 为第 j 种汉堡的信息，i 为在 n 个不同的状态点的二进制状态转换成的十进制数，那么：<\\/p>\n<pre><code>dp[i | (1 &lt;&lt; j)].val = dp[i].val + items[j].val, dp[i | (1 &lt;&lt; j)].cost = dp[i].cost + items[j].cost;\n<\\/code><\\/pre><p>这里的 (1 &lt;&lt; j) 表示一个“只做当前枚举的第 j 个汉堡的二进制状态”，i 是当前状态，由于 (1 &lt;&lt; j) 二进制下只有第 j 位是 1 其他都是 0（注意这里 j 的下标是从 0 开始的），所以 i 与 1 &lt;&lt; j 按位或返回的结果就是下一个状态。<\\/p>\n<p>做完 DP 之后循环一遍 dp 数组更新 ans 就可以了： <code>ans = max(ans, dp[i].val), 其中 dp[i].cost &lt;= E.<\\/code><\\/p>\n<h2 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"><\\/a>代码<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt;\nusing namespace std;\n\nconst int MAXN = 15;\nconst int MAXS = 1 &lt;&lt; 15;\nconst int INF = 1e9 + 7;\n\nstruct Hamburger {\n  int val;\n  int cost;\n  int dep;\n  int deps[15];\n};\nHamburger items[MAXN];\n\nstruct State {\n  int val;\n  int cost;\n};\nState dp[MAXS];\n\nint cases;\nint n, e;\n\nint main()\n{\n  scanf(&quot;%d&quot;, &amp;cases);\n\n  while (cases--)\n  {\n    memset(items, 0, sizeof(items));\n    memset(dp, -1, sizeof(dp));\n\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;e);\n    for (int i = 0; i &lt; n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;items[i].val);\n    }\n    for (int i = 0; i &lt; n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;items[i].cost);\n    }\n    for (int i = 0; i &lt; n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;items[i].dep);\n      if (items[i].dep &gt; 0)\n      {\n        for (int j = 0; j &lt; items[i].dep; j++)\n        {\n          scanf(&quot;%d&quot;, &amp;items[i].deps[j]);\n          items[i].deps[j]--;\n        }\n      }\n    } \\/\\/ end read\n\n    int end = 1 &lt;&lt; n;\n    int ans = 0;\n\n    dp[0].cost = 0, dp[0].val = 0;\n\n    for (int i = 0; i &lt; end; i++)\n    {\n      if (dp[i].cost == -1)\n        continue;\n\n      for (int j = 0; j &lt; n; j++)\n      {\n        int cur = 1 &lt;&lt; j;\n        if (!(i &amp; cur))\n        {\n          int next = i | cur;\n\n          bool flag = true;\n          if (items[j].dep &gt; 0)\n          {\n            for (int x = 0; x &lt; items[j].dep; x++)\n            {\n              int depState = 1 &lt;&lt; items[j].deps[x];\n              if (!(i &amp; depState)) {\n                flag = false;\n                break;\n              }\n            } \\/\\/ for x = 0 -&gt; items[j].dep\n          } \\/\\/ if items[j].dep &gt; 0\n\n          if (flag)\n          {\n            dp[next].val = dp[i].val + items[j].val;\n            dp[next].cost = dp[i].cost + items[j].cost;\n          }\n\n        } \\/\\/ if i &amp; cur\n      } \\/\\/ for j = 0 -&gt; n\n    } \\/\\/ for i = 1 -&gt; end\n\n    for (int i = 0; i &lt; end; i++)\n    {\n      if (dp[i].cost &lt;= e)\n        ans = max(ans, dp[i].val);\n    }\n\n    printf(&quot;%d\\n&quot;, ans);\n\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"11-200-HDU1520-Anniversary-Party\"><a href=\"#11-200-HDU1520-Anniversary-Party\" class=\"headerlink\" title=\"11\\/200, HDU1520, Anniversary Party\"><\\/a>11\\/200, HDU1520, Anniversary Party<\\/h1><h2 id=\"题意-amp-扯淡-2\"><a href=\"#题意-amp-扯淡-2\" class=\"headerlink\" title=\"题意 &amp; 扯淡\"><\\/a>题意 &amp; 扯淡<\\/h2><p>树形 DP 入门题，是之前突然想学学树形 DP 的时候找到的。题意大概就是一个宴会上要邀请员工，每个员工都有一个开心指数，只有在宴会上见不到自己的直属上司的时候才会开心，然后要求出开心指数的最大值。<\\/p>\n<h2 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"><\\/a>题解<\\/h2><p>这道题有个很坑的地方就是它一个样例有好多个子任务，但是它什！么！都！没！说！ <\\/p>\n<ul>\n<li>然后我交了 7 遍还是不知道为什么 WA 的……找了个 std 一看，卧槽要处理多组数据……<\\/li>\n<\\/ul>\n<p>设 dp[i][0] 为不邀请第 i 个人的最大值， dp[i][1] 为邀请第 i 个人的最大值。如果我们邀请了第 i 个人，那么我们就不能邀请第 i 个人的直接下属，但是他的直接下属的下属是可以邀请的……然后按照这个思路转移方程就出来了。<\\/p>\n<p>首先要建树，然后这里我采用的是用图的保存方法，直接用了 vector<int>[MAXN] 数组来存第 i 个人的直接下属。首先找到树根，也就是入度为 0 的（没有父亲或者说父亲是本身的）那个节点 Q，然后以此节点为起点做一遍 DFS，边 DFS 边状态转移，之后输出答案就好了。<\\/int><\\/p>\n<p>状态转移方程如下：<\\/p>\n<pre><code>dp[i][0] = max(dp[k1][0], dp[k1][1]) + ... + max(dp[kx][0], dp[kx][1])\n\\/\\/ 其中 k1 ... kx 是第 i 个员工的所有直属下属的下标\n\ndp[i][1] = dp[k1][0] + dp[k2][0] + ... + dp[kx][0]\n\\/\\/ 假如第 i 个员工要出席宴会，这种情况下他的直接下属都不能参加\n<\\/code><\\/pre><p>然后答案就是 <code>ans = max(dp[Q][0], dp[Q][1]);<\\/code>.<\\/p>\n<h2 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"><\\/a>代码<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nusing namespace std;\n\nconst int MAXN = 6010;\nint n;\nint rate[MAXN], p[MAXN];\nint dp[MAXN][2];\nvector&lt;int&gt; T[MAXN];\n\nvoid dfs(int s)\n{\n  if (T[s].size() == 0)\n  {\n    dp[s][1] = rate[s];\n    dp[s][0] = 0;\n    return;\n  }\n\n  for (int i = 0; i &lt; T[s].size(); i++)\n  {\n    int cur = T[s][i];\n    dfs(cur);\n    dp[s][0] += max(dp[cur][1], dp[cur][0]);\n    dp[s][1] += dp[cur][0];\n  }\n  dp[s][1] += rate[s];\n  return;\n}\n\nint main()\n{\n  while (scanf(&quot;%d&quot;, &amp;n) != EOF)\n  {\n    memset(rate, 0, sizeof(rate));\n    memset(p, 0, sizeof(p));\n    memset(dp, 0, sizeof(dp));\n\n    for (int i = 0; i &lt;= MAXN; i++)\n    {\n      T[i].clear();\n    }\n\n    for (int i = 1; i &lt;= n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;rate[i]);\n    }\n\n    int x, y;\n    while (scanf(&quot;%d%d&quot;, &amp;x, &amp;y) != EOF &amp;&amp; x != 0 &amp;&amp; y != 0)\n    {\n      T[y].push_back(x);\n      p[x] = y;\n    }\n\n    int s;\n    for (int i = 1; i &lt;= n; i++)\n    {\n      if (p[i] == 0)\n      {\n        s = i;\n        break;\n      }\n    }\n\n    dfs(s);\n    int ans = max(dp[s][0], dp[s][1]);\n    printf(&quot;%d\\n&quot;, ans);    \n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"12-200-HDU1166-敌兵布阵\"><a href=\"#12-200-HDU1166-敌兵布阵\" class=\"headerlink\" title=\"12\\/200, HDU1166, 敌兵布阵\"><\\/a>12\\/200, HDU1166, 敌兵布阵<\\/h1><p>题意自己看原题吧 Orz 反正是中文的，这题用 BIT 和单点修改的线段树都可以做，是个裸的板子题。记一下这道题的板子代码以防将来需要。<\\/p>\n<h2 id=\"BIT-version\"><a href=\"#BIT-version\" class=\"headerlink\" title=\"BIT version\"><\\/a>BIT version<\\/h2><p>因为只有单点修改，所以用树状数组完全可以胜任。<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt;\n\nconst int MAXN = 50005;\nint n;\nint c[MAXN];\n\nint lowbit(int x)\n{\n  return x &amp; (-x);\n}\n\nvoid add(int i, int value)\n{\n  while (i &lt;= n)\n  {\n    c[i] += value;\n    i += lowbit(i);\n  }\n}\n\nint sum(int x)\n{\n  int res = 0;\n  while (x &gt; 0)\n  {\n    res += c[x];\n    x -= lowbit(x);\n  }\n  return res;\n}\n\nint main()\n{\n  int t;\n  scanf(&quot;%d&quot;, &amp;t);\n\n  for (int i = t; i &gt; 0; i--)\n  {\n    printf(&quot;Case %d:\\n&quot;, t - i + 1);\n    scanf(&quot;%d&quot;, &amp;n);\n    memset(c, 0, sizeof(c));\n\n    for (int j = 1; j &lt;= n; j++)\n    {\n      int x;\n      scanf(&quot;%d&quot;, &amp;x);\n      add(j, x);\n    }\n\n    char str[10];\n    int x, y;\n    while (scanf(&quot;%s&quot;, str) != EOF &amp;&amp; str[0] != &#39;E&#39;)\n    {\n      scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\n      if (str[0] == &#39;Q&#39;) {\n        int res = sum(y) - sum(x-1);\n        printf(&quot;%d\\n&quot;, res);\n      }\n\n      if (str[0] == &#39;A&#39;) {\n        add(x, y);\n      }\n\n      if (str[0] == &#39;S&#39;) {\n        add(x, -y);\n      }\n    }\n\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n<h2 id=\"Segment-Tree-version\"><a href=\"#Segment-Tree-version\" class=\"headerlink\" title=\"Segment Tree version\"><\\/a>Segment Tree version<\\/h2><p>线段树的单点修改区间查询版也可以做这题，如下。写起来会比树状数组的版本麻烦一些。记得一个很重要的地方就是线段树的数组要开到 MAXN 的 4 倍。<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nconst int MAXN = 50010;\n\nint n;\nint kases, tmp;\n\nstruct SegTree\n{\n  int sum[MAXN &lt;&lt; 2];\n\n  void pushUp(int root) \n  {\n    sum[root] = sum[root * 2] + sum[root * 2 + 1];\n  }\n\n  void build(int left, int right, int root)\n  {\n    if (left == right)\n    {\n      scanf(&quot;%d&quot;, &amp;sum[root]);\n      return;\n    }\n    int middle = (left + right) \\/ 2;\n    build(left, middle, root * 2);\n    build(middle + 1, right, root * 2 + 1); \n\n    pushUp(root);\n  }\n\n  void update(int left, int right, int root, int pos, int addVal)\n  {\n    if (left == right)\n    {\n      sum[root] += addVal;\n      return;\n    }\n    int middle = (left + right) \\/ 2;\n\n    if (pos &lt;= middle)\n    {\n      update(left, middle, root * 2, pos, addVal);\n    }\n    else\n    {\n      update(middle + 1, right, root * 2 + 1, pos, addVal);\n    }\n\n    pushUp(root);\n  }\n\n  int query(int from, int to, int left, int right, int root)\n  {\n    if (from &lt;= left &amp;&amp; right &lt;= to)\n    {\n      return sum[root];\n    }\n\n    int middle = (left + right) \\/ 2;\n\n    int res = 0;\n    if (to &lt;= middle)\n    {\n      res += query(from, to, left, middle, root * 2);\n    }\n    else if (from &gt; middle)\n    {\n      res += query(from, to, middle + 1, right, root * 2 + 1);\n    }\n    else\n    {\n      res += query(from, to, left, middle, root * 2) + query(from, to, middle + 1, right, root * 2 + 1);\n    }\n\n    return res;\n  }\n\n  void init()\n  {\n    for (int i = 0; i &lt; MAXN; i++)\n    {\n      sum[i] = 0;\n    }\n  }\n};\n\nSegTree tree;\n\nint main()\n{\n  scanf(&quot;%d&quot;, &amp;kases);\n\n  while (kases--) \n  {\n    tmp++;\n    printf(&quot;Case %d:\\n&quot;, tmp);\n\n    scanf(&quot;%d&quot;, &amp;n);\n\n    tree.init();\n    tree.build(1, n, 1);\n\n    char commands[20];\n    while (scanf(&quot;%s&quot;, commands) != EOF &amp;&amp; commands[0] != &#39;E&#39;)\n    {\n      if (commands[0] == &#39;Q&#39;)\n      {\n        int x, y;\n        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\n        int res = tree.query(x, y, 1, n, 1);\n        printf(&quot;%d\\n&quot;, res);\n      }\n\n      if (commands[0] == &#39;A&#39;)\n      {\n        int x, y;\n        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n        tree.update(1, n, 1, x, y);\n      }\n\n      if (commands[0] == &#39;S&#39;)\n      {\n        int x, y;\n        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n        tree.update(1, n, 1, x, -y);\n      }\n    }\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n",
    "excerpt": "<p>这周主要是尝试了一些新的东西（ 做了一些之前一直想看但是一直没看懂和没做的题目。依旧是做 HDU 的题。虽然写得不是很熟练，不过慢慢来应该也是可以的。<br>另外下周由于要阶段考试这样子，可能就没有时间做题目了。<\\/p>",
    "slug": "practicing-record-3rd-8-14-8-20",
    "published": true,
    "layout": "post",
    "path": "blog/post/practicing-record-3rd-8-14-8-20/",
    "permalink": "https://kirainmoe.com/blog/post/practicing-record-3rd-8-14-8-20/",
    "tags": [
      {
        "name": "oi",
        "slug": "oi",
        "path": "tags/oi/",
        "permalink": "https://kirainmoe.com/tags/oi/",
        "length": 9
      },
      {
        "name": "algorithm",
        "slug": "algorithm",
        "path": "tags/algorithm/",
        "permalink": "https://kirainmoe.com/tags/algorithm/",
        "length": 8
      }
    ],
    "categories": []
  },
  "menu": {
    "Home": "/",
    "Guestbook": "/pages/guestbook/",
    "Friends": "/pages/friends/",
    "About": "https://about.me/kirainmoe"
  },
  "socials": {
    "twitter": "https://twitter.com/yume_kankawa",
    "github": "https://github.com/kirainmoe",
    "weibo": "https://weibo.com/returnnnn",
    "medium": "https://medium.com/@kotori",
    "lastfm": "https://www.last.fm/user/kirainmoe"
  },
  "avatar": "https://secure.gravatar.com/avatar/c47187d311099868de825697fa419654?s=200&r=G",
  "menuIcon": {
    "Home": "home",
    "Guestbook": "book",
    "Friends": "users",
    "Archives": "tags",
    "About": "id-card-o"
  },
  "disqus": "yume-diary"
}</script>
  <!-- hook node of React -->
  <div id="himawari-app"></div>

  
    <!-- scripts list from theme config.yml -->
    
      <script src="https://unpkg.com/muse-player/dist/assets/muse-player.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/prism.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-clike.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-php.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-css.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-c.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-cpp.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-javascript.min.js"></script>
    
      <script src="/common.js"></script>
    
      <script src="/main.js"></script>
    
  

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-111347233-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-111347233-1');
  </script>

</body>
</html>
