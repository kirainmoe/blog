<!DOCTYPE html>
<html><head>
<title>每周解题报告 (4th, 8/20~9/10)</title>

<meta charset="utf-8">
<meta name="X-UA-Compatible" content="IE=edge">
<meta name="google-site-verification" content="">
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
<meta content="telephone=no" name="format-detection">
<meta name="renderer" content="webkit">
<meta name="theme-color" content="#ffffff">




<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-111347233-1', 'auto');
	
	ga('send', 'pageview');
}
</script>



<script src="/vendor/js/jquery.min.js" ></script>
<script src="/vendor/js/popper.min.js" ></script>
<script src="/vendor/js/bootstrap.min.js" ></script>
<script src="/vendor/js/smooth-scroll.polyfills.min.js" ></script>
<link type="text/css" rel="stylesheet" href="/vendor/css/bootstrap.min.css">
<script src="/vendor/js/vue.min.js" ></script>




<link rel="stylesheet" href="https://kirainmoe.com/scss/journal.min.d1b323a5bdb0e7b05730834eb664c761432cfb57d618b4efeb5a9417a66a4b44.css" integrity="sha256-0bMjpb2w57BXMINOtmTHYUMs&#43;1fWGLTv61qUF6ZqS0Q=" media="screen">

<script src="https://kirainmoe.com//js/loadCSS.js"></script>
<script src="https://kirainmoe.com//js/table.js"></script>


<script src="https://kirainmoe.com//js/toc.js"></script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      showProcessingMessages: false,
      messageStyle: "none", 
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [["$", "$"], ["\\(", "\\)"]],
        displayMath: [["$$", "$$"], ["\\[", "\\]"]],
        skipTags: ["script", "noscript", "style", "textarea", "pre", "code", "a"]
      },
      "HTML-CSS": {
        availableFonts: ["STIX", "TeX"], 
        showMathMenu: false
      }
  });
</script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script src="https://unpkg.com/muse-player/dist/assets/muse-player.js"></script>

<script>
    loadCSS("https://fonts.googleapis.com/css?family=Lora|Montserrat|Fira+Mono|Noto+Serif+SC|Material+Icons");
</script>

</head><body>
    	<div id="app"><div ref="sideContainer" class="side-container">
    
    <a class="a-block nav-head false" href="https://kirainmoe.com/">
    
        <div class="nav-title">
            宇宙よりも遠い場所
        </div>
        
    </a>

    <div class="nav-link-list">
        
        
            
                
                
                <a class="a-block nav-link-item false" href="/pages/guestbook">
                    留言板
                </a>
        
            
                
                
                <a class="a-block nav-link-item false" href="/pages/friends">
                    友情链接
                </a>
        
            
                
                
                <a class="a-block nav-link-item false" href="/tags">
                    标签
                </a>
        
            
                
                
                <a class="a-block nav-link-item false" href="/pages/about">
                    关于
                </a>
        
    </div>

    

    <div class="nav-footer">
        &copy;
	
	2016-2020 宇宙よりも遠い場所
	

/

<a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC-BY-SA 4.0</a>

<br>

Published with <a href="https://gohugo.io">Hugo</a> / Theme <a href="https://github.com/amazingrise/hugo-theme-diary" title="Author: Rise @ amazingrise.net">Diary</a>

    </div>

    
    <script src="https://tj.kirainmoe.com/cgi-bin/inject_scriipt.cgi"></script>
    
</div><div ref="extraContainer" class="extra-container">
    
    <div class="toc animated-visibility" :class="{ invisible: scrollY <= 140 }">


	<div class="toc-content">
	
		
		
		
		<center>- CATALOG -</center>
			
				
				
					
						
						
							<ul>
						
						
								<li>
				 					<a href="#13-200-hdu1069-monkey-and-banana" v-on:click="closeDrawer" id="13-200-hdu1069-monkey-and-banana-nav">
										 13⁄200, HDU1069, Monkey and Banana
									</a>
								</li>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#solution" v-on:click="closeDrawer" id="solution-nav">
										 Solution
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#code" v-on:click="closeDrawer" id="code-nav">
										 Code
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
						
								<li>
				 					<a href="#14-200-hdu1176-%e5%85%8d%e8%b4%b9%e9%a6%85%e9%a5%bc" v-on:click="closeDrawer" id="14-200-hdu1176-免费馅饼-nav">
										 14⁄200, HDU1176, 免费馅饼
									</a>
								</li>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#solution-1" v-on:click="closeDrawer" id="solution-1-nav">
										 Solution
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
	</div>

</div>
    
    <div class="pagination">
        <a id="globalBackToTop" class="pagination-action animated-visibility" href="#top" :class="{ invisible: scrollY == 0 }">
            <i class="material-icons pagination-action-icon">
                keyboard_arrow_up
            </i>
        </a>
        
    </div>
</div><div class="single-column-drawer-container" ref="drawer"
     v-bind:class="{ 'single-column-drawer-container-active': isDrawerOpen }">
    <div class="drawer-content">
        <div class="drawer-menu">
            
            
                
                    
                    
                    <a class="a-block drawer-menu-item false" href="/pages/guestbook">
                        留言板
                    </a>
            
                
                    
                    
                    <a class="a-block drawer-menu-item false" href="/pages/friends">
                        友情链接
                    </a>
            
                
                    
                    
                    <a class="a-block drawer-menu-item false" href="/tags">
                        标签
                    </a>
            
                
                    
                    
                    <a class="a-block drawer-menu-item false" href="/pages/about">
                        关于
                    </a>
            
            
            <div class="toc">


	<div class="toc-content">
	
		
		
		
		<center>- CATALOG -</center>
			
				
				
					
						
						
							<ul>
						
						
								<li>
				 					<a href="#13-200-hdu1069-monkey-and-banana" v-on:click="closeDrawer" id="13-200-hdu1069-monkey-and-banana-nav">
										 13⁄200, HDU1069, Monkey and Banana
									</a>
								</li>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#solution" v-on:click="closeDrawer" id="solution-nav">
										 Solution
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#code" v-on:click="closeDrawer" id="code-nav">
										 Code
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
						
								<li>
				 					<a href="#14-200-hdu1176-%e5%85%8d%e8%b4%b9%e9%a6%85%e9%a5%bc" v-on:click="closeDrawer" id="14-200-hdu1176-免费馅饼-nav">
										 14⁄200, HDU1176, 免费馅饼
									</a>
								</li>
						
							</ul>
						
					
				
			
				
				
					
						
						
							<ul>
						
							<ul>
						
						
								<li>
				 					<a href="#solution-1" v-on:click="closeDrawer" id="solution-1-nav">
										 Solution
									</a>
								</li>
						
							</ul>
						
							</ul>
						
					
				
			
	</div>

</div>
            
        </div>
    </div>
</div>
<transition name="fade">
    <div v-bind:class="{ 'single-column-drawer-mask': mounted }" v-if="isDrawerOpen" v-on:click="toggleDrawer"></div>
</transition>
<nav ref="navBar" class="navbar sticky-top navbar-light single-column-nav-container">
    <div ref="navBackground" class="nav-background"></div>
    <div class="container container-narrow nav-content">
        <button id="nav_dropdown_btn" class="nav-dropdown-toggle" type="button" v-on:click="toggleDrawer">
            <i class="material-icons">
                menu
            </i>
        </button>
        <a ref="navTitle" class="navbar-brand" href="https://kirainmoe.com/">
            宇宙よりも遠い場所
        </a>
    </div>
</nav>
<div class="single-column-header-container" ref="pageHead"
     v-bind:style="{ transform: 'translateZ(0px) translateY('+.3*scrollY+'px)', opacity: 1-navOpacity }">
    <a href="https://kirainmoe.com/">
        <div class="single-column-header-title">宇宙よりも遠い場所</div>
        

    </a>
</div>
            <div id="content">
<div ref="streamContainer" class="stream-container">
    <div class="post-list-container post-list-container-shadow">
        <div class="post">
            
            
            

            <div class="post-head-wrapper-text-only"
                 style="background-image: url('/')">
                <div class="post-title">
                    每周解题报告 (4th, 8/20~9/10)
                    <div class="post-meta">
                        <time itemprop="datePublished">
                            2017-09-10 11:16
                        </time>

                        

                        
                            <i class="material-icons" style="">label</i>
                            
                                <a href="/tags/oi">oi</a>
                                &nbsp;
                            
                                <a href="/tags/algorithm">algorithm</a>
                                &nbsp;
                            
                        
                    </div>
                </div>
            </div>
            
            <div class="post-body-wrapper">
                <div class="post-body">
                    <p>经过了一周阶段考的折磨过后，这一周终于有时间更新解题报告了。上一周因为时间太少，加上填 MUSE 的坑，只做了一题，索性都屯到这一周来发了，但虽然这样这周的题量还是没有多到哪里去……</p>

<p>有些比较简单的题目我就两句话带过就好了。特地在 GitHub 上开了个仓库，这一篇包括之前那些解题报告中题目的所有完整代码（以及部分题的数据）以及接下来做的 HDU 的题都会汇总在<a href="https://github.com/kirainmoe/oh-my-hdu">这个地方</a>。</p>

<h1 id="13-200-hdu1069-monkey-and-banana"><sup>13</sup>&frasl;<sub>200</sub>, HDU1069, Monkey and Banana</h1>

<h2 id="solution">Solution</h2>

<p>经典 DP，最开始的思路是……设一个四维的状态…反正数据范围这么小是吧 (x) 后来写了好久写不下去了。查了一发题解，随便点开一个，看到第一句话：先把 x 排序，然后把 y 排序……会了……</p>

<p>那么，首先输入一组 xyz，然后排序一下，选择其中两个当做 width 和 length，然后最后一个数当 height；把 x, y 分别按照从大到小的顺序排序一遍，然后对 z 求满足第 i 层的 x, y 小于第 i-1 层的 x, y 时的最大 z 之和就好了。</p>

<p>转移方程：<code>dp[i] = dp[j] + block[i].height, 其中 j = 0...i-1</code></p>

<p>*// PS. 嘛，顺序枚举 j 似乎会 WA，所以 j 要从 i-1 倒回去。 *</p>

<h2 id="code">Code</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#</span><span style="color:#75715e">include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt; </span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAXN <span style="color:#f92672">=</span> <span style="color:#ae81ff">35</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">6</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">10</span>;
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Block</span> {
  <span style="color:#66d9ef">int</span> x, y, z;
};
Block b[MAXN];
<span style="color:#66d9ef">int</span> T, kases <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">int</span> size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">int</span> dp[MAXN];

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">cmp</span>(<span style="color:#66d9ef">const</span> Block a, <span style="color:#66d9ef">const</span> Block b)
{
  <span style="color:#66d9ef">if</span> (a.x <span style="color:#f92672">&gt;</span> b.x)
    <span style="color:#66d9ef">return</span> true;
  <span style="color:#66d9ef">if</span> (a.x <span style="color:#f92672">=</span><span style="color:#f92672">=</span> b.x <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> a.y <span style="color:#f92672">&gt;</span> b.y)
    <span style="color:#66d9ef">return</span> true;
  <span style="color:#66d9ef">return</span> false;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
  <span style="color:#66d9ef">while</span> (scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>T) <span style="color:#f92672">!</span><span style="color:#f92672">=</span> EOF <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> T <span style="color:#f92672">!</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>)
  {    
    size <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    memset(b, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(b));
    memset(dp, <span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">sizeof</span>(dp));
    
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> T; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)
    {
      <span style="color:#66d9ef">int</span> tx, ty, tz;
      scanf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%d%d%d</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">&amp;</span>tx, <span style="color:#f92672">&amp;</span>ty, <span style="color:#f92672">&amp;</span>tz);
      <span style="color:#66d9ef">int</span> arr[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> {tx, ty, tz};
      
      sort(arr, arr <span style="color:#f92672">+</span> <span style="color:#ae81ff">3</span>);
      
      <span style="color:#75715e">// permutation
</span><span style="color:#75715e"></span>      b[size].x <span style="color:#f92672">=</span> arr[<span style="color:#ae81ff">0</span>], b[size].y <span style="color:#f92672">=</span> arr[<span style="color:#ae81ff">1</span>], b[size<span style="color:#f92672">+</span><span style="color:#f92672">+</span>].z <span style="color:#f92672">=</span> arr[<span style="color:#ae81ff">2</span>];
      b[size].x <span style="color:#f92672">=</span> arr[<span style="color:#ae81ff">0</span>], b[size].y <span style="color:#f92672">=</span> arr[<span style="color:#ae81ff">2</span>], b[size<span style="color:#f92672">+</span><span style="color:#f92672">+</span>].z <span style="color:#f92672">=</span> arr[<span style="color:#ae81ff">1</span>];
      b[size].x <span style="color:#f92672">=</span> arr[<span style="color:#ae81ff">1</span>], b[size].y <span style="color:#f92672">=</span> arr[<span style="color:#ae81ff">2</span>], b[size<span style="color:#f92672">+</span><span style="color:#f92672">+</span>].z <span style="color:#f92672">=</span> arr[<span style="color:#ae81ff">0</span>];
      
      sort(b, b<span style="color:#f92672">+</span>size, cmp);
    }
    
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> size; i<span style="color:#f92672">+</span><span style="color:#f92672">+</span>)
    {
      dp[i] <span style="color:#f92672">=</span> b[i].z;
      <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; j <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j<span style="color:#f92672">-</span><span style="color:#f92672">-</span>)
      {
        <span style="color:#66d9ef">if</span> (b[i].x <span style="color:#f92672">&lt;</span> b[j].x <span style="color:#f92672">&amp;</span><span style="color:#f92672">&amp;</span> b[i].y <span style="color:#f92672">&lt;</span> b[j].y) {
          dp[i] <span style="color:#f92672">=</span> max(dp[j] <span style="color:#f92672">+</span> b[i].z, dp[i]);
        }
      }
      ans <span style="color:#f92672">=</span> max(ans, dp[i]);
    }
    printf(<span style="color:#e6db74"></span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">Case %d: maximum height = %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">+</span><span style="color:#f92672">+</span>kases, ans);
  }
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>
<h1 id="14-200-hdu1176-免费馅饼"><sup>14</sup>&frasl;<sub>200</sub>, HDU1176, 免费馅饼</h1>

<h2 id="solution-1">Solution</h2>

<p>这题有两种做法。</p>

<ol>
<li><p>第一种是直接 DP，注意的是可以不要想太多去检查状态是否合法，状态表示和转移方程：<code>dp[i][j]</code> 表示第 i 秒的时候站在第 j 个位置能接到的最大馅饼数，
则：<code>dp[i][j]  = max(dp[i-1][j], dp[i-1][j-1], dp[i-1][j+1]) + items[i][j] (如果 j-1 和 j+1 存在)</code></p></li>

<li><p>数塔做法：联想一下数字三角形，从下往上递推回去就行了。<code>dp[i][j]</code> 还是表示第 i 秒在第 j 个位置能取到的最大值，不同的是要逆推，并且可以直接覆盖掉之前的值（因为计算完就没有用了），则：</p>
<pre><code class="language-dp[i][j] =  max(dp[i+1][j-1], dp[i+1][j], dp[i+1][j+1]) + dp[i][j]```" data-lang="dp[i][j] =  max(dp[i+1][j-1], dp[i+1][j], dp[i+1][j+1]) + dp[i][j]```">## Code</code></pre>
<p>cpp</p></li>
</ol>

<p>// Solution 1
#include <bits/stdc++.h>
using namespace std;</p>

<p>const int MAXT = 1e5 + 10;
const int MAXP = 11;</p>

<p>int n, mt, ans = 0;
int items[MAXT][MAXP];
int dp[MAXT][MAXP];</p>

<p>int cmp(int a, int b, int c)
{
  return max(a, max(b, c));
}</p>

<p>int main()
{
  while (scanf(&ldquo;%d&rdquo;, &amp;n) != EOF &amp;&amp; n != 0)
  {
    memset(items, 0, sizeof(items));
    memset(dp, 0, sizeof(dp));
    mt = 0, ans = 0;
    for (int i = 0; i &lt; n; i++)
    {
      int x, t;
      scanf(&ldquo;%d%d&rdquo;, &amp;x, &amp;t);
      items[t][x]++;
      mt = max(t, mt);
    }</p>
<pre><code>dp[1][4] = items[1][4];
dp[1][5] = items[1][5];
dp[1][6] = items[1][6];

for (int i = 2; i <= mt; i++)
{
  for (int j = 0; j < MAXP; j++)
  {
    dp[i][j] = dp[i-1][j];
    if (j == 0) {
      dp[i][j] = max(dp[i-1][j], dp[i-1][j+1]) + items[i][j];
    } else if (j == MAXP - 1) {
      dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + items[i][j];
    } else {
      dp[i][j] = cmp(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]) + items[i][j];
    }
    ans = max(ans, dp[i][j]);
  }
}

printf("%d\n", ans);</code></pre>
<p>}
  return 0;
}</p>
<pre><code></code></pre>
<p>cpp
// Solution 2
#include <bits/stdc++.h>
using namespace std;
const int MAXT = 1e5 + 10;
const int MAXP = 11;</p>

<p>int n, mt, ans = 0;
int pies[MAXT][MAXP];</p>

<p>int main()
{
  while (scanf(&ldquo;%d&rdquo;, &amp;n) != EOF &amp;&amp; n)
  {
    memset(pies, 0, sizeof(pies));
    ans = 0;
    for (int i = 0; i &lt; n; i++)
    {
      int x, t;
      scanf(&ldquo;%d%d&rdquo;, &amp;x, &amp;t);
      pies[t][x]++;
      mt = max(mt, t);
    }</p>
<pre><code>for (int i = mt - 1; i >= 0; i--)
{
  for (int j = 0; j < MAXP; j++)
  {
    int tmp = pies[i][j];       // current
    pies[i][j] = pies[i+1][j];

    if (j > 0) {
      pies[i][j] = max(pies[i+1][j-1], pies[i][j]);
    }

    if (j < MAXP - 1) {
      pies[i][j] = max(pies[i+1][j+1], pies[i][j]);
    }

    pies[i][j] += tmp;
  }
}

printf("%d\n", pies[0][5]);</code></pre>
<p>}
  return 0;
}</p>
<pre><code># 15/200, Codeforces 846A, Curriculum Vitae

## Solution
题意就是一个人要找工作，要在简历上介绍他所完成过的游戏，游戏有成功的和失败的，这个人不想让任何失败的游戏出现在成功的游戏之后，然后求他最多可以在他的简历上放上多少个这样的符合要求的游戏。

↑ 说成人话就是：求一个由 0 和 1 组成的序列的子序列，这个子序列满足没有一个 0 在 1 的右边，且长度尽可能大。例如 0 1 0 0 1 0 的符合要求的子序列为 0 0 0 1 或 0 0 0 0.

翻译完之后我们可以发现，只要找到一个最长的数列的，使得它的左边都是 0，右边都是 1 就可以了。然后我们可以发现这个子序列满足**最长不下降（注意不是最长上升）**的性质。鉴于数据范围 <= 100，所以我们可以用 O(n^2) 的最长不下降子序列算法直接过。

第二天想了一下，突然觉得这题似乎还有线性的做法：考虑第 i 件作品是否入选，和它的上一件符合性质要求的作品有关。假如第 i 件作品是失败的，那么第 i 件写入简历时，最大值为 **上一件失败作品的最大值 + 1**；如果第 i 件作品是成功的，那么第 i 件写入简历时最大值为 **上一件失败作品的最大值 和 上一件成功作品的最大值 两者的最大值 + 1**。这样，我们可以用一个 ```last0``` 表示上一件失败作品的位置，用 ```last1``` 表示上一件成功作品的位置。具体的转移方程可以看代码：

## Code</code></pre>
<p>cpp
// Solution 1: O(n^2)
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 105;
const int INF = 1e9 + 7;
int n, ans = 0;
int arr[MAXN];
int dp[MAXN];
int main()
{
  memset(arr, 0, sizeof(arr));
  memset(dp, 0, sizeof(dp));</p>

<p>scanf(&ldquo;%d&rdquo;, &amp;n);
  for (int i = 0; i &lt; n; i++)
  {
    scanf(&ldquo;%d&rdquo;, &amp;arr[i]);
  }</p>

<p>for (int i = 0; i &lt; n; i++)
  {
    dp[i] = 1;
    for (int j = 0; j &lt; i; j++)
    {
      if (arr[j] &lt;= arr[i] &amp;&amp; dp[i] &lt; dp[j] + 1)
      {
        dp[i] = dp[j] + 1;
      }
    }
    ans = max(dp[i], ans);
  }</p>

<p>printf(&ldquo;%d&rdquo;, ans);</p>

<p>return 0;
}</p>
<pre><code></code></pre>
<p>cpp
// Solution 2: O(n)
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 105;
int n;
int dp[MAXN];
int last0 = -1, last1 = -1;
int main()
{
    memset(dp, 0, sizeof(dp));
    scanf(&ldquo;%d&rdquo;, &amp;n);
    for (int i = 0; i &lt; n; i++)
    {
        int tmp;
        scanf(&ldquo;%d&rdquo;, &amp;tmp);
        if (tmp == 0) {
            dp[i] = (last0 == -1 ? 1 : dp[last0] + 1);
            last0 = i;
        } else {
            if (i == 0) {
                dp[i] = 1;
            } else {
              dp[i] = 1;
                if (last0 != -1) {
                    dp[i] = max(dp[last0] + 1, dp[i]);
                }
                if (last1 != -1) {
                    dp[i] = max(dp[last1] + 1, dp[i]);
                }
            }
            last1 = i;
        }
    }
    int ans = 0;
    for (int i = 0; i &lt; n; i++)
    {
      ans = max(ans, dp[i]);
  }
  printf(&ldquo;%d&rdquo;, ans);
  return 0;
}</p>
<pre><code># 16/200, Codeforces 854A, Fraction

嗯……太水了，不想写了，就是单纯的计算。</code></pre>
<p>cpp
#include <bits/stdc++.h>
const int INF = 1e9 + 7;
int gcd(int a, int b)
{
  return (a == 0) ? b : gcd(b % a, a);
}
int main()
{
  int ori, curi = 1, curj = INF;</p>

<p>scanf(&ldquo;%d&rdquo;, &amp;ori);
  for (int i = 1; i &lt; ori; i++)
  {
    for (int j = i + 1; j &lt; ori; j++)
    {
      int gcder = gcd(j, i);
      double a = (double) i, b = (double) j;</p>
<pre><code>  if (
    (i + j) == ori &&
    gcder == 1 &&
    (double)(a / b) > (double)((double)curi / (double)curj)
  ) {
    curi = i, curj = j;
  }
}</code></pre>
<p>}</p>

<p>printf(&ldquo;%d %d&rdquo;, curi, curj);
  return 0;
}</p>
<pre><code># 17/200, HDU4568, Hunter

这题前前后后花了我两星期的时间……这星期又花了三天的时间看它，终于理解并且 A 掉了这题……果然状态压缩还是一个大坑 Orz……

## Solution
题目大意是给定一个 n*m 的地图，其中有一些点当中有宝藏，经过地图中的每个点都需要花费相应的代价。一个人要从边界进入这个地图，经过所有的宝藏点，然后从边界走出，问这样做的最小代价是多少。n, m <= 200, 宝藏数目 1 <= k <= 13.

首先题目的模型说成人话就是从边界的任何一点进入，取走所有宝藏，然后从边界的任意一点走出，所以我们可以知道最小代价应该是：从边界到第一个点的代价+第一个点到第二个点的代价+……+从终点走出边界的代价，这样这道题就被我们分解成了一个个的子问题了，我们只需要分别计算这些子问题就可以了。现在：

1. 从边界到第一个点的最小代价和从终点走出的边界如何知道？从第 i 个点到第 j 个点的最小代价又如何知道？SPFA 对每一个宝藏点跑一遍就行了，这样我们总共需要进行 k 次 SPFA。

2. 如何决策？每次拓展都选择当前一步代价最小的方案走显然有可能不是最优解，所以我们还是用动态规划来解全局最优的最小代价。

3. 用 DP 如何表示状态？这道题的要求是走完所有的宝藏点，那么我们首先考虑如何表示经过的和未经过的宝藏点。因为 k <= 13，我们的第一反应应该是状态压缩。用二进制表示状态点的经过情况，二进制第 i 位为 0 表示未经过第 i 个宝藏点，为 1 则表示已经经过，然后把二进制状态转换成十进制的整数即可。还有一个问题，假如只设置这样的一个状态，那么只能表示经过的点情况，不能表示终点在哪一个点，而我们到达终点的时候还需要从边界走出去，这样就还差一步，所以我们再设计一维状态，那么：

> 设 ```dp[i][j]``` 为当前经过的点状态为 i 且最后所在的终点位置为 j 时，所花费的最小代价。这样我们还能顺便得到转移方程：```dp[s | (1 << next)][next] = min(dp[s | (1 << next)][next], dp[s][cur] + toEach[cur][next])```, 其中 s 是当前状态，cur 是当前状态的终点，next 是下一步的点。

（为什么这里不需要表示起点？因为我们用 ```dp[1 << i][i] = toEdge[i]``` 可以很容易地表示以第 i 个点为起点时的代价，又我们的状态从 0 开始，所以起点在哪可以直接决策；但是终点我们很难通过 DP 方程直接决策，所以我们多一维状态。）

首先我们用 SPFA 先求出每两个宝藏点之间的距离和每个宝藏点到边界的距离（注意节点的拓展方向），然后就可以状态压缩了。DP 完之后，别忘了要回到边界，所以最终 ```ans = min(dp[(1 << k) - 1][i] + toEdge[i], ans), 其中 i = 0...k```.

这样我们就完美地解决了这个问题。

## Code</code></pre>
<p>cpp
#include <bits/stdc++.h>
using namespace std;
const int INF = 1e9 + 7;
const int MAXN = 205;
const int MAXT = 14;</p>

<p>struct Point {
  int x, y;
};
Point target[MAXT];    // 宝藏坐标</p>

<p>int k, cases, row, col;</p>

<p>// dp[i][j] 表示当前已经过的宝藏点状态为 i, 并且终点为 j 时所花费的最小代价
// 那么有 DP 方程：dp[s|(1&lt;&lt;next)][next] = min(dp[s|(1&lt;&lt;next)][s], dp[s][cur] + toEach[cur][next]);
// 其中 next 是下一个目标状态点，cur 是当前状态的终点
int dp[1 &lt;&lt; MAXT][MAXT];</p>

<p>// 用于 SPFA 计算每个宝藏点之间的距离
int dist[MAXN][MAXN];</p>

<p>// toEdge[i] 表示第 i 个宝藏点到边界的最小代价（不包括本身）
// toEach[i][j] 表示第 i 个宝藏点到第 j 个宝藏点的最小代价
int toEdge[MAXT], toEach[MAXT][MAXT];</p>

<p>// SPFA 拓展节点的方向
int dir[2][4] = {
  { 0, 0, 1, -1 },
  { 1, -1, 0, 0 }
};</p>

<p>// SPFA 记录点访问情况的数组
bool vis[MAXN][MAXN];</p>

<p>// 用不定长数组存储地图
vector<int> G[MAXN];</p>

<p>void SPFA(int s)
{
  // 初始化 SPFA
  memset(vis, 0, sizeof(vis));
  for (int i = 0; i &lt; MAXN; i++)
    for (int j = 0; j &lt; MAXN; j++)
      dist[i][j] = INF;</p>

<p>queue<Point> Q;</p>

<p>Point start;
  start.x = target[s].x, start.y = target[s].y;
  vis[start.x][start.y] = 1;    // 标记起点为已访问
  dist[start.x][start.y] = 0;   // 起点到自身的最短路为 0
  Q.push(start);</p>

<p>while (!Q.empty())
  {
    Point cur = Q.front();
    Q.pop();
    vis[cur.x][cur.y] = 0;    // 当前节点出队，标记为未访问</p>
<pre><code>// 到达边界，更新该点到边界的距离
if (cur.x == 0 || cur.y == 0 || cur.x == row - 1 || cur.y == col - 1) {
  toEdge[s] = min(toEdge[s], dist[cur.x][cur.y]);
}

// 拓展节点
for (int i = 0; i < 4; i++)
{
  Point next;
  next.x = cur.x + dir[0][i], next.y = cur.y + dir[1][i];
  // 检验节点合法性以及是否可到达
  if (next.x >= 0 && next.y >= 0 && next.x < row && next.y < col && G[next.x][next.y] != -1) {
    // 松弛操作
    if (dist[next.x][next.y] > dist[cur.x][cur.y] + G[next.x][next.y]) {
      dist[next.x][next.y] = dist[cur.x][cur.y] + G[next.x][next.y];
      if (!vis[next.x][next.y]) {
        Q.push(next);
        vis[next.x][next.y] = 1;
      }
    }
  }
} // end for i</code></pre>
<p>} // end while
}</p>

<p>void init()
{
  for (int i = 0; i &lt; MAXN; i++)
    G[i].clear();</p>

<p>for (int i = 0; i &lt; (1 &lt;&lt; MAXT); i++)
    for (int j = 0; j &lt; MAXT; j++)
      dp[i][j] = INF;</p>

<p>fill(toEdge, toEdge + MAXT, INF);</p>

<p>for (int i = 0; i &lt; MAXT; i++)
    for (int j = 0; j &lt; MAXT; j++)
      toEach[i][j] = INF;
}</p>

<p>int main()
{
  scanf(&ldquo;%d&rdquo;, &amp;cases);
  while (cases&ndash;)
  {
    init();
    scanf(&ldquo;%d%d&rdquo;, &amp;row, &amp;col);
    for (int i = 0; i &lt; row; i++)
    {
      for (int j = 0; j &lt; col; j++)
      {
        int tmp;
        scanf(&ldquo;%d&rdquo;, &amp;tmp);
        G[i].push_back(tmp);
      }
    }
    scanf(&ldquo;%d&rdquo;, &amp;k);
    for (int i = 0; i &lt; k; i++)
    {
      scanf(&ldquo;%d%d&rdquo;, &amp;target[i].x, &amp;target[i].y);
    }</p>
<pre><code>// 求每两个宝藏点之间的最短距离（最小代价）
for (int i = 0; i < k; i++)
{
  SPFA(i);
  for (int j = 0; j < k; j++)
  {
    // 自身到自身的代价为 0
    if (i == j) {
      toEach[i][j] = 0;
      continue;
    }
    int jx = target[j].x, jy = target[j].y;
    toEach[i][j] = min(toEach[i][j], dist[jx][jy]);
  }
  // dp[1 << i][i] 表示只访问了第 i 个点时的代价
  // 等于：从边界进来时的代价 + 自身的代价
  dp[1 << i][i] = toEdge[i] + G[target[i].x][target[i].y];
}

// solve
// 枚举从 0 到 (1 << k) - 1 的每个状态
for (int state = 0; state < (1 << k); state++)
{
  // 枚举该状态当前的终点
  for (int i = 0; i < k; i++)
  {
    // 如果状态不包含当前点，则回溯
    if ((state & (1 << i)) == 0) {
      continue;
    }

    // 如果当前状态下到终点的距离还没有计算，则回溯？
    // 不太清楚是不是这样的，因为我注释掉这段代码仍然是 AC 的
    if (dp[state][i] == INF) {
      continue;
    }

    // 枚举在当前状态时，下一个目标是去哪一个宝藏点呢
    for (int j = 0; j < k; j++)
    {
      // 如果这个宝藏点已经访问过了，就回溯，因为每个点只能走一次
      if ((state & (1 << j)) == 1) {
        continue;
      }
      // 下一个状态
      int next = (state | (1 << j));

      // 下一个状态 next，终点为 j 的最小代价等于 这个代价 和 当前代价+(cur, next)两点间最短距离 的最小值
      dp[next][j] = min(dp[next][j], dp[state][i] + toEach[i][j]);
    } // for j
  } // for i
} // for state

// 输出答案
int ans = INF;
for (int i = 0; i < k; i++)
{
  // 最终的最优答案是 min(dp[(1 << k) - 1][i]), i = 0...k
  // 因为 dp[i][j] 是以 j 为终点，但是我们最终需要从边界出去，所以还要加上终点到边界的最短距离
  ans = min(dp[(1 << k) - 1][i] + toEdge[i], ans);
}
printf("%d\n", ans);</code></pre>
<p>}
  return 0;
}
```</p>

<p>// EOF</p>
                    <HR width="100%" id="EOF">
                    <p style="color:#777;">Last modified on 2017-09-10</p>
                </div>
                
            </div>
            
            
            <nav class="post-pagination">

                
                <a class="newer-posts" href="https://kirainmoe.com/blog/post/making-slider-with-latex-beamer-on-windows/">
                    Next<br>使用 LaTeX &#43; Beamer 制作幻灯片 (Windows)
                </a>
                
                
                
                <a class="older-posts" href="https://kirainmoe.com/blog/post/webpack-plugin-developing-tutorial/">
                    Previous<br>开发一个简单的 webpack 插件
                </a>
                
            </nav>
            <div class="post-comment-wrapper">
                
<div class="post-comment-wrapper">
<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "yume-diary" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>




            </div>
        </div>
    </div>
</div>

            </div><div id="single-column-footer">&copy;
	
	2016-2020 宇宙よりも遠い場所
	

/

<a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh">CC-BY-SA 4.0</a>

<br>

Published with <a href="https://gohugo.io">Hugo</a> / Theme <a href="https://github.com/amazingrise/hugo-theme-diary" title="Author: Rise @ amazingrise.net">Diary</a>
</div>
    	</div>
    <script src="https://kirainmoe.com//js/journal.js"></script>
    </body>
</html>
