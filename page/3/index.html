<!-- Himawari no Yakusoku -->

<!DOCTYPE html>
<html lang="Zh-cn">
<head>
  <meta charset="UTF-8">
  <meta name="theme-color" content="#FF98A8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>6 年間、共に歩んでくれたあなたへ。 [ YumeのDiary ]</title>
  <meta name="description" content="6 年間、共に歩んでくれたあなたへ。">
  <link rel="manifest" href="/manifest.json">
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    
      <link rel="stylesheet" href="/himawari.css">
    
  
</head>
<body>
  
  <!-- infos -->
  <script type="text/json" id="himawari-json">{
  "title": "YumeのDiary",
  "siteTitle": "YumeのDiary",
  "description": "6 年間、共に歩んでくれたあなたへ。",
  "author": "Yume Kankawa",
  "route": "index",
  "format": "blog/:layout/:title/",
  "posts": [
    {
      "title": "一次搭建内部 Online Judge 及调优的笔记",
      "date": "2017-08-05T13:05:18.000Z",
      "modified": "2018-01-07T05:18:32.715Z",
      "content": "<p>嗯，就是搭 OJ 这破事把我拽进了 Python 和 docker 的大坑中……<br>为了给本校 OI 学员的交流和练(gao)习(shi)提供条件，便有了搭建 OJ 的这么一个想法。以前一直以为这种事情就和装个 WordPress 什么的差不多嘛，真正跳进去才发现，woc 这水居然这么深。<br>关于 OJ 的选择，这里我用的是青岛大学 (QingdaoU) 的开源项目 <a href=\"https:\\/\\/github.com\\/QingdaoU\\/OnlineJudge\" target=\"_blank\" rel=\"external\">qduoj<\\/a>。<\\/p>\n<a id=\"more\"><\\/a>\n<p>之所以选 qduoj 呢是因为<s>好看<\\/s>这个 OJ 的架构比较让人满意，网页端采用了 Python Django，判题端的沙箱做得还可以，然后整个项目跑在 docker 中，可以最大限度地减少对宿主机留下的后遗症，以及在判题方面有更高的安全保障。<\\/p>\n<p>我是在一台 Xeon E3 的 ThinkServer 上部署的 Online Judge，操作系统是 Arch Linux, 运行截至写本文之日最新版的 docker. 这个环境可以供各位参考一下，<s>毕竟 Arch Linux 大法好<\\/s>.<\\/p>\n<h1 id=\"Installation\"><a href=\"#Installation\" class=\"headerlink\" title=\"Installation\"><\\/a>Installation<\\/h1><p>部署之前，先按照项目 README 中的一步一步走就是了。项目需要 docker 和 docker-compose，由于我用的是 Arch，所以通过下面的命令安装依赖：<\\/p>\n<pre><code class=\"shell\"># pacman -S git python-pip docker docker-compose\n<\\/code><\\/pre>\n<p>安装完之后我们启动 docker 服务：<\\/p>\n<pre><code class=\"shell\"># systemctl start docker\n<\\/code><\\/pre>\n<p>然后就是把项目克隆到本地，这一步就不多说了，然后接下来是关键的一步，同时也是这个项目的第一个坑：<\\/p>\n<p>首先我们来看看原文 (README) 中是怎么说的：<\\/p>\n<blockquote>\n<p>启动服务：运行 docker-compose up -d ，不需要其他的步骤，大约一分钟之后 web 界面就可以访问了，默认开放80和443端口。其中443端口是自签名证书。<\\/p>\n<p>这就结束了：超级管理员用户名是root，默认密码是password@root，请及时修改。登录\\/admin，添加一个判题服务器，地址为judger，端口为8080，密码是上面自定义的rpc_token。修改custom_settings.py可以自定义站点信息。<\\/p>\n<\\/blockquote>\n<p>天真的我照做了，然后一切正常，打开浏览器访问 <a href=\"http:\\/\\/localhost\\/\" target=\"_blank\" rel=\"external\">http:\\/\\/localhost\\/<\\/a> ，然后喜闻乐见地 connection reset 了。对于一个对 docker 和 python 一窍不通的萌新来说，没有什么比用当场懵逼形容更合适不过的了……<\\/p>\n<p>于是翻 issues, 查找 docker 的玩法，调出了 oj_web_server 这个容器的 log，从 log 中发现找不到 WEBSITE_INFO 的 attribute，WEBSITE_INFO 在 custom_settings.py 当中有定义，初步推断应该是容器内的 django 读不到放在容器外的 custom_settings.py.<\\/p>\n<p>然后打开 docker-compose.yml 一看，似乎没什么不对啊。于是乎在群内求助，经由<a href=\"https:\\/\\/boot.pw\\/\" target=\"_blank\" rel=\"external\">田师傅<\\/a>的指导，将 docker-compose.yml 中的 <code>$PWD<\\/code> 变量统统改成 <code>.\\/<\\/code> 之后，重新 <code>docker-compose up -d<\\/code>，终于在浏览器中看到了这个 OJ 的真容。大概可能也许是原项目对 <code>$PWD<\\/code> 的环境变量使用有问题吧 OvO……或者是不同发行版不兼容……或者是我少配置了什么……谁知道呢。<\\/p>\n<h1 id=\"一些优化\"><a href=\"#一些优化\" class=\"headerlink\" title=\"一些优化\"><\\/a>一些优化<\\/h1><p>搭好了之后，就是魔改它的时间了……想了想，这是个基于 docker 的项目诶，想要魔改似乎很麻烦的说。<\\/p>\n<p>鉴于每次在容器中修改之后再 commit 的方法十分麻烦，这里我直接把容器里的代码部分复制出来，然后再用 docker 的数据卷机制从宿主机映射回去，这样就可以很方便地修改了，同时容器中也会实时更新：<\\/p>\n<pre><code class=\"shell\"># docker cp oj_web_server:\\/code \\/home\\/username\\/code\n<\\/code><\\/pre>\n<p>然后再修改 docker-compose.yml，按照其中的其它映射数据卷的配置的格式抄一遍，把复制出来的目录映射回去镜像里就可以了。<\\/p>\n<h1 id=\"填坑\"><a href=\"#填坑\" class=\"headerlink\" title=\"填坑\"><\\/a>填坑<\\/h1><p>生产过程中还是在不停地踩坑……大部分是在判题的部分踩的。<\\/p>\n<h3 id=\"添加题目的时候标题等字段必须有英文，且不能出现公式字符\"><a href=\"#添加题目的时候标题等字段必须有英文，且不能出现公式字符\" class=\"headerlink\" title=\"添加题目的时候标题等字段必须有英文，且不能出现公式字符\"><\\/a>添加题目的时候标题等字段必须有英文，且不能出现公式字符<\\/h3><p>这个只能说似乎防 XSS 的机制做得好像太严格了，稍微修改一下问题的表达，问题不大。<\\/p>\n<h3 id=\"编译失败，Compile-Error，后面是一大串-JSON\"><a href=\"#编译失败，Compile-Error，后面是一大串-JSON\" class=\"headerlink\" title=\"编译失败，Compile Error，后面是一大串 JSON\"><\\/a>编译失败，Compile Error，后面是一大串 JSON<\\/h3><p>大概像这样的：<\\/p>\n<pre><code class=\"json\">Compile error: Compile error, info: {&#39;cpu_time&#39;: 1203, &#39;exit_status&#39;: 0, &#39;signal&#39;: 0, &#39;flag&#39;: 3, &#39;memory&#39;: 164458496, &#39;real_time&#39;: 1263}\n<\\/code><\\/pre>\n<p>当我看到标程 CE 的时候，又是一脸懵逼状。<\\/p>\n<p>参考这个 issue: <a href=\"https:\\/\\/github.com\\/QingdaoU\\/OnlineJudge\\/issues\\/40\" target=\"_blank\" rel=\"external\">https:\\/\\/github.com\\/QingdaoU\\/OnlineJudge\\/issues\\/40<\\/a> ，原来是评测机里限制了编译时候的资源，包括 CPU 时间和内存什么的。但是可能是评测机的性能太差了，即使原作者放宽了限制依旧存在这个问题。那么只能再人为地放宽这个限制了。<\\/p>\n<p>用你喜欢的办法修改 judger 容器中的 language.py，把其中的 compile_max_cpu_time 和 compile_max_memory 稍微调大一点就好了。<\\/p>\n<h3 id=\"Compiler-Bomb\"><a href=\"#Compiler-Bomb\" class=\"headerlink\" title=\"Compiler Bomb\"><\\/a>Compiler Bomb<\\/h3><p>如果你闲着无聊的话，试试下面这件事：在一个 .c 文件中写入这段代码: <code>main[-1u]={1};<\\/code>，然后用 gcc 编译。仅对 C 语言有效，C++ 无效。<\\/p>\n<p><s>这可是你自己要作死的。<\\/s><\\/p>\n<blockquote>\n<p>编译这段代码之后，会生成16GB的文件。<\\/p>\n<\\/blockquote>\n<p>关于编译器炸弹的原理，请看这里：<a href=\"http:\\/\\/link.zhihu.com\\/?target=https%3A\\/\\/wikicoding.org\\/wiki\\/c\\/Compiler_Bomb\\/%3Futm_content%3Dbuffer7c944%26utm_medium%3Dsocial%26utm_source%3Dfacebook.com%26utm_campaign%3Dbuffer\" target=\"_blank\" rel=\"external\">http:\\/\\/link.zhihu.com\\/?target=https%3A\\/\\/wikicoding.org\\/wiki\\/c\\/Compiler_Bomb\\/%3Futm_content%3Dbuffer7c944%26utm_medium%3Dsocial%26utm_source%3Dfacebook.com%26utm_campaign%3Dbuffer<\\/a><\\/p>\n<p>网上有一篇文章说限制编译出的可执行文件的大小，然而我并没有在 gcc 的编译选项中看到任何可以限制大小的参数……<\\/p>\n<p>不过既然这个东西会生成 16GB 的文件，那么写入的话肯定需要时间对吧，既然如此我们还是可以通过限制编译所用的最大时间来防范这种攻击，超时的话直接干掉编译器返回 CE. 鉴于我并不知道判题端容器中的 gcc 似乎没有受到上文说的 compile_max_cpu_time 的限制的原因，我们直接从编译命令上下手，修改 language.py 中的 compile_command：<\\/p>\n<pre><code>&quot;compile_command&quot;: &quot;\\/usr\\/bin\\/gcc -DONLINE_JUDGE -O2 -w -fmax-errors=3 -std=c99 {src_path} -lm -o {exe_path}\\/main&quot;\n<\\/code><\\/pre><p>改成：<\\/p>\n<pre><code>&quot;compile_command&quot;: &quot;timeout 3s \\/usr\\/bin\\/gcc -DONLINE_JUDGE -O2 -w -fmax-errors=3 -std=c99 {src_path} -lm -o {exe_path}\\/main&quot;\n<\\/code><\\/pre><p>这样子给编译设置一个最长 3s 的限制（当然，根据机器性能的不同，你可以设置短一点或者长一点），超过了就直接 kill 掉 gcc.<\\/p>\n<p>（大概还有很多坑没有踩，接下来再慢慢补充吧……）<\\/p>\n",
      "excerpt": "<p>嗯，就是搭 OJ 这破事把我拽进了 Python 和 docker 的大坑中……<br>为了给本校 OI 学员的交流和练(gao)习(shi)提供条件，便有了搭建 OJ 的这么一个想法。以前一直以为这种事情就和装个 WordPress 什么的差不多嘛，真正跳进去才发现，woc 这水居然这么深。<br>关于 OJ 的选择，这里我用的是青岛大学 (QingdaoU) 的开源项目 <a href=\"https:\\/\\/github.com\\/QingdaoU\\/OnlineJudge\">qduoj<\\/a>。<\\/p>",
      "slug": "notes-of-building-an-online-judge",
      "published": true,
      "layout": "post",
      "path": "blog/post/notes-of-building-an-online-judge/",
      "permalink": "https://kirainmoe.com/blog/post/notes-of-building-an-online-judge/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "online judge",
          "slug": "online-judge",
          "path": "tags/online-judge/",
          "permalink": "https://kirainmoe.com/tags/online-judge/",
          "length": 1
        },
        {
          "name": "python",
          "slug": "python",
          "path": "tags/python/",
          "permalink": "https://kirainmoe.com/tags/python/",
          "length": 1
        },
        {
          "name": "docker",
          "slug": "docker",
          "path": "tags/docker/",
          "permalink": "https://kirainmoe.com/tags/docker/",
          "length": 1
        }
      ],
      "categories": []
    },
    {
      "title": "奇怪的道路 (FCS2017 D2T1)",
      "date": "2017-07-19T12:12:30.000Z",
      "modified": "2018-01-07T05:18:39.209Z",
      "content": "<p>emmm… FCS2017 夏令营的一道题目……用的是分治的算法，为了题目的一些细节本蒟蒻足足推了两个小时QAQ……所以要写篇文章记录一下不然哪天自己就看不明白了……<\\/p>\n<p>由于我比较啰嗦，以及我太弱了导致文章有可能有一些部分讲错了，所以，大家将就着看一下吧（虽然我不相信有人看）。<\\/p>\n<a id=\"more\"><\\/a>\n<h1 id=\"奇怪的道路\"><a href=\"#奇怪的道路\" class=\"headerlink\" title=\"奇怪的道路\"><\\/a>奇怪的道路<\\/h1><h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"><\\/a>问题描述<\\/h2><p>从前，有一座网格城市，城市中每个房子占据一个正方形小格子的中<br>心，每个正方形小格子的边长均为1。<\\/p>\n<p><img src=\"https:\\/\\/i.loli.net\\/2017\\/07\\/19\\/596f4bfc53442.png\" alt=\"road\"><\\/p>\n<p>这座城市道路的设计方式是这样的，首先，定义(𝑎)图为一个基本图形，其阶为1，之后，将(𝑎)图中每一个房子都用一个基本图形代替，得到(𝑏)图，那么(𝑏)图的阶即为2，再将(𝑏)图中的每一个房子都用基本图形替代，得到阶为3的(c)图，以此类推，只要知道这座城市的阶𝑛，就可以知道它的道路设计。<\\/p>\n<p>这种七拐八弯的道路设计使得这座城市之间的道路交通运输相当不便，于是该市的市长决定改造一下这座城市的道路，但在此之前他需要做一系列的评估，比如这座网格城市中，连接第𝑖1行第𝑗1列的房屋与第𝑖2行第𝑗2列的房屋之间（两座房屋可能相同）的道路有多长，由于这种道路设计太过奇怪，人力难以计算，于是这个任务就交给作为软件工程师的你了。<\\/p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"><\\/a>输入格式<\\/h2><p>每个测试点第一行有两个正整数𝑛, 𝑇，表示城市的阶数和询问数。<br>接下来𝑇行，每行4个正整数𝑖1 𝑗1 𝑖2 𝑗2，表示要查询的两个房屋的坐标。<\\/p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"><\\/a>输出格式<\\/h2><p>对每个询问输出一行相应的值表示答案。<\\/p>\n<h2 id=\"样例输入\"><a href=\"#样例输入\" class=\"headerlink\" title=\"样例输入\"><\\/a>样例输入<\\/h2><blockquote>\n<p>2 4<br>2 1 3 1<br>3 2 2 2<br>2 3 3 3<br>3 4 2 4<\\/p>\n<\\/blockquote>\n<h2 id=\"样例输出\"><a href=\"#样例输出\" class=\"headerlink\" title=\"样例输出\"><\\/a>样例输出<\\/h2><blockquote>\n<p>13<br>11<br>1<br>3<\\/p>\n<\\/blockquote>\n<h2 id=\"样例解释\"><a href=\"#样例解释\" class=\"headerlink\" title=\"样例解释\"><\\/a>样例解释<\\/h2><p>样例对应题目中的(𝑏)图。<br>第一个询问问的是图中编号为2的房子与编号为15的房子的距离。<br>第二个询问问的是图中编号为14的房子与编号为3的房子的距离。<br>第三个询问问的是图中编号为8的房子与编号为9的房子的距离。<br>第四个询问问的是图中编号为10的房子与编号为7的房子的距离。<\\/p>\n<h2 id=\"数据规模\"><a href=\"#数据规模\" class=\"headerlink\" title=\"数据规模\"><\\/a>数据规模<\\/h2><p>Easy：对于30%的数据，1 ≤ 𝑛 ≤ 3。<br>Normal：对于60%的数据，1 ≤ 𝑛 ≤ 8。<br>Hard：对于100%的数据，均有1 ≤ 𝑛 ≤ 15，1 ≤ 𝑖1, 𝑗1, 𝑖2, 𝑗2 ≤ 2𝑛，1 ≤ 𝑇 ≤ 10000。<\\/p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"><\\/a>思路<\\/h2><p>观察题意，不难看出，对于给定的坐标 (x1, y1) 和 (x2, y2)，记他们所对应的房子编号分别为 A, B，要求 A, B 两个房子之间的距离，可以看出<strong>这个距离等于编号A - 编号B 的绝对值<\\/strong>，记这个距离为 x，则我们可以看出：<code>x = abs(A - B)<\\/code>。既然距离是由两个房子的编号唯一决定，那么我们就可以将目标转移到<strong>求这两个坐标对应的房子的编号上<\\/strong>。<\\/p>\n<p>首先看 n 的范围不超过 15，也就是说最大的房子数量不超过 4 ^ 15 = 1073741824，做预处理的话开不下这么大的空间。这启示我们，一定存在一种方法，<strong>对于给定的一个城市坐标 (x, y)，通过这种方法能够直接推算出这个坐标所对应的房子编号<\\/strong>。<\\/p>\n<p>我们先观察这个图：观察当 n &gt;= 2 时候的图形，可以发现图形有这样的规律：基本图形总是会占满整个四分之一矩阵后，才会进入下一个四分之一矩阵。通过这样的规律，我们又能发现这四个被均分的矩阵<strong>具有相似的子结构<\\/strong>，所以我们可以想到——<strong>分！治！<\\/strong><\\/p>\n<p>接下来，目标转移到找到这个方法。题意告诉我们，对于任意已知的 n，以从上到下（行）为 x 轴正方向，以从左到右（列）为 y 轴正方向，第一个房子的坐标一定位于 (1, 1)，第 4^n 个房子一定位于 (2^n+1, 1)，所以根据这个性质我们一定能够推算出这个城市的具体道路规划图。<\\/p>\n<p>问题在于，编号和坐标之间有没有什么关系？<s>当然这种琢磨不透的题目<\\/s>一定不会让你一眼看出这个关系，所以我们需要一点小小的计算：<\\/p>\n<p>首先让我们看当 n = 1，即这个城市只有 1 阶，边长为 2^1=2，房子数 4^1 = 4。根据题意，我们有这样的关系：<\\/p>\n<pre><code>  1     2\n=========\n1 1 --- 2\n        |\n        |\n        |\n2 4 --- 3\n<\\/code><\\/pre><p>可以看到对于这样的矩阵，知道坐标的区间，就可以唯一确定城市的房子了。比如说在这里，(1, 1) 就对应房子 1。至于为什么和怎么确定，我们下面再说。不过说到这里有人还是会对这个 <s>flag<\\/s> 将信将疑：坐标对应的房子可能会受到这个“基本图形”开口的影响，凭什么说它可以唯一确定一个房子的编号？的确，假如它的开口不同，就会导致这个性质是错的。<s>既然如此我们就把这个反例消灭<\\/s>，保证一个子矩阵始终满足这个基本图形的性质。具体地说，对于已知 n = k 的 k 阶矩阵，一定要满足这个性质：<\\/p>\n<blockquote>\n<p>在最左上方取到这个矩阵中数的最小值，并在最左下方取到这个矩阵中数的最大值。<\\/p>\n<\\/blockquote>\n<p>具体的操作，比如说我们看下面的这个图，这也是由基本图形变形而来的：<\\/p>\n<pre><code> 1     4\n |     |\n |     |\n 2 --- 3\n<\\/code><\\/pre><p>那么怎么把它变成基本图形那样，可能大家的第一想法是旋转。但是旋转之后，并不满足在左上取最小值和左下取最大值的性质，所以旋转是不行的。所以我们采取另外一个方法，就是对称。例如上图中，我们取 1, 3 连接而成的对角线为对称轴，将这个图形沿着轴对称，那么这个图形就在还原回基本图形的同时，也保持了这个性质。<\\/p>\n<p>现在又有一个问题。如何知道什么时候对称，沿什么轴来对称？根据分治的思想我们再观察四个图形，我们发现，记当 n=k 的时候边长为 E, 则 E = 2^k，节点数为 N, 则 N = 4^k. 以中点为界将这个矩阵划分为相等的四个部分，<strong>右上角的矩阵和右下角的矩阵会始终保持着这个性质<\\/strong>，那么我们的对称操作只需要对左上和左下的两个矩阵执行就可以了。观察左上和左下的两个矩阵，我们在确定对称轴的时候只需要找到对称后<strong>还原出基本图形及满足其性质<\\/strong>（<s>窝说话太啰嗦了，所以希望你们还记得这个性质<\\/s>）的那一条对称轴即可。再看图形，我们很容易找出，使得左上部分矩阵符合以上性质的对称轴为<strong>从左上到原矩阵中心位置<\\/strong>的这条<strong>对角线<\\/strong>，同样我们为左下矩阵找到的对称轴为<strong>从左下到原矩阵中心位置<\\/strong>的这条<strong>对角线<\\/strong>。<\\/p>\n<p>下面开始用坐标推算房子的编号。我们规定<code>getnum(n, x, y)<\\/code>为<strong>第 n 阶中坐标位于 (x, y) 的房子的编号<\\/strong>，并且规定当 n = 0 的时候，<code>getnum(0, 1, 1) = 1<\\/code>。令 edgeMid = 当前阶的大矩阵边长的一半，有 <code>mid = 2^(n-1)<\\/code>，nodeNum = 当前阶的大矩阵被四均分后的节点数目，有 <code>node = 4^(n-1) = 2^(2n-2)<\\/code>.<\\/p>\n<p>注意到我们刚才提到的性质1：基本图形会先填满一个四分之一矩阵之后，才会进入下一个矩阵。而且无论 n 为何值，进入四个矩阵的先后顺序一定是：左上 =&gt; 右上 =&gt; 右下 =&gt; 左下。所以呢，对于右上的矩阵，编号最小的房子一定是 nodeNum + 1；对于右下的矩阵，编号最小的房子一定是 2 × nodeNum + 1；对于左下的矩阵，编号最小的房子一定是 3 × nodeNum + 1。最大的也很容易推出。<\\/p>\n<p>先从简单的两个子矩阵——也就是不需要做任何对称的两个矩阵入手：对于每个阶段右上和右下这两个不需要做对称操作的部分，其坐标和编号的关系是显然的一个递推式：<\\/p>\n<pre><code>\\/\\/ 右上\nindex = 1 * nodeNum + getnum(n - 1, x, y - edgeMid);\n\n\\/\\/ 右下\nindex = 2 * nodeNum + getnum(n - 1, x - edgeMid, y - edgeMid);\n<\\/code><\\/pre><p>其中进行坐标变换是为了确保起点为 (1, 1)，终点为 (2^n+1, 1)，这样根据坐标推出的编号才会成立。<\\/p>\n<p>进行对称操作的部分的坐标需要进行额外的小变化，因为<strong>进行了对称<\\/strong>，所以我们要<strong>将 x 和 y 进行反转<\\/strong>。同样也要进行坐标变换确保起点为 (1, 1) 和 (2^n+1, 1)。这里要注意一下左下矩阵的边界处理。<\\/p>\n<pre><code>\\/\\/ 左上\nindex = getnum(n - 1, y, x);\n\n\\/\\/ 左下\nindex = 3 * nodeNum + getnum(n - 1, edgeMid + 1 - y, 2 * edgeMid + 1 - x);\n<\\/code><\\/pre><p>注意这里的坐标轴方向是以向下为 x 轴正方向，向右为 x 轴负方向，这样大家画一画草图就可以很容易地推出左下矩阵这个让人看了十分害怕的递推式。<\\/p>\n<p>至此，我们的目的——根据节点坐标推算它的编号——已经达到了。不信的话你可以随便找个点按照上面的递推式试一下。<\\/p>\n<p>以下贴的是参考代码。事实上理解了上面的内容，代码也就不难出来了。<\\/p>\n<h2 id=\"示例代码-C\"><a href=\"#示例代码-C\" class=\"headerlink\" title=\"示例代码 (C++)\"><\\/a>示例代码 (C++)<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nint getNum(int stage, int x, int y)\n{\n  if (stage == 1) {\n    if (x == 1 &amp;&amp; y == 1)\n      return 1;\n    if (x == 1 &amp;&amp; y == 2)\n      return 2;\n    if (x == 2 &amp;&amp; y == 2)\n      return 3;\n    if (x == 2 &amp;&amp; y == 1)\n      return 4;\n  }\n\n  int edgeMid = 1 &lt;&lt; (stage - 1),                    \\/\\/ edgeMid = 2^(stage-1)\n      nodeNum = 1 &lt;&lt; (2 * (stage - 1));   \\/\\/ nodeNum = 4^(stage-1) = 2^2(stage-1)\n\n  if (x &lt;= edgeMid &amp;&amp; y &lt;= edgeMid)\n    return getNum(stage - 1, y, x);\n  if (x &lt;= edgeMid &amp;&amp; y &gt; edgeMid)\n    return nodeNum + getNum(stage - 1, x, y - edgeMid);\n  if (x &gt; edgeMid &amp;&amp; y &gt; edgeMid)\n    return 2 * nodeNum + getNum(stage - 1, x - edgeMid, y - edgeMid);\n  if (x &gt; edgeMid &amp;&amp; y &lt;= edgeMid)\n    return 3 * nodeNum + getNum(stage - 1, edgeMid + 1 - y, 2 * edgeMid + 1 - x);\n\n}\n\nint main()\n{\n  freopen(&quot;road.in&quot;, &quot;r&quot;, stdin);\n  freopen(&quot;road.out&quot;, &quot;w&quot;, stdout);\n\n  int n, T;\n  scanf(&quot;%d%d&quot;, &amp;n, &amp;T);\n\n  while (T--)\n  {\n    int x1, y1, x2, y2;\n    scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);\n    printf(&quot;%d\\n&quot;, abs(getNum(n, x1, y1) - getNum(n, x2, y2)));\n  }\n\n  fclose(stdin);\n  fclose(stdout);\n\n  return 0;\n}\n<\\/code><\\/pre>\n<blockquote>\n<p>这样我们就圆满地解决了这个问题。 —— 题解<\\/p>\n<\\/blockquote>\n<ul>\n<li>原题版权归出题人所有。<\\/li>\n<\\/ul>\n",
      "excerpt": "<p>emmm… FCS2017 夏令营的一道题目……用的是分治的算法，为了题目的一些细节本蒟蒻足足推了两个小时QAQ……所以要写篇文章记录一下不然哪天自己就看不明白了……<\\/p>\n<p>由于我比较啰嗦，以及我太弱了导致文章有可能有一些部分讲错了，所以，大家将就着看一下吧（虽然我不相信有人看）。<\\/p>",
      "slug": "strange-road-fcs2017-d2-solution",
      "published": true,
      "layout": "post",
      "path": "blog/post/strange-road-fcs2017-d2-solution/",
      "permalink": "https://kirainmoe.com/blog/post/strange-road-fcs2017-d2-solution/",
      "tags": [
        {
          "name": "algorithms",
          "slug": "algorithms",
          "path": "tags/algorithms/",
          "permalink": "https://kirainmoe.com/tags/algorithms/",
          "length": 1
        },
        {
          "name": "divide",
          "slug": "divide",
          "path": "tags/divide/",
          "permalink": "https://kirainmoe.com/tags/divide/",
          "length": 1
        }
      ],
      "categories": []
    },
    {
      "title": "从根源缩小 webpack 打包的 React App 体积",
      "date": "2017-06-06T02:51:43.000Z",
      "modified": "2018-01-07T05:18:36.776Z",
      "content": "<p>用 webpack 打包 React App 可谓是 React 开发中的最佳实践，但是有个令人十分头疼的问题就是在堆上了一堆依赖之后，用 webpack 打包出来的东西体积非常非常非常大，加载和首屏渲染的时间就要非常非常非常久，用户体验自然也就非……很不好。有很多前辈已经研究了很多缩小 webpack 打包出的 React App 体积的办法，这里我想讲一下自己踩这个大坑的经历以及发现的一个可行的方案。<\\/p>\n<a id=\"more\"><\\/a>\n<p><s>上一次更文已经是四……三……月份了？再不写点啥这里都有长草了……<\\/s><\\/p>\n<h1 id=\"在这之前\"><a href=\"#在这之前\" class=\"headerlink\" title=\"在这之前\"><\\/a>在这之前<\\/h1><p>关于如何缩小 webpack 打包出的 bundle 的体积，已经有很多的引路人为我们填下了很多的坑，所以如果你想要缩减体积提高 React App 的首屏渲染效率，你可以参考以下的这些方法：<\\/p>\n<h2 id=\"将第三方库与业务代码分离打包\"><a href=\"#将第三方库与业务代码分离打包\" class=\"headerlink\" title=\"将第三方库与业务代码分离打包\"><\\/a>将第三方库与业务代码分离打包<\\/h2><p>大概是个治标不治本的方法，因为要正常渲染还是都要加载的，只是分开之后业务代码的部分体积会小一些，而且 React 和 ReactDOM 这类的库可以直接从 CDN 取得。这个地方目前据我所知有三种主流的方法：<\\/p>\n<p>一个是修改 webpack.config.js 中的 vendor 和使用 CommonsChunkPlugin 来分离 vendor 和 bundle，可以参考：<\\/p>\n<ul>\n<li><a href=\"http:\\/\\/blog.csdn.net\\/tyro_java\\/article\\/details\\/54755610；\" target=\"_blank\" rel=\"external\">http:\\/\\/blog.csdn.net\\/tyro_java\\/article\\/details\\/54755610；<\\/a><\\/li>\n<li><a href=\"https:\\/\\/webpack.github.io\\/docs\\/code-splitting.html#multiple-entry-chunks\" target=\"_blank\" rel=\"external\">https:\\/\\/webpack.github.io\\/docs\\/code-splitting.html#multiple-entry-chunks<\\/a><\\/li>\n<\\/ul>\n<p>二是通过 webpack.config.js 中的 external 把模块的对象暴露到 window 中去，个人不是很推荐这种方法，虽然很方便，但不太好维护什么的；<\\/p>\n<p>三是用 webpack 的 DLL 方式来分离：<\\/p>\n<ul>\n<li><a href=\"http:\\/\\/www.jianshu.com\\/p\\/a5b3c2284bb6。\" target=\"_blank\" rel=\"external\">http:\\/\\/www.jianshu.com\\/p\\/a5b3c2284bb6。<\\/a><\\/li>\n<\\/ul>\n<h2 id=\"去掉不必要的东西和使用-uglifyJS-压缩\"><a href=\"#去掉不必要的东西和使用-uglifyJS-压缩\" class=\"headerlink\" title=\"去掉不必要的东西和使用 uglifyJS 压缩\"><\\/a>去掉不必要的东西和使用 uglifyJS 压缩<\\/h2><p>诸如 react-hot-loader 和 redux-devtools 一类的东西生产环境是不需要的，所以在 dist 的时候就不要打包进去了。<\\/p>\n<p>以及很重要也很有效的一个方法就是用 uglifyJS 插件压缩 JS 代码，webpack 中自带了 UglifyJsPlugin，只需要修改一下 webpack config 中的 plugin 就可以了：<\\/p>\n<pre><code class=\"javascript\">new webpack.optimize.UglifyJsPlugin({\n  compress: {\n    warnings: false,\n    comments: false\n  }\n})\n<\\/code><\\/pre>\n<h2 id=\"把代码分割成小块-Code-Split\"><a href=\"#把代码分割成小块-Code-Split\" class=\"headerlink\" title=\"把代码分割成小块 (Code Split)\"><\\/a>把代码分割成小块 (Code Split)<\\/h2><p>Code Split 的应用场景是当很多时候用户加载一个页面的时候只需要部分的内容，而却要下载所有的页面，因为它们被 webpack 一起打包在 bundle 当中了。解决方法就是把代码分块，然后按需加载。此方案支持 CommonJS 和 AMD, 但是暂时不支持 ES6 module. 这个方案可能对那些纠结 SPA 体积过大的开发者们很有帮助：<\\/p>\n<p><a href=\"https:\\/\\/webpack.github.io\\/docs\\/code-splitting.html\" target=\"_blank\" rel=\"external\">https:\\/\\/webpack.github.io\\/docs\\/code-splitting.html<\\/a><\\/p>\n<h2 id=\"从服务器端着手优化\"><a href=\"#从服务器端着手优化\" class=\"headerlink\" title=\"从服务器端着手优化\"><\\/a>从服务器端着手优化<\\/h2><p>从服务器端下手也是在正式发布生产环境之前一个很重要的环节——例如，开启 gzip 压缩的话能让 bundle 的体积缩小不少。以及不要忘记还有一个屡试不爽的方案——服务端渲染（SSR）。这两个方案的要求比较高也很好用，但是有些场景下并不适用<s>例如你没有服务器的控制权<\\/s>。<\\/p>\n<h1 id=\"直接从-React-上下手\"><a href=\"#直接从-React-上下手\" class=\"headerlink\" title=\"直接从 React 上下手\"><\\/a>直接从 React 上下手<\\/h1><p>在我完成一个 React 项目的过程中也因为体积太大而捣鼓了好久，上面的这些方法也或多或少试过，鉴于应用场景的特殊性和广泛性有些上文提到的有效的方法都无法实践在这个项目中。一个小小的东西打包出来有 360K+ 的大小。考虑到其中 React + ReactDOM + redux 就占了将近一半（170K 左右）的空间，所以能否从 React 上下手来减少 bundle 的体积？<\\/p>\n<p>答案是肯定的，但是这并不是要你去自己精简 React —— 为了一个小项目去做这样的事情实在是太费神了，<s>不如直接重构<\\/s>。好在，现在市面上也有一些 React 的精简版本，我们可以直接使用它们，有些轻量版的 React 甚至可以平滑过渡，<s>实在是我这种懒人的福音<\\/s>。<\\/p>\n<p>当前有很多对 React 进行抽象精简或者自行实现 Virtual DOM 和 JSX 的方案，例如 deku, react-lite, preact 等等。<\\/p>\n<h2 id=\"react-lite\"><a href=\"#react-lite\" class=\"headerlink\" title=\"react-lite\"><\\/a>react-lite<\\/h2><p>这里之所以不介绍 deku 是因为虽然 deku 有一些诸如 VDOM 的关键理念，但是如果你想从 React 转到 deku 相当于重构。<\\/p>\n<p>react-lite 是一个 react 的轻量实现。日常用到的 React API 几乎都可以在 react-lite 中跑起来。与原有的 react 相比<br>，react-lite 保留了 react 的大量特性，例如 VDOM，JSX，等等；当然也丢了一些某些场景下用不到的东西，如果你不想要服务端渲染的话可以考虑使用 react-lite。<\\/p>\n<blockquote>\n<p>React-lite supports the core APIs of React, such as Virtual DOM, intended as a drop-in replacement for React, when you don’t need server-side rendering in browser(no ReactDOM.renderToString &amp; ReactDOM.renderToStaticMarkup).<\\/p>\n<\\/blockquote>\n<p>react-lite 也是我现在正在使用的代替 react 的方案，从某种意义上讲，react-lite 在某些方面（例如渲染等）的性能优于 react. 除了能有效地缩小 bundle 的体积（170K+ -&gt; 30K）以及配置方便以外，它最吸引人的地方还在于：<\\/p>\n<h3 id=\"它能和-react-router-redux-完美兼容！\"><a href=\"#它能和-react-router-redux-完美兼容！\" class=\"headerlink\" title=\"它能和 react-router \\/ redux 完美兼容！\"><\\/a>它能和 react-router \\/ redux 完美兼容！<\\/h3><h3 id=\"它能和-react-router-redux-完美兼容！-1\"><a href=\"#它能和-react-router-redux-完美兼容！-1\" class=\"headerlink\" title=\"它能和 react-router \\/ redux 完美兼容！\"><\\/a>它能和 react-router \\/ redux 完美兼容！<\\/h3><h3 id=\"它能和-react-router-redux-完美兼容！-2\"><a href=\"#它能和-react-router-redux-完美兼容！-2\" class=\"headerlink\" title=\"它能和 react-router \\/ redux 完美兼容！\"><\\/a>它能和 react-router \\/ redux 完美兼容！<\\/h3><p>简直太棒了有没有！！这意味着用 react-router + redux 构建的 react 项目几乎就可以直接平滑地过渡到 react-lite 上！！而且对于 react 的一些 unittest, react-lite 都能跑过。<\\/p>\n<p>从 react 过渡到 react-lite 也十分容易，在大部分情况下两者是可以兼容的，直接为 webpack 配置一个 alias，把对 react 的引用指向 react-lite 即可：<\\/p>\n<pre><code class=\"javascript\">\\/\\/ webpack.config.js\n{\n    resolve: {\n        alias: {\n            &#39;react&#39;: &#39;react-lite&#39;,\n            &#39;react-dom&#39;: &#39;react-lite&#39;\n        }\n    }\n}\n<\\/code><\\/pre>\n<p><a href=\"https:\\/\\/github.com\\/Lucifier129\\/react-lite\" target=\"_blank\" rel=\"external\">https:\\/\\/github.com\\/Lucifier129\\/react-lite<\\/a><\\/p>\n<h2 id=\"preact\"><a href=\"#preact\" class=\"headerlink\" title=\"preact\"><\\/a>preact<\\/h2><p>react-lite 能把 150K+ 的 react &amp; react-dom 弄到 25K 左右，接下来介绍的 preact 号称是“3KB 的 react”，而且与 react 有相似的 API：<\\/p>\n<blockquote>\n<p>Fast 3kB alternative to React, with the same ES2015 API.<\\/p>\n<p>All the power of Virtual DOM components, without the overhead:<\\/p>\n<ul>\n<li>Familiar React API &amp; patterns: ES6 Class and Functional Components<\\/li>\n<li>Extensive React compatibility via a simple preact-compat alias<\\/li>\n<li>Everything you need: JSX, VDOM, React DevTools, HMR, SSR..<\\/li>\n<li>A highly optimized diff algorithm and seamless Server Side Rendering<\\/li>\n<li>Transparent asynchronous rendering with a pluggable scheduler<\\/li>\n<\\/ul>\n<\\/blockquote>\n<p>和 react-lite 一样，它的渲染性能在某些场景下也能超过 react，毕竟没有了那么多奇奇怪怪的东西，性能飞起来也不足为奇嘛。<\\/p>\n<p>不过，体积小了 50 倍，相应地你也要付出一些代价。preact 不像 react-lite 那样可以平滑过渡，要修改组件的代码，自己配置 babel 对 JSX 的转译，很多东西也都需要替换成 preact 专用的东西，相对的讲不是那么方便，据说 react 的单元测试 preact 只能跑过一半。但是想到体积减小的大胜利，这点小小的工作就不值一提了。<\\/p>\n<p><a href=\"https:\\/\\/github.com\\/developit\\/preact\" target=\"_blank\" rel=\"external\">https:\\/\\/github.com\\/developit\\/preact<\\/a><\\/p>\n<h1 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"><\\/a>后记<\\/h1><p>通过上面的方案以及直接对 React 动刀子，项目的体积直接从原来的 360K 左右变到 170K 上下了，首屏渲染的速度也改善了很多。后续如果还有什么行之有效的优化方法再补充这篇文章吧。<\\/p>\n",
      "excerpt": "<p>用 webpack 打包 React App 可谓是 React 开发中的最佳实践，但是有个令人十分头疼的问题就是在堆上了一堆依赖之后，用 webpack 打包出来的东西体积非常非常非常大，加载和首屏渲染的时间就要非常非常非常久，用户体验自然也就非……很不好。有很多前辈已经研究了很多缩小 webpack 打包出的 React App 体积的办法，这里我想讲一下自己踩这个大坑的经历以及发现的一个可行的方案。<\\/p>",
      "slug": "reduce-react-webpack-app-volume-in-an-extreme-way",
      "published": true,
      "layout": "post",
      "path": "blog/post/reduce-react-webpack-app-volume-in-an-extreme-way/",
      "permalink": "https://kirainmoe.com/blog/post/reduce-react-webpack-app-volume-in-an-extreme-way/",
      "tags": [
        {
          "name": "react",
          "slug": "react",
          "path": "tags/react/",
          "permalink": "https://kirainmoe.com/tags/react/",
          "length": 3
        },
        {
          "name": "webpack",
          "slug": "webpack",
          "path": "tags/webpack/",
          "permalink": "https://kirainmoe.com/tags/webpack/",
          "length": 3
        },
        {
          "name": "volume",
          "slug": "volume",
          "path": "tags/volume/",
          "permalink": "https://kirainmoe.com/tags/volume/",
          "length": 1
        },
        {
          "name": "react-lite",
          "slug": "react-lite",
          "path": "tags/react-lite/",
          "permalink": "https://kirainmoe.com/tags/react-lite/",
          "length": 1
        },
        {
          "name": "preact",
          "slug": "preact",
          "path": "tags/preact/",
          "permalink": "https://kirainmoe.com/tags/preact/",
          "length": 1
        }
      ],
      "categories": []
    },
    {
      "title": "导出 Typecho 的数据到 Canvas：typecho-to-canvas",
      "date": "2017-04-09T08:28:10.000Z",
      "modified": "2018-01-07T05:15:25.777Z",
      "content": "<p>通过简单几步，将 Typecho 博客程序的数据（文章，标签一类）轻松转换到由 Laravel 驱动的 Canvas 博客平台。<br><a id=\"more\"><\\/a><br>有关 <a href=\"canvas.toddaustin.io\">Canvas<\\/a> 什么的我就不说了吧，大概知道这是个比较新的 PHP 博客程序，由 Laravel 框架驱动就可以了。<\\/p>\n<p>至于为什么为突发奇想写这样一个东西，首先主要是这是个比较新鲜的东西，相关的东西都还很少，我在 GitHub 上找到了 <em>wordpress-to-canvas<\\/em> 的东西，于是便觉得为何不搞一个 <em>typecho-to-canvas<\\/em> 呢～其次呢，因为我之前用过一段时间的 Typecho，也想借这个东西把之前的一些数据导回来（虽然我找不到我把 DB 的 备份扔到哪了……qwq），以及……其他的一些原因……所以就花了一些时间造这个轮子啦。<\\/p>\n<p>GitHub: <a href=\"https:\\/\\/github.com\\/kirainmoe\\/typecho-to-canvas\" target=\"_blank\" rel=\"external\">typecho-to-canvas: easily converting your data from Typecho to Canvas<\\/a><\\/p>\n<p>Packagist(Composer): <a href=\"https:\\/\\/packagist.org\\/packages\\/kirainmoe\\/typecho-to-canvas\" target=\"_blank\" rel=\"external\">typecho-to-canvas<\\/a><\\/p>\n<h2 id=\"功能特色\"><a href=\"#功能特色\" class=\"headerlink\" title=\"# 功能特色\"><\\/a># 功能特色<\\/h2><ul>\n<li>Typecho 下的第一个 “Switch to Canvas” 工具<\\/li>\n<li>支持转换 Typecho 的文章、标签和关系树，兼容性约 95%<\\/li>\n<li>自动加载和解析配置数据，你甚至可以全程 Enter<\\/li>\n<li>在 CLI 模式下运行<\\/li>\n<li><s>作者这么萌<\\/s><\\/li>\n<\\/ul>\n<h2 id=\"环境需求\"><a href=\"#环境需求\" class=\"headerlink\" title=\"# 环境需求\"><\\/a># 环境需求<\\/h2><ul>\n<li>确保 Typecho 和 Canvas 在转换环境下分别已正确安装<\\/li>\n<li>拥有转换环境的操作权限<\\/li>\n<li>PHP 5.6.4 以上的版本（Canvas 的版本要求）<\\/li>\n<li>已正确安装 composer 依赖管理工具<\\/li>\n<li>PHP 已加载对应 Typecho 和 Canvas 安装类型的数据库的 PDO 拓展<\\/li>\n<li>数据库正常运行<s>（废话）<\\/s><\\/li>\n<li>耐心，Patient<\\/li>\n<\\/ul>\n<h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"# 使用方法\"><\\/a># 使用方法<\\/h2><h4 id=\"数据无价，在进行以下操作之前，强烈建议手动备份-Typecho-和-Canvas-的数据库。\"><a href=\"#数据无价，在进行以下操作之前，强烈建议手动备份-Typecho-和-Canvas-的数据库。\" class=\"headerlink\" title=\"数据无价，在进行以下操作之前，强烈建议手动备份 Typecho 和 Canvas 的数据库。\"><\\/a>数据无价，在进行以下操作之前，强烈建议手动备份 Typecho 和 Canvas 的数据库。<\\/h4><h4 id=\"数据无价，在进行以下操作之前，强烈建议手动备份-Typecho-和-Canvas-的数据库。-1\"><a href=\"#数据无价，在进行以下操作之前，强烈建议手动备份-Typecho-和-Canvas-的数据库。-1\" class=\"headerlink\" title=\"数据无价，在进行以下操作之前，强烈建议手动备份 Typecho 和 Canvas 的数据库。\"><\\/a>数据无价，在进行以下操作之前，强烈建议手动备份 Typecho 和 Canvas 的数据库。<\\/h4><h4 id=\"数据无价，在进行以下操作之前，强烈建议手动备份-Typecho-和-Canvas-的数据库。-2\"><a href=\"#数据无价，在进行以下操作之前，强烈建议手动备份-Typecho-和-Canvas-的数据库。-2\" class=\"headerlink\" title=\"数据无价，在进行以下操作之前，强烈建议手动备份 Typecho 和 Canvas 的数据库。\"><\\/a>数据无价，在进行以下操作之前，强烈建议手动备份 Typecho 和 Canvas 的数据库。<\\/h4><p>重要的事情说三遍。<br>再次确保你的环境工作正常，Typecho 和 Canvas 的数据库可以访问～然后接着往下看吧～<\\/p>\n<h4 id=\"准备：安装-te2cn\"><a href=\"#准备：安装-te2cn\" class=\"headerlink\" title=\"准备：安装 te2cn\"><\\/a>准备：安装 te2cn<\\/h4><p>安装教程可以在 GitHub 的 README 找到：<a href=\"https:\\/\\/github.com\\/kirainmoe\\/typecho-to-canvas\" target=\"_blank\" rel=\"external\">https:\\/\\/github.com\\/kirainmoe\\/typecho-to-canvas<\\/a><\\/p>\n<p>这里提供通过 Git 的安装方法，简单快捷～如果你没有安装 Git，请自行搜索当前系统的安装方式。<\\/p>\n<pre><code class=\"shell\"># 首先将项目仓库拉下来\n$ git clone https:\\/\\/github.com\\/kirainmoe\\/typecho-to-canvas\n$ cd typecho-to-canvas\n\n# 然后用 composer 安装依赖\n$ composer install\n\n# 运行 te2cn，按照提示转换数据就行啦\n$ chmod -R 755 .\\/te2cn\n$ .\\/te2cn\n<\\/code><\\/pre>\n<hr>\n<h4 id=\"填写数据库配置信息\"><a href=\"#填写数据库配置信息\" class=\"headerlink\" title=\"填写数据库配置信息\"><\\/a>填写数据库配置信息<\\/h4><p>运行程序首先是一贯的套路 welcome，然后 <strong>te2cn<\\/strong> 会先后向你询问 <em>Typecho<\\/em> 和 <em>Canvas<\\/em> 的数据库配置信息。首先会询问 Typecho 的数据库配置信息，请按顺序依次输入：数据库主机、用户、密码、数据库名称、端口、以及数据库的种类。程序会给出默认值，如果你不需要修改默认值，可以直接敲回车。<br>（小技巧：直接将 Typecho 的配置文件 <strong>config.inc.php<\\/strong> 复制到程序目录下，<strong>te2cn<\\/strong> 会自动解析数据库配置，无需人工填写）<\\/p>\n<p>接下来会询问 Canvas 数据库的配置信息。首先会问你 Canvas 和 Typecho 是否安装在同一数据库主机中，如果是的话直接回车，程序会问你 Canvas 安装的数据库名称；如果不是的话，会收集 Canvas 安装数据库的配置。<br>（目前暂时不支持解析 Laravel .ENV 的说 qwq）<\\/p>\n<p>接下来会列出所收集或解析的数据库的配置信息，请检查是否有误，如果无误可以直接敲回车。<\\/p>\n<h4 id=\"开始转换进程\"><a href=\"#开始转换进程\" class=\"headerlink\" title=\"开始转换进程\"><\\/a>开始转换进程<\\/h4><p>如果信息填写正确，程序就会自动开始数据导出进程。不过在这之前会先询问你是否保留 Canvas 的现有数据，如果你需要保留直接回车，不保留的话需要确认两次，以防误操作丢失数据。<\\/p>\n<p>然后，程序就会自动启动转换进程。取决于 Typecho 数据量的大小以及服务器 IO 性能，这个过程可能需要一些时间，请耐心等待，在依次导出了 tags, posts, relationships 之后，就完成了操作。<\\/p>\n<h4 id=\"Enjoy～\"><a href=\"#Enjoy～\" class=\"headerlink\" title=\"Enjoy～\"><\\/a>Enjoy～<\\/h4><p>当看到转换完成的提示之后，Typecho 的数据就成功地被导出到 Canvas 了。你可以试一试运行 Canvas 看看效果：<\\/p>\n<pre><code class=\"shell\">$ cd \\/path\\/to\\/your\\/canvas\n$ php artisan serve\n<\\/code><\\/pre>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"# 问题解决\"><\\/a># 问题解决<\\/h2><p>目前由于 Canvas 暂时不支持本地评论以及其他一些 Typecho 的 features，所以只做了文章、标签和关系树的单向转换。如果有时间会更新逆向转换功能（canvas-to-typecho）。<\\/p>\n<p>有任何问题或者建议，都可以到 GitHub 的项目主页提 issues 或者 Pull request 告诉我们。<\\/p>\n<p>嘛。希望这个轮子能对你们有帮助～<\\/p>\n",
      "excerpt": "<p>通过简单几步，将 Typecho 博客程序的数据（文章，标签一类）轻松转换到由 Laravel 驱动的 Canvas 博客平台。<br>",
      "slug": "export-data-of-typecho-to-canvas",
      "published": true,
      "layout": "post",
      "path": "blog/post/export-data-of-typecho-to-canvas/",
      "permalink": "https://kirainmoe.com/blog/post/export-data-of-typecho-to-canvas/",
      "tags": [],
      "categories": []
    },
    {
      "title": "LeetCode Praticing Record",
      "date": "2017-03-01T09:38:39.000Z",
      "modified": "2018-01-07T05:18:29.347Z",
      "content": "<p>_(:з」∠)_ 因为实在是太久没有写文章但是又找不到有什么东西好写的，正好最近被某 Tyanboot 带入了 <a href=\"https:\\/\\/leetcode.com\" target=\"_blank\" rel=\"external\">LeetCode<\\/a> 刷题的坑，所以想了想，索性就开了这个帖子记录一下在 LeetCode 的刷题历程好了。因为不想用一题一篇文章的记录方式，所以就直接扔在一整篇博文里。因为时间比较少（被续掉的（不是））<s>所以大概就是 1~2 周做一题、更一题的样子。当然遇到更难的题目另外说……<\\/s><\\/p>\n<a id=\"more\"><\\/a>\n<p><s>（题外：西方的 LeetCode 比什么 *gu 一类的 Online Judge 不知道高到哪里去了！）<\\/s><\\/p>\n<h1 id=\"目录-Content\"><a href=\"#目录-Content\" class=\"headerlink\" title=\"目录 (Content)\"><\\/a>目录 (Content)<\\/h1><p>[Problem 1] Two sum 简单的两数求和（斜眼笑）<br>[Problem 2] Add Two Numbers 真 · 两数求和<br>[Problem 3] Longest Substring Without Repeating Characters 找到一串字符串最长不重复的子串<\\/p>\n<h2 id=\"Problem-1-Two-sum\"><a href=\"#Problem-1-Two-sum\" class=\"headerlink\" title=\"[Problem 1] Two sum\"><\\/a>[Problem 1] Two sum<\\/h2><p>一开始看难度 Easy，以为又是普通 OJ 的那种 A+B 问题，点进去一看才发现……我毕竟还是图样图森破啊。<br>呐。问题的大意就是给你一个不定长的整数数组 nums，里面的数不会重复；再给你一个目标数 target，然后让你求出数组中的哪两个数加起来等于目标数。<br>（喂，这和我们说好的水题不一样啊！）<br>其实还是可以的啦，题目给的标签是哈希表，那就照着这个方向写吧。这里哈希表用STL 的 map 来建好了，也是很方便的（问题是写这题之前还没试过用 map 呢 orz）<br>代码 Gist 地址：<a href=\"https:\\/\\/gist.github.com\\/kirainmoe\\/919ee87b7653ada8689fbe2384503bd5#file-two_sum-cpp\" target=\"_blank\" rel=\"external\">https:\\/\\/gist.github.com\\/kirainmoe\\/919ee87b7653ada8689fbe2384503bd5#file-two_sum-cpp<\\/a><br>做题的时候参考的：<br>《C++ 中的 STL 中 map 用法详解》：<a href=\"http:\\/\\/blog.sina.com.cn\\/s\\/blog_a9303fd9010195hm.html\" target=\"_blank\" rel=\"external\">http:\\/\\/blog.sina.com.cn\\/s\\/blog_a9303fd9010195hm.html<\\/a><\\/p>\n<hr>\n<h2 id=\"Problem-2-Add-Two-Numbers\"><a href=\"#Problem-2-Add-Two-Numbers\" class=\"headerlink\" title=\"[Problem 2] Add Two Numbers\"><\\/a>[Problem 2] Add Two Numbers<\\/h2><p>稍有常识的人就能看出，<s>如果我们的铁骑继续前进<\\/s> 这道题目就是一个高精度加法运算的链表实现形式：<br>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>Output: 7 -&gt; 0 -&gt; 8<br>把高精度的模板套过来使之与链表相适即可。但是受 Top solution 的一个题解的启发，原来代码可以写得更简洁，如下，代码不长不扔 Gist 了。<\\/p>\n<pre><code class=\"cpp\">\\/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n *\\/\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode a = ListNode(0), *ans = &amp;a;\n        int remain = 0;         \\/\\/ 剩余\n    \\/\\/ l1, l2 都为空之后，切记要处理最后剩余的\n    while (l1 != NULL || l2 != NULL || remain != 0)\n        {\n            int cur = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + remain;\n            remain = cur \\/ 10;\n            ans-&gt;next = new ListNode(cur % 10);\n            ans = ans-&gt;next;\n\n            \\/\\/ 下一位，记得判断一下 l1, l2 的 next 是否为 NULL\n            l1 = l1 ? l1-&gt;next : l1;\n            l2 = l2 ? l2-&gt;next : l2;\n        }\n\n        return a.next;\n    }\n};\n<\\/code><\\/pre>\n<p>就是这样的喵。<\\/p>\n<hr>\n<h2 id=\"Problem-3-Longest-Substring-Without-Repeating-Characters\"><a href=\"#Problem-3-Longest-Substring-Without-Repeating-Characters\" class=\"headerlink\" title=\"[Problem 3] Longest Substring Without Repeating Characters\"><\\/a>[Problem 3] Longest Substring Without Repeating Characters<\\/h2><p>其实做这道题目距离今天已经有一段日子了……也是我 LeetCode 的入坑题。难度是 Medium ，但是我觉得这个比上一题简单的说。<\\/p>\n<p>题目大意是给你一个字符串，找出最长的不重复子串，然后返回这个不重复子串的长度。比如说：<\\/p>\n<pre><code>Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.\n<\\/code><\\/pre><p>刚看到这道题目的时候，想到以前好像做过类似的题目可以用 DP 来求解，仔细想想发现不需要用动态规划，并且可以把时间复杂度控制在 O(n)。具体的做法如下：<\\/p>\n<blockquote>\n<p>首先维护一个长度为 96 的数组 pos，因为这里题目给出来的字符串不只包括大小写字母，还包括特殊符号（喂，不带不给数据范围的啊），但是都在 ASCII 能表示的范围内，用这个数组作为 Flag。用 memset() 把这个数组赋上初值 -1。定义一个叫 ans 和 cur 的整形变量，分别用来存储最终答案和当前搜到的最长不重复子串的长度，初值都让他们为 0。最后我们还需要一个作为指针作用的变量 flag = s.length().<\\/p>\n<p>接下来就是求解。将这个字符串从后往前搜（length-1→0），定义一个叫做 tmp 的变量保存当前遍历到的字符的 ASCII 码与 32 的差（s[i]-32，这里与 32 做差的原因是我们上文只定义了 96 的数组长度）。接着对 pos[tmp] 做判断：<br>如果 pos[tmp] == -1，说明到目前为止还没有遇到过这个字母，那么令 cur += 1，接着判断 cur 和 ans 的关系，如果 cur &gt; ans，就用 cur 的值替换 ans 的值。<\\/p>\n<p>如果 pos[tmp] != -1，说明在之前已经遇到了这个字母，而现在又遇到了，这个时候需要判断 pos[tmp] 和 flag 的大小关系。<\\/p>\n<p>== 如果 pos[tmp] &gt; flag，这个时候说明 flag 在当前搜到的字符(tmp) 上一次出现之后已经更新过了，那么这时候我们就令 cur = flag-i（这个时候，从 i 到 flag 的字符共同组成从 s[i] 开始往下能取到的最长不重复子串），然后比较 ans 和 cur，更新 ans 的值。<\\/p>\n<p>==  如果 pos[tmp] &lt; flag，那么更新 flag 的值，让 flag = pos[tmp]（这么做的原因是因为如果 pos[tmp] 在 flag 之前，那么从 i 开始能取到的最长不重复子串就会变成 i 到 pos[tmp]-1之间的所有字符）。这个时候就可以令 cur = flag-i 了。由于这个时候得到的新值必定比 ans 小，所以就不需要做比较了。<\\/p>\n<p>做完这一切还有最后一件事，就是更新当前字母出现的位置啦。别忘记在循环体最后加上 pos[tmp] = i 更新一下位置。最后就大胆地 return ans; 吧。<\\/p>\n<\\/blockquote>\n<p>代码 Gist 地址：<a href=\"https:\\/\\/gist.github.com\\/kirainmoe\\/a39a65e73efc95012bb7be84d32337c7\" target=\"_blank\" rel=\"external\">https:\\/\\/gist.github.com\\/kirainmoe\\/a39a65e73efc95012bb7be84d32337c7<\\/a><br>由于理想情况下复杂度是 O(n) ，所以实测最快可以在 LeetCode 跑到 9ms 左右（这个成绩是超过 99.57% 的提交）<\\/p>\n",
      "excerpt": "<p>_(:з」∠)_ 因为实在是太久没有写文章但是又找不到有什么东西好写的，正好最近被某 Tyanboot 带入了 <a href=\"https:\\/\\/leetcode.com\">LeetCode<\\/a> 刷题的坑，所以想了想，索性就开了这个帖子记录一下在 LeetCode 的刷题历程好了。因为不想用一题一篇文章的记录方式，所以就直接扔在一整篇博文里。因为时间比较少（被续掉的（不是））<s>所以大概就是 1~2 周做一题、更一题的样子。当然遇到更难的题目另外说……<\\/s><\\/p>",
      "slug": "leetcode-praticing-record",
      "published": true,
      "layout": "post",
      "path": "blog/post/leetcode-praticing-record/",
      "permalink": "https://kirainmoe.com/blog/post/leetcode-praticing-record/",
      "tags": [
        {
          "name": "algorithm",
          "slug": "algorithm",
          "path": "tags/algorithm/",
          "permalink": "https://kirainmoe.com/tags/algorithm/",
          "length": 8
        },
        {
          "name": "leetcode",
          "slug": "leetcode",
          "path": "tags/leetcode/",
          "permalink": "https://kirainmoe.com/tags/leetcode/",
          "length": 1
        },
        {
          "name": "cpp",
          "slug": "cpp",
          "path": "tags/cpp/",
          "permalink": "https://kirainmoe.com/tags/cpp/",
          "length": 1
        }
      ],
      "categories": []
    },
    {
      "title": "只读属性引起的 state 不随 setState 的触发而变化",
      "date": "2017-02-19T09:32:16.000Z",
      "modified": "2018-01-07T05:18:38.461Z",
      "content": "<p>这个是写某项目过程当中偶然遇到的，具体需求是随着数据的变化，实时改变一个 <code>&lt;input&gt;<\\/code> 输入框的 value。因为用 React.js，自然很快就想到利用 React 组件的 state 特性就可以很方便的做到了。然而由此却引发了一些问题，就是我发现用 <code>this.state.val<\\/code> 赋值，用 <code>this.setState()<\\/code> 改变组件状态的时候，更新并没有实时展现出来（其实是根本没有展示出来），输入框里的内容并没有实时更新。<\\/p>\n<a id=\"more\"><\\/a>\n<p>我们知道通过调用 React 组件的 <code>setState()<\\/code> 方法改变组件的状态会触发组件重新渲染，则用 <code>this.state<\\/code> 调用的 state 也会改变。所以说，输入框的值没有实时更新，很可能是因为组件根本没有重新渲染。一开始以为是回调的问题，于是使用 <code>setState()<\\/code> 的第二个参数处理接下来的业务逻辑，可是发现并不是。最后发现，问题出现在对 input 的 value 属性的设置上。<\\/p>\n<p>考虑下面的这一段代码：<\\/p>\n<pre><code class=\"javascript\">class App extends React.Component {\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      val: &#39;&#39;\n    };\n    setTimeout(() =&gt; {\n      this.setState({\n        val: &#39;world!&#39;\n      });\n    }, 1000);\n  }\n\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;span&gt;Hello&lt;\\/span&gt;\n        &lt;input type=&#39;text&#39; defaultValue={this.state.val} \\/&gt;\n      &lt;\\/div&gt;\n    );\n  }\n\n}\n<\\/code><\\/pre>\n<p>如果正常，将 <code>&lt;App \\/&gt;<\\/code> 渲染到页面上，你可以看到 Hello 。然后稍等 1s，你可以看到 Hello 。<\\/p>\n<blockquote>\n<p><s>这就是你说的正常显示？我读书少你别骗我！”<\\/s><\\/p>\n<\\/blockquote>\n<p>的确，如果单单读这段代码，一般人都应该能猜出想象中的结果——文本框最开始为空，但是一秒后它的值会变为 world。可是这里却并没有实现。文档并没有写错，<code>this.setState()<\\/code> 过后会引起状态的变更，虽然是异步的但是迟早会做这一步的啊。为什么在这里无效呢。<\\/p>\n<p>问题的关键在于，我们为输入框赋值的时候用的属性是 <code>defaultValue<\\/code>。这是一个只读属性。<\\/p>\n<blockquote>\n<p><s>“切，这就是你的锅了，好好的 value 属性不用，用个 poi 的 defaultValue！”<\\/s><\\/p>\n<\\/blockquote>\n<p>可是假如你把 defaultValue 改成 value，那么请你打开 console，那里已经有一条红色的警告消息等着你了。不信的话大家不妨试试：<\\/p>\n<p><code>Warning: Failed form propType: You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`. Check the render method of `Hello`.<\\/code><\\/p>\n<p>React 要求我们设置这个 input 为只读，或者为这个 input 设置一个 onChange 事件，如果都不的话就用 defaultValue 代替 value。很多人为了省事就听了它的话用了 defaultValue（包括我），于是就踩进了坑。下面我们试着改一下上面那个组件的 render 方法好不好啊？吼啊！（（（<\\/p>\n<pre><code class=\"javascript\">return (\n  &lt;div&gt;\n    &lt;span&gt;Hello&lt;\\/span&gt;\n    &lt;input \n          type=&#39;text&#39;\n          value={this.state.val}\n          onChange={() =&gt; false} \\/&gt;\n  &lt;\\/div&gt;\n);\n<\\/code><\\/pre>\n<p>把 defaultValue 改成 value 并且绑定一个 onChange 事件。再次刷新页面你会发现出现了我们预期中的结果。至此我们可以大声讲出这个问题就是有这个只读的属性 defaultValue 引起的了。<\\/p>\n",
      "excerpt": "<p>这个是写某项目过程当中偶然遇到的，具体需求是随着数据的变化，实时改变一个 <code>&lt;input&gt;<\\/code> 输入框的 value。因为用 React.js，自然很快就想到利用 React 组件的 state 特性就可以很方便的做到了。然而由此却引发了一些问题，就是我发现用 <code>this.state.val<\\/code> 赋值，用 <code>this.setState()<\\/code> 改变组件状态的时候，更新并没有实时展现出来（其实是根本没有展示出来），输入框里的内容并没有实时更新。<\\/p>",
      "slug": "state-does-not-chage-by-setState-due-to-the-readonly-props",
      "published": true,
      "layout": "post",
      "path": "blog/post/state-does-not-chage-by-setState-due-to-the-readonly-props/",
      "permalink": "https://kirainmoe.com/blog/post/state-does-not-chage-by-setState-due-to-the-readonly-props/",
      "tags": [],
      "categories": []
    },
    {
      "title": "修改 React-Native Android App 包名",
      "date": "2017-02-17T09:31:03.000Z",
      "modified": "2018-01-07T05:26:58.048Z",
      "content": "<p>不知道是为什么（大概是依赖太多？），每次执行 react-native init 创建新项目的时候，总是要等个将近 10 分钟的样子…… 对于初学者来说，需要在短时间内创建好多好多好多的项目，这样每次 init 就要浪费好长的时间。用 verbose 模式一看，其实 react-native init 的过程中大部分时间是在安装 node_modules 文件夹里的依赖，那么如果每次要创建新项目的时候保留 node_modules 文件夹，只是复制一份纯净的 android, ios, index.android.js 和 index.ios.js 会省很多的时间。<br>不过众所周知的是即使这样做的话，如果不做改动的话，这些新项目的 package name 都是相同的，在同一台设备中只能存在一个唯一包名的 App。搜索了一下 React Native 改包名 一类的关键词，找到了一些结果，好像很有道理的样子，照做之后兴高采烈地 react-native run-android 的时候……各种编译出错。于是就在这个基础上，自己踩了一些坑，最后总结出了修改包名的完整过程。<\\/p>\n<a id=\"more\"><\\/a>\n<p>我们知道，例如我们执行 react-native init AwesomeProject 的时候，创建的 App 包名默认是 com.AwesomeProject 。<\\/p>\n<ol>\n<li>首先最容易找到的是 package.json 当中的 name 字段，修改它（其实后来发现修不修改都没有什么关系，因为并没有什么卵用）。<\\/li>\n<li>然后是 android\\/app 目录下的 build.gradle，这个是 gradle 执行 build 的 config 文件，里面大概 90 行左右，在 defaultConfig 块中有一个 applicationId “com.AwesomeProject”， 修改它。<\\/li>\n<li>修改 android\\/src\\/main 目录下的 AndroidManifest.xml ，第 2 行就是了，找到 package=“com.AwesomeProject”，修改之。<\\/li>\n<li>接着就是 android\\/src\\/main\\/java 目录下的东西了。首先这个文件夹中你可以看到 .\\/com\\/AwesomeProject 目录，我们先把这个目录下的两个文件移动走，然后放到对应你想要修改的包名的目录。例如这里，我想修改包名为 com.kirainmoe.helloworld，我们就在 android\\/src\\/main\\/java 目录下创建这样的层级目录：.\\/com\\/kirainmoe\\/helloworld\\/ ，然后将两个文件 MainActivity.java 和 MainApplication.java 移动过去。<br>然后修改 MainActivity.java &amp; MainApplication.java 第一行中的 package com.AwesomeProject; 改掉，改成你想要的包名，记住一定要和前面的对应。<\\/li>\n<\\/ol>\n<p>（百度出来的回答到这里结束，然而……）<\\/p>\n<p>好了，做到这里之后就尝试了一下 react-native run-android，结果在构建 debug app 的时候，到 :app:compileDebugJavaWithJavac 这一步就报错了：<\\/p>\n<pre><code class=\"bash\">\\/path\\/to\\/MainApplication.java:20: 错误: 找不到符号 \n return BuildConfig.DEBUG; \n ^ \n 符号: 变量 BuildConfig \n1 个错误 \n FAILED \nFAILURE: Build failed with an exception. \n\n* What went wrong: \nExecution failed for task ‘:app:compileDebugJavaWithJavac’. \n&gt; Compilation failed; see the compiler error output for details. \n\n* Try: \nRun with — stacktrace option to get the stack trace. Run with — info or — debug option\n to get more log output. \n\nBUILD FAILED \n\nTotal time: 1 mins 5.339 secs \nCould not install the app on the device, read the error above for details. \nMake sure you have an Android emulator running or a device connected and have \nset up your Android development environment: \nhttps:\\/\\/facebook.github.io\\/react-native\\/docs\\/android-setup.html\n<\\/code><\\/pre>\n<p>orz，看看错误信息应该是出在 MainApplication.java 上，这里的内容是：<\\/p>\n<pre><code class=\"java\">return BuildConfig.DEBUG;\n<\\/code><\\/pre>\n<p>搜索一下这个错误信息，好像确实有遇到的人，但是这里提出的解决方案是针对 Android Studio 下的……不过其中一句话启发了我：<\\/p>\n<blockquote>\n<p>BuildConfig类是在编译时自动生成的，分为debug和release两个版本，路径是：<br>app\\/build\\/source\\/BuildConfig\\/Build Varients\\/package name\\/BuildConfig<br>修改包名后，原来使用到BuildConfig类的类，import语句会出错，<br>把import语句的包名改为修改后的包名或者删除这条import语句（让系统自动补充import语句），调试时提示找不到BuildConfig类<br><strong>import 修改后的包名.BuildConfig;<\\/strong><\\/p>\n<\\/blockquote>\n<p>最后一句话中提到可以通过 import packageName.BuildConfig; 引入，那么我们也可以带上包名来 return 以解决找不到 BuildConfig 的问题，把刚才的语句修改为：<\\/p>\n<pre><code class=\"java\">return your.package.name.BuildConfig.DEBUG;\n<\\/code><\\/pre>\n<p>例如，我可以改成：<\\/p>\n<pre><code class=\"java\">return com.kirinmoe.helloworld.BuildConfig.DEBUG;\n<\\/code><\\/pre>\n<p>好了，到此为止，再次执行 react-native run-android ，问题就不再出现了。<\\/p>\n<blockquote>\n<p>Update at 9\\/14: 貌似也可以在这个文件里加一句 import your.package.name;，这样也能解决找不到 BuildConfig 的问题。<\\/p>\n<\\/blockquote>\n",
      "excerpt": "<p>不知道是为什么（大概是依赖太多？），每次执行 react-native init 创建新项目的时候，总是要等个将近 10 分钟的样子…… 对于初学者来说，需要在短时间内创建好多好多好多的项目，这样每次 init 就要浪费好长的时间。用 verbose 模式一看，其实 react-native init 的过程中大部分时间是在安装 node_modules 文件夹里的依赖，那么如果每次要创建新项目的时候保留 node_modules 文件夹，只是复制一份纯净的 android, ios, index.android.js 和 index.ios.js 会省很多的时间。<br>不过众所周知的是即使这样做的话，如果不做改动的话，这些新项目的 package name 都是相同的，在同一台设备中只能存在一个唯一包名的 App。搜索了一下 React Native 改包名 一类的关键词，找到了一些结果，好像很有道理的样子，照做之后兴高采烈地 react-native run-android 的时候……各种编译出错。于是就在这个基础上，自己踩了一些坑，最后总结出了修改包名的完整过程。<\\/p>",
      "slug": "change-the-package-name-of-react-native-app",
      "published": true,
      "layout": "post",
      "path": "blog/post/change-the-package-name-of-react-native-app/",
      "permalink": "https://kirainmoe.com/blog/post/change-the-package-name-of-react-native-app/",
      "tags": [],
      "categories": []
    },
    {
      "title": "初探全新的 Node.js 包管理器 Yarn",
      "date": "2016-10-12T09:33:58.000Z",
      "modified": "2018-01-07T05:18:26.943Z",
      "content": "<blockquote>\n<p><strong>FAST, RELIABLE, AND SECURE DEPENDENCY MANAGEMENT.<\\/strong><\\/p>\n<\\/blockquote>\n<p>就在昨天，<strong><em>Facebook<\\/em><\\/strong> 发布了新的 <strong><em>node.js<\\/em> <\\/strong>包管理器 <a href=\"https:\\/\\/yarnpkg.com\\/\" target=\"_blank\" rel=\"external\"><strong><em>Yarn<\\/em><\\/strong><\\/a> 用以替代 <strong><em>npm<\\/em><\\/strong>。咱虽然是个半桶水的咸鱼前端，不过也得跟上<strong> <em>Javascript<\\/em> <\\/strong>这股潮<strong><em>(hong)<\\/em><\\/strong>流<strong><em>(huang)<\\/em><\\/strong> 的脚步，所以便有了下面这篇文章。大概的浅尝了一下这个自称是又快又可信赖又安全的包管理，所以写的内容不会很详细，更多的可能只是针对这个全新的包管理与 <strong><em>npm<\\/em><\\/strong> 的不同之处来对比。也可能有些地方写得不对，如果有的话，欢(lai)迎(da)指(wo)正(a)。<\\/p>\n<a id=\"more\"><\\/a>\n<p><img src=\"https:\\/\\/cdn-images-1.medium.com\\/max\\/800\\/0*fOeA4Ko_Z2f8vFAd.png\" alt=\"\"><\\/p>\n<h3 id=\"Installation\"><a href=\"#Installation\" class=\"headerlink\" title=\"Installation\"><\\/a>Installation<\\/h3><p>首先当然是安装啦。跟 <strong><em>npm<\\/em> <\\/strong>这种被钦点而随<strong> <em>nodejs<\\/em> <\\/strong>一起被安装的包管理器不同，<strong><em>Yarn<\\/em><\\/strong> 需要自行手动安装。这也可以理解吧，毕竟是全新的东西。不过老实说，安装体验是不太好的……吧。<\\/p>\n<p>为什么怎么说呢……因为我的开发环境是 <strong><em>Arch Linux<\\/em><\\/strong>，而官方文档只提供了<strong> <em>apt-get<\\/em> <\\/strong>系<strong> <em>Linux<\\/em> <\\/strong>和 <strong><em>yum<\\/em><\\/strong> 系<strong> <em>Linux<\\/em> <\\/strong>的安装方式……<\\/p>\n<p>既然志在取代 <strong><em>npm<\\/em><\\/strong>，那么肯定有全平台的兼容方案咯，果然有适用于所有发行版的手动安装脚本，于是我就尝试这个，可是装了三次没有一次成功，各种问题……<\\/p>\n<p>最后发现，其实 <strong><em>yarn<\\/em><\\/strong> 可以直接像装模块那样用 <strong><em>npm<\\/em><\\/strong> 装：<\\/p>\n<pre name=\"80b3\" id=\"80b3\" class=\"graf graf--pre graf-after--p\">npm install -g yarn<\\/pre>\n\n<p>啊嘞？一个要取代<strong> <em>npm<\\/em> <\\/strong>的东西，居然还要用 <strong><em>npm<\\/em><\\/strong> 来装？<strong><em>excuse me<\\/em><\\/strong>？好吧，不管怎么讲总之是这样装上了，所以我说安装体验一般般……也许可能对其他的发行版来说会好一些吧，可能对于一些大众的发行版和<strong> <em>macOS<\\/em> <\\/strong>来说，安装就是一条命令打进终端的事情。<\\/p>\n<p>虽然截止到我写这篇文章的时候，已经有了<strong> <em>Arch Linux<\\/em> <\\/strong>上的安装方式，不过是通过 <strong><em>yaourt(AUR)<\\/em><\\/strong> 的方式，我并不觉得对于新手来说手动装一下 <strong><em>yaourt<\\/em><\\/strong> 再装 <strong><em>yarn<\\/em><\\/strong> 比直接用 <strong><em>pacman<\\/em> <\\/strong>装 <strong><em>nodejs<\\/em> <\\/strong>然后 <strong><em>npm install<\\/em><\\/strong> 简单。也许在现阶段，相比什么 <strong><em>Debian\\/Ubuntu\\/CentOS<\\/em><\\/strong> 来说 <strong><em>Arch<\\/em><\\/strong> 还是个小众的发行版吧……<\\/p>\n<h3 id=\"Dependencies-Management\"><a href=\"#Dependencies-Management\" class=\"headerlink\" title=\"Dependencies Management\"><\\/a>Dependencies Management<\\/h3><p>安装部分就这样告一段落。既然作为一个包管理，就要做好自己的职责。接下来就想要试试这个新包管理是否真的有它所宣传的那样神奇。接下来我在同样的环境下，将<strong> <em>yarn<\\/em> <\\/strong>和 <strong><em>npm<\\/em><\\/strong> 以及<strong> <em>cnpm<\\/em> <\\/strong>做对比。<\\/p>\n<h4 id=\"FASTER\"><a href=\"#FASTER\" class=\"headerlink\" title=\"FASTER\"><\\/a>FASTER<\\/h4><blockquote>\n<p>updated at 2016.10.14 13:10<\\/p>\n<\\/blockquote>\n<p><strong><em>Yarn<\\/em><\\/strong> 和 <strong><em>npm<\\/em><\\/strong> 的包仓库是同步的，所以 <strong><em>npm 的 registry 同样对 yarn 适用。<\\/em><\\/strong>执行以下命令就可以把 <strong><em>yarn<\\/em><\\/strong> 的源设置为 <strong><em>taobao<\\/em><\\/strong> 的 <strong><em>npm registry<\\/em><\\/strong>。但是我发现改了之后并没有加快 <strong><em>yarn<\\/em><\\/strong> 的速度多少，所以以下 <strong><em>yarn<\\/em><\\/strong> 使用的依旧是默认源。<\\/p>\n<pre name=\"1583\" id=\"1583\" class=\"graf graf--pre graf-after--p\">yarn config set registry **_https:\\/\\/registry.npm.taobao.org_**<\\/pre>\n\n<p><strong><em>Yarn<\\/em><\\/strong> 既然是 <strong><em>Facebook<\\/em><\\/strong> 家的东西，那我们就首先试一下安装他家的 <strong><em>React<\\/em><\\/strong> 好了：<\\/p>\n<p><img src=\"https:\\/\\/cdn-images-1.medium.com\\/max\\/600\\/1*t3JKasHT_Tg4MP2nh8WCWg.png\" alt=\"\"><\\/p>\n<p>首先当然是主角 <strong><em>yarn<\\/em><\\/strong> 啦。需要注意的是 <strong><em>yarn<\\/em><\\/strong> 安装依赖的方式不同于 <strong><em>npm<\\/em><\\/strong>，你需要执行以下命令来安装依赖：<\\/p>\n<pre name=\"b5e2\" id=\"b5e2\" class=\"graf graf--pre graf-after--p\">yarn add react<\\/pre>\n\n<p>可以看到 <strong><em>yarn<\\/em><\\/strong> 安装<strong> <em>React<\\/em> <\\/strong>用了<strong> <em>13.3s<\\/em><\\/strong>，这速度也着实令人满意。<\\/p>\n<p><img src=\"https:\\/\\/cdn-images-1.medium.com\\/max\\/600\\/1*uRYA4dr0CBNu_-ZAFR01dA.png\" alt=\"\"><\\/p>\n<p>接下来是 <strong><em>npm<\\/em><\\/strong>。因为<strong> <em>npm<\\/em> <\\/strong>并不显示命令时间，所以我掐了一下秒表，大概 <strong><em>45s<\\/em><\\/strong> 的样子，是 <strong><em>yarn<\\/em><\\/strong> 的好几倍多。好像比起<strong> <em>npm<\\/em> <\\/strong>来说，<strong> <em>yarn<\\/em><\\/strong> 的速度确实快了一些呢，而且<strong> <em>npm<\\/em> <\\/strong>用的还是国内的源。<\\/p>\n<p>不过<strong> <em>cnpm<\\/em> <\\/strong>的速度就更快了，只用了<strong> <em>4s<\\/em><\\/strong> 便完成了整个安装过程。但是毕竟 <strong><em>cnpm<\\/em><\\/strong> 是 <strong><em>npm<\\/em><\\/strong> 的衍生产物，处于情理之中。既然这东西可以改善 <strong><em>npm<\\/em><\\/strong> 的速度，谁知道以后会不会有<strong> <em>cyarn<\\/em> <\\/strong>呢？但是通过这个测试我们可以看出，<strong><em>yarn<\\/em> <\\/strong>的速度相比原生 <strong><em>npm<\\/em> <\\/strong>着实是一个质的飞跃，FASTER 并不是浪得虚名。<\\/p>\n<p>接下来我又尝试了安装其他的包，多次对比了一下，<strong><em>平均下来 yarn 会比 npm 快上 3–6 倍（这是安装体积小一些的包的情况）。<\\/em><\\/strong><\\/p>\n<h4 id=\"RELIABLE-SECURE\"><a href=\"#RELIABLE-SECURE\" class=\"headerlink\" title=\"RELIABLE\\/SECURE\"><\\/a>RELIABLE\\/SECURE<\\/h4><p>至于这个包管理是否 <strong><em>reliable\\/secure<\\/em><\\/strong>，这个我暂时没想到怎么测试。我只知道在我用的时候，偶尔有几率会报一些莫名其妙的错误，但是反复执行两遍命令，就又正常工作了。毕竟 <strong><em>yarn<\\/em> <\\/strong>是新出的东西嘛，可以理解。不过就在这一天之内，yarn 的 GitHub 项目主页已经赢得了 9K star，issues 和 pull request 也有了上千个，可见其火热的程度，所以对于它的前景，我还是很看好的。<\\/p>\n<h3 id=\"Offline-mode\"><a href=\"#Offline-mode\" class=\"headerlink\" title=\"Offline mode\"><\\/a>Offline mode<\\/h3><p><span class=\"graf-dropCap\">Y<\\/span><strong><em>arn<\\/em><\\/strong> 的一个亮点就是可以离线安装依赖，当然，前提是曾经安装过这个依赖。<strong><em>Yarn<\\/em><\\/strong> 会缓存安装过的包，下次安装的时候如果指定了 <strong><em>-offline<\\/em><\\/strong> 参数，<strong><em>Yarn<\\/em><\\/strong> 就会直接从缓存中取出这个包，这样将大大缩短安装依赖的时间。<\\/p>\n<p>遗憾的是，尽管官方文档我看了一遍又一遍，这个功能还是无法正常在我的环境上工作。我会找一下原因，这一段稍后补充。<\\/p>\n<p>但是这个<strong> <em>feature<\\/em><\\/strong> 真的是让人眼前一亮，可以说解决了<strong> <em>npm<\\/em> <\\/strong>的一个短板，很致命的短板。有了这样的功能之后，以后在没有网络的环境下也能够安装已有的依赖的。而且省去了下载的时间，大大提高了效率。想象一下以后执行 <strong><em>react-native init<\\/em><\\/strong> 的时候不用漫长等待 15 分钟了，是不是很开心（当然，什么时候<strong> <em>Facebook<\\/em> <\\/strong>把<strong> <em>react-native init<\\/em> <\\/strong>的安装依赖过程换成自家的包管理安装还是未知数喔）。<\\/p>\n<h3 id=\"yarn-lock-文件\"><a href=\"#yarn-lock-文件\" class=\"headerlink\" title=\"yarn.lock 文件\"><\\/a>yarn.lock 文件<\\/h3><p><span class=\"graf-dropCap\">Y<\\/span><strong><em>arn<\\/em><\\/strong> 通过一个 <strong><em>yarn.lock<\\/em><\\/strong> 文件，来使得你的程序得以在不同的机器上获得一致的体验。虽然这个解释很牵强，好歹我没有机翻给大家看，已经很良心了（雾）。感觉这好像是个很高端的东西，其实主要是对 <strong><em>package.json<\\/em> <\\/strong>的一个补充。<\\/p>\n<p>有兴趣的话，可以看这里的详细介绍（需要英文好一些哟）：<\\/p>\n<p><a href=\"https:\\/\\/yarnpkg.com\\/en\\/docs\\/yarn-lock\" title=\"https:\\/\\/yarnpkg.com\\/en\\/docs\\/yarn-lock\" target=\"_blank\" rel=\"external\"><strong>Yarn<\\/strong><br>_Fast, reliable, and secure dependency management._yarnpkg.com<\\/a><\\/p>\n<h3 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"><\\/a>Summary<\\/h3><p>忽如一夜春风来，千树万树梨花开。有时候就是眼睛一睁一闭之间，一个新的东西就这样在你全然不知的时候悄然面世了。今天出了 yarn，明天指不定又会出现什么。庆幸的是，我们还能赶上这个新玩意的早班车。<\\/p>\n<p>记得近几日的一篇高端黑文（大雾），描述了在 2016 年学习 Javascript 这门语言的感受（看这里：<a href=\"https:\\/\\/hackernoon.com\\/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f#.mkiou6jtq\" target=\"_blank\" rel=\"external\"><strong><em>How it feels to learn Javascript in 2016<\\/em><\\/strong><\\/a>），确实，这门语言单单一年的发展，就足以呛死不少人。<\\/p>\n<p>但是必须要说<strong> <em>yarn<\\/em> <\\/strong>的出现确实是有进步意义的，他解决了 <strong><em>npm<\\/em><\\/strong> 已知的一些问题，拓展出了新的特性。既然如此，它就是值得去接触和学习的。尽管距离取代 <strong><em>npm<\\/em><\\/strong> 还有好长的一段时间，走好长的一段路，但是可以预见它的前途将是一片的光明。<\\/p>\n<p>所以，来吧，你需要尝试一些新的东西。 <strong><em>yarn<\\/em><\\/strong> 未来的成长，将由我们共同见证。<\\/p>\n",
      "excerpt": "<blockquote>\n<p><strong>FAST, RELIABLE, AND SECURE DEPENDENCY MANAGEMENT.<\\/strong><\\/p>\n<\\/blockquote>\n<p>就在昨天，<strong><em>Facebook<\\/em><\\/strong> 发布了新的 <strong><em>node.js<\\/em> <\\/strong>包管理器 <a href=\"https:\\/\\/yarnpkg.com\\/\"><strong><em>Yarn<\\/em><\\/strong><\\/a> 用以替代 <strong><em>npm<\\/em><\\/strong>。咱虽然是个半桶水的咸鱼前端，不过也得跟上<strong> <em>Javascript<\\/em> <\\/strong>这股潮<strong><em>(hong)<\\/em><\\/strong>流<strong><em>(huang)<\\/em><\\/strong> 的脚步，所以便有了下面这篇文章。大概的浅尝了一下这个自称是又快又可信赖又安全的包管理，所以写的内容不会很详细，更多的可能只是针对这个全新的包管理与 <strong><em>npm<\\/em><\\/strong> 的不同之处来对比。也可能有些地方写得不对，如果有的话，欢(lai)迎(da)指(wo)正(a)。<\\/p>",
      "slug": "first-taste-of-nodejs-package-manager-yarn",
      "published": true,
      "layout": "post",
      "path": "blog/post/first-taste-of-nodejs-package-manager-yarn/",
      "permalink": "https://kirainmoe.com/blog/post/first-taste-of-nodejs-package-manager-yarn/",
      "tags": [
        {
          "name": "nodejs",
          "slug": "nodejs",
          "path": "tags/nodejs/",
          "permalink": "https://kirainmoe.com/tags/nodejs/",
          "length": 1
        },
        {
          "name": "yarn",
          "slug": "yarn",
          "path": "tags/yarn/",
          "permalink": "https://kirainmoe.com/tags/yarn/",
          "length": 1
        },
        {
          "name": "npm",
          "slug": "npm",
          "path": "tags/npm/",
          "permalink": "https://kirainmoe.com/tags/npm/",
          "length": 1
        }
      ],
      "categories": [],
      "illust": "https://cdn-images-1.medium.com/max/800/0*fOeA4Ko_Z2f8vFAd.png"
    }
  ],
  "menu": {
    "Home": "/",
    "Guestbook": "/pages/guestbook/",
    "Friends": "/pages/friends/",
    "About": "https://about.me/kirainmoe"
  },
  "socials": {
    "twitter": "https://twitter.com/yume_kankawa",
    "github": "https://github.com/kirainmoe",
    "weibo": "https://weibo.com/returnnnn",
    "medium": "https://medium.com/@kotori",
    "lastfm": "https://www.last.fm/user/kirainmoe"
  },
  "avatar": "https://secure.gravatar.com/avatar/c47187d311099868de825697fa419654?s=200&r=G",
  "menuIcon": {
    "Home": "home",
    "Guestbook": "book",
    "Friends": "users",
    "Archives": "tags",
    "About": "id-card-o"
  },
  "disqus": "yume-diary",
  "prev": 2,
  "next": 0
}</script>
  <!-- hook node of React -->
  <div id="himawari-app"></div>

  
    <!-- scripts list from theme config.yml -->
    
      <script src="https://unpkg.com/muse-player/dist/assets/muse-player.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/prism.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-clike.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-php.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-css.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-c.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-cpp.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-javascript.min.js"></script>
    
      <script src="/common.js"></script>
    
      <script src="/main.js"></script>
    
  

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-111347233-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-111347233-1');
  </script>

</body>
</html>
