<!-- Himawari no Yakusoku -->

<!DOCTYPE html>
<html lang="Zh-cn">
<head>
  <meta charset="UTF-8">
  <meta name="theme-color" content="#FF98A8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>6 年間、共に歩んでくれたあなたへ。 [ YumeのDiary ]</title>
  <meta name="description" content="6 年間、共に歩んでくれたあなたへ。">
  <link rel="manifest" href="/manifest.json">
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    
      <link rel="stylesheet" href="/himawari.css">
    
  
</head>
<body>
  
  <!-- infos -->
  <script type="text/json" id="himawari-json">{
  "title": "YumeのDiary",
  "siteTitle": "YumeのDiary",
  "description": "6 年間、共に歩んでくれたあなたへ。",
  "author": "Yume Kankawa",
  "route": "index",
  "format": "blog/:layout/:title/",
  "posts": [
    {
      "title": "记自己的第一次差点翻车的出题经历",
      "date": "2017-10-29T13:01:52.000Z",
      "modified": "2018-01-07T05:18:30.966Z",
      "content": "<p>复赛在即，我们学校里面的四个撒币不知道是谁突发奇想，说要出一套模拟题。于是我们四个人分别出了一道要多恶心有多恶心的题= =本来嘛是要在学校内部自己测的，不过人太少，不好玩，于是就连夜 py 到洛谷上搞了公开赛。从早上 8 点到中午 12 点，虽然出了很多的锅，不过还是要记录一下我的第一次出题经历（<\\/p>\n<a id=\"more\"><\\/a>\n<p><div id=\"muse-app\"><\\/div><\\/p>\n<script type=\"text\\/javascript\">\nvar playList = [\n  {\n    \"title\": \"未来の僕らは知ってるよ\",\n    \"artist\": \"Aqours\",\n    \"cover\": \"http:\\/\\/p1.music.126.net\\/03tA9ZYD51gTLxlEuY3_vw==\\/109951163049447102.jpg\",\n    \"src\": \"https:\\/\\/api.kotori.love\\/netease\\/514543403.mp3\",\n    \"lyric\": \"[00:00.00] 作曲 : 光増ハジメ\\n[00:00.17] 作词 : 畑亜贵\\n[00:00.51](千歌)本気を ぶつけあって\\n[00:06.15]手に入れよう (全员)未来を\\n[00:14.63]\\n[00:20.23]味方なんだ 空も この海も\\n[00:25.75]さあ頑張るんだと 輝いてるよ\\n[00:30.73]遠くへ 遠くへ 声が届くように\\n[00:36.34]もっと大きくユメを叫ぼうか\\n[00:41.22](2年生)(希望でいっぱいの)\\n[00:43.20](3年生)今日が明日を引き寄せるんだと\\n[00:47.33](1年生)ハートの磁石を握って走る\\n[00:51.81](全员)今は 楽しいんだ それが\\n[00:55.92]「ずっと一緒に行こう！」\\n[00:57.92]\\n[00:58.15]未来をどうしようかな\\n[01:01.02]みんな夢のカタチを探して\\n[01:06.53]泣いたり 笑ったり\\n[01:08.74]未来の僕たちは きっと答えを持ってる\\n[01:15.11]はずだから 本気で駆け抜けて\\n[01:23.33]\\n[01:30.19](梨子)歌いながら 雨に濡れながら\\n[01:36.11](曜)絶対晴れると信じてるんだよ\\n[01:40.96](花丸)元気な (露比)元気な\\n[01:43.40](花丸)声で (花露)呼んでみよう\\n[01:46.69](善子)きっと大きな\\n[01:48.70](夜羽)夢に会えるはずさ\\n[01:52.10](果南)進化したいから すぐできないこと\\n[01:56.30](黛雅)ひとつ ひとつ 乗り越えて\\n[02:01.74](鞠莉)雲の間に間に新しい青空が\\n[02:07.20]待ってるよ (全员)待ってるよ\\n[02:11.94]\\n[02:12.36](全员)期待で弾け飛ぼう\\n[02:15.60]こんな勢いのままで\\n[02:18.73]行きたいよ\\n[02:20.71]泣いても 笑っても\\n[02:22.95]期待が僕たちへたくさん合図くれるから\\n[02:29.40]逃がさないで チャンスを捕まえて\\n[02:36.68]\\n[02:45.10]I live I live lovelive days！！\\n[02:48.47]\\n[02:52.69]本気をぶつけたら\\n[02:57.26]叶うんじゃないかな ユメ\\n[03:04.00]\\n[03:05.51](千歌)未来をどうしようかな\\n[03:08.21]みんなユメのカタチを ah (ah～)\\n[03:13.77]探してるんだ みんなで\\n[03:15.61]\\n[03:15.97](全员)期待で弾け飛ぼう\\n[03:18.85]こんな勢いのままで 行きたいよ\\n[03:24.41]泣いても 笑っても\\n[03:26.64]未来の僕たちは きっと答えを持ってる\\n[03:33.18]はずだから 本気で駆け抜けて\\n[03:40.28]チャンスを捕まえて\\n[03:48.10]光る風になろう\\n[03:51.10]We got dream!\\n\",\n    \"translation\": \"[00:00.51]让我们触碰彼此真心\\n[00:06.15]将未来紧握手中\\n[00:14.63]\\n[00:20.23]碧海蓝天 与我们同在\\n[00:25.75]来吧 高喊加油 闪耀起来哟\\n[00:30.73]为了让声音传向更远更远\\n[00:36.34]更加放声呼喊梦想吧\\n[00:41.22]（希望已充盈四周）\\n[00:43.20]今日之行引导着明日之景\\n[00:47.33]紧握心型磁石向前奔跑\\n[00:51.81]如今这样就让人非常欢乐\\n[00:55.92] “一直携手同行吧”\\n[00:57.92]\\n[00:58.15]究竟要怎样对待未来呢\\n[01:01.02]大家一路捕捉梦想的形状\\n[01:06.53]时而落泪 时而欢笑\\n[01:08.74]未来的我们一定早已知晓答案\\n[01:15.11]所以更应全心全意勇往直前\\n[01:23.33]\\n[01:30.19]在风雨中坚持歌唱\\n[01:36.11]因为相信着一定会放晴\\n[01:40.96]试着用元气满满的\\n[01:43.40]声音来呼喊吧\\n[01:46.69]这样定能相遇\\n[01:48.70]壮阔的梦想\\n[01:52.10]因为想要蜕变 所以要将尚且力所不及的事情\\n[01:56.30]一件一件把它们战胜\\n[02:01.74]波涛云海间的崭新蓝天\\n[02:07.20]正等待着 等待着我们呢\\n[02:11.94]\\n[02:12.36]满怀期待尽情绽放\\n[02:15.60]希望就着这个劲头\\n[02:18.73]一直勇往直前\\n[02:20.71]即使一路有笑有泪\\n[02:22.95]期待会向我们发来许多指引的信号\\n[02:29.40]所以不要逃避了 快把握住每个机遇\\n[02:36.68]\\n[02:45.10]\\n[02:48.47]\\n[02:52.69]跟随自我本心而努力\\n[02:57.26]是不是就能让梦想实现呢\\n[03:04.00]\\n[03:05.51]究竟要怎样对待未来呢\\n[03:08.21]那些梦想的轮廓\\n[03:13.77]就让大家一起来寻找吧\\n[03:15.61]\\n[03:15.97]满怀期待尽情绽放\\n[03:18.85]希望照着这个劲头一直勇往直前\\n[03:24.41]即使一路有笑有泪\\n[03:26.64]未来的我们一定早已知晓答案\\n[03:33.18]所以更应全心全意勇往直前\\n[03:40.28]把握住每个机遇\\n[03:48.10]化作闪耀的风儿\\n[03:51.10]\"\n  }\n];\nwindow.MUSE.render(playList, document.getElementById('muse-app'));\n<\\/script>\n\n<h1 id=\"感受\"><a href=\"#感受\" class=\"headerlink\" title=\"感受\"><\\/a>感受<\\/h1><p>各位有兴趣看题目的话地址在这里：<br><a href=\"https:\\/\\/www.luogu.org\\/contest\\/show?tid=4291\" target=\"_blank\" rel=\"external\">https:\\/\\/www.luogu.org\\/contest\\/show?tid=4291<\\/a><br><a href=\"https:\\/\\/www.luogu.org\\/problemnew\\/show\\/U14667\" target=\"_blank\" rel=\"external\">https:\\/\\/www.luogu.org\\/problemnew\\/show\\/U14667<\\/a><\\/p>\n<p>安排给我的出题难度是压轴（也就是最难的那一题），不过被我活生生出成了水题= =……出了一道状压 DP 的模板题（大概），然后呢并没有人帮我验题（事实上他们三个人互相 A 不掉对方的题目总共前前后后调到比赛都开始了还在出锅）……<\\/p>\n<p>于是因此发生了一件很尴尬的事情，就是造数据的时候呢，因为 std 出了锅少写了一个等于号，然后造出了一堆错误的数据，把正解卡到了 30 分= =比赛完了之后写题解才发现，卧槽标程都出锅了，然后更新数据、重传数据，联系了 luogu 的管理员帮我们重测，然后还一个一个给可能写了正解的参赛者发私信道歉+让他们请求重新提交……<\\/p>\n<p>提交了 80 多个人有将近 90% 是输出 No Answer 骗分的233333早知道不设这个点了（<\\/p>\n<p>最后重新提交完有两个写出了正解的 julao，一个写了接近正解但是差一点的 dalao……嘛，看起来这题出得还是挺水的（不过话说回来，比同校人出的那些题良心多了2333<\\/p>\n<hr>\n<p>接下来是题目：<\\/p>\n<h1 id=\"肝活动-event-pas-c-cpp\"><a href=\"#肝活动-event-pas-c-cpp\" class=\"headerlink\" title=\"肝活动 (event.pas\\/.c\\/.cpp)\"><\\/a>肝活动 (event.pas\\/.c\\/.cpp)<\\/h1><p>时间限制：1s \\/ 空间限制：512MB \\/ 测试点数目：20<\\/p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"><\\/a>题目描述<\\/h2><p>Yume 最近在玩一个名为《LoveLive! School idol festival》的音乐游戏。他之所以喜欢上这个游戏，是因为这个游戏对非洲人十分友好，即便你脸黑到抽不出好卡，还可以通过在每个月举办的两次活动中达成一定的目标来获得奖励。<br>Yume 很喜欢这一期活动奖励卡的卡面，于是他决定要肝这一期的活动，拿到活动奖励。这一期的活动规则很特殊，玩家需要在活动规定的结束时间前，完成所有指定的歌曲<strong>（每首歌只能打一次）<\\/strong>，并获得一定的分数，就可以拿到活动奖励。如果在规定的时间前没有完成所有的歌曲，或者分数不够奖励的分数线，则不能领取活动奖励。每首歌有一个限定的奖励开放时间，玩家如果在这段时间内完成了这首歌，便可以获得一定的分数<strong>（获得的分数 = 开放时间 - 当前已用的总时间）<\\/strong>。如果超出了这段时间之后再完成这首歌，就不能获得分数了。<br>这样的规则对 Yume 这样的老玩家来说本应是轻而易举，但不巧的是 Yume 把活动的结束时间记成了活动的开始时间，以至于当他上线跃跃欲试的时候，惊恐地发现活动已经快要结束了。现在他想知道，在剩余的时间之内，他能否完成所有的歌、达成奖励的分数线拿到活动卡。为了节省时间，他把这个问题交给了你来解决。请你根据给定的数据，帮他计算出能否在剩余的时间内达成目标。如果能，请告诉他完成每首歌曲的顺序。<\\/p>\n<h2 id=\"输入数据\"><a href=\"#输入数据\" class=\"headerlink\" title=\"输入数据\"><\\/a>输入数据<\\/h2><p>从文件 event.in 读取输入数据。<br>输入的第一行是三个整数 n, m, t，分别表示规定完成的歌曲数目、获得奖励需要达到的最低分数和距离活动结束剩余的时间。<br>接下来有 n 行，第 i 行有一个字符串 Si 和两个整数 Ti 和 Mi，表示第 i 首歌的歌名为 Si，完成第 i 首歌所需要的时间为 Ti，第 i 首歌的奖励开放时间剩余 Mi。保证 Ti ≤ Mi. 其中数据已按 Si 的字典序给出。<\\/p>\n<h2 id=\"输出数据\"><a href=\"#输出数据\" class=\"headerlink\" title=\"输出数据\"><\\/a>输出数据<\\/h2><p>将答案输出到 event.out 中。<br>如果在活动结束前 Yume 可以完成指定的目标拿到奖励，则在第一行输出一个整数 C，表示在获得奖励的前提下，所能够获得的分数的最大值；接下来的 n 行中，按照完成歌曲的顺序输出第 i 首歌的歌名。如果有多种可能性，则输出字典序最小的情况。<br>如果在活动结束前 Yume 不能完成所有的歌曲，输出 No Answer .<\\/p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"><\\/a>输入样例<\\/h2><blockquote>\n<p>【样例1】<br>3 2 10<br>BokutachiwaHitotsunoHikari 3 8<br>Korekara 1 2<br>SnowHalation 2 5<\\/p>\n<p>【样例2】<br>2 1 2<br>AoizoraJumpingHeart 1 2<br>TimeLapse 2 4<\\/p>\n<\\/blockquote>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"><\\/a>输出样例<\\/h2><blockquote>\n<p>【样例1】<br>6<br>SnowHalation<br>BokutachiwaHitotsunoHikari<br>Korekara<\\/p>\n<p>【样例2】<br>No Answer<\\/p>\n<p>样例1说明：<br>首先打第三首歌，用时 2，获得分数为 (5-2)=3；<br>接着打第一首歌，用时 3，获得分数为 (8-2-3)=3；<br>最后打第二首歌，用时 1，由于打完第二首歌之后总用时为 6，但第二首歌的奖励获得时间为 2，因此不能获得分数。<br>总用时为 6 &lt; 10，分数为 6 &gt; 2，完成目标。<\\/p>\n<\\/blockquote>\n<h2 id=\"数据规模\"><a href=\"#数据规模\" class=\"headerlink\" title=\"数据规模\"><\\/a>数据规模<\\/h2><p>对于 0% 的数据，与测试数据完全相同。<br>对于 20% 的数据，满足 n ≤ 5。<br>对于 40% 的数据，满足 n ≤ 9。<br>对于 70% 的数据，满足 n ≤ 15。<br>对于 100% 的数据，满足 n ≤ 22，Si 的长度不超过 50. 保证 m, t 和 Ti, Mi 以及其相加的结果都在 int 的最大范围内。<br>另有 10% 的数据满足 Sigma(T1, T2, …, Tn) &lt; t.<\\/p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"><\\/a>题解<\\/h1><p>没错，这是一道状态压缩 DP（而且事实上是道水题吧，感觉对不起提高+\\/省选-的评级 Orz）。很多人没写出来大概是因为被这个比赛发起人瞎 YY 的评级吓到了……不太明白状态压缩 DP 原理的= =嘛，建议先去理解一下，出题人太懒，不想在题解里写状压 DP 的原理（逃<\\/p>\n<p>首先要读懂题目的意思，找出关键的信息，这个不多说。注意一下分数的计算方式和获得奖励的条件即可。<\\/p>\n<p>先考虑无解的情况，第一种情况是当 <code>Sigma(T1, T2, T3, ..., Tn) &lt; t<\\/code> 的时候，在剩余时间内无法完成所有的歌，很明显应该输出 <code>No Answer<\\/code>.<\\/p>\n<p>还有一种情况是即便在规定时间内打完了所有的歌，仍然达不到规定的分数 m 的时候，也是 <code>No Answer<\\/code>，这种情况我们只能找到最大值后才计算。可惜有一位离正解很近的 julao 忘记了这种情况被砍掉了 15 = =<\\/p>\n<p>再就是状态的设计。题目中规定要完成每首歌，并且每首歌都只能打一次，那么我们设 <code>dp[i]<\\/code> 表示<strong>当前已完成的歌曲编号的二进制状态为 i 的情况下，能取得的分数的最大值<\\/strong>。<\\/p>\n<p>那么转移方程就显然了：<code>dp[i] = max(dp[i], dp[i &amp; (~j)] + limit[j] - curTime[i])<\\/code>，其中 <code>j<\\/code> 是当前考虑的歌曲编号，那么 <code>i &amp; (~j)<\\/code> 就是打第 j 首歌之前的状态，<code>limit[j]<\\/code> 表示能获得奖励分数的规定时间，<code>curTime[i]<\\/code> 就是打完第 j 首歌之后的总用时。<\\/p>\n<p>我们可以看到完成的歌曲的二进制状态为 i 时所用的时间 <code>curTime[i]<\\/code> 与打歌的顺序无关，所以我们可以预处理计算出这个 <code>curTime<\\/code> 数组:<\\/p>\n<pre><code class=\"cpp\">for (int i = 0; i &lt; (1 &lt;&lt; 22); i++)\n{\n  for (int j = 0; j &lt; n; j++)\n  {\n    \\/\\/ 状态 i 已经包含了第 j 首歌\n    if (i &amp; j) {\n      continue;\n    }\n    curTime[i | j] = curTime[i] + cost[j];\n  }\n}\n<\\/code><\\/pre>\n<p>当然你也可以不做这一步，直接在 DP 的时候更新当前状态的时间也没有问题。<\\/p>\n<p>接下来我们就可以写出 DP 的主过程了。Wait, 在此之前，细心的各位想必已经注意到了题目中的一个需求，如果多种打歌顺序都可获得最大值的话，那么要输出字典序最小的方案。这个怎么解决呢？再细心看一下题目会发现每首歌在给出的时候已经强调按照字典序排好了，所以我们只需要把正序枚举 j from 1 to n 改成逆序枚举 j from n to 1，这样就可以保证在遇到字典序更小的最优解的时候替换掉当前解。<\\/p>\n<pre><code class=\"cpp\">    for (int i = 0; i &lt;= (1 &lt;&lt; n); i++)\n    {\n        for (int j = n; j &gt;= 0; j--)\n        {\n            int cur = 1 &lt;&lt; j;\n            if (i &amp; cur) {\n                int prev = i &amp; (~cur);\n                int getscore = rest[j] - curTime[prev] - cost[j];\n                if (getscore &lt; 0) {\n                    getscore = 0;     \\/\\/ 记得把不能得到分数的情况修改掉\n                }\n                \\/\\/ 注意这里的条件是 &lt;=，因为当得分相等的时候取字典序更小的更优\n                if (dp[i].score &lt;= dp[prev].score + getscore) {\n                    dp[i].score = dp[prev].score + getscore;\n                    dp[i].cur = j;\n                    dp[i].prev = prev;\n                }\n            }\n        }\n    }\n<\\/code><\\/pre>\n<p>最后我们顺着 <code>dp[(1 &lt;&lt; n) - 1]<\\/code> 的状态一路推回去输出方案。在此之前别忘了再判断一下 m 与 <code>dp[(1 &lt;&lt; n) - 1]<\\/code> 的大小关系。还有一个要注意的地方是输出顺序的问题，因为是从最后一个推回去的，但是应该从第一个输出到最后一个，所以这个时候做一个 DFS 或者丢进栈里就完美啦。<\\/p>\n<h1 id=\"附上蒟蒻的标程\"><a href=\"#附上蒟蒻的标程\" class=\"headerlink\" title=\"附上蒟蒻的标程\"><\\/a>附上蒟蒻的标程<\\/h1><pre><code class=\"cpp\">#include &lt;cstdio&gt; \n#include &lt;cstring&gt;\n#include &lt;stack&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nconst int MAXS = (1 &lt;&lt; 24);\nconst int MAXN = 25;\n\nstruct State {\n    int cur;\n    int prev;\n    int score;\n};\nState dp[MAXS + 20];\n\nint n, m, t;\nint sum;\nint cost[MAXN], rest[MAXN];\nint curTime[MAXS + 20];\nchar name[MAXN][110];\n\nint main()\n{\n    memset(curTime, 0, sizeof curTime);\n    memset(dp, 0, sizeof dp);\n\n    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t);\n    for (int i = 0; i &lt; n; i++)\n    {\n        scanf(&quot;%s%d%d&quot;, name[i], &amp;cost[i], &amp;rest[i]);\n        sum += cost[i];\n    }\n\n    if (t &lt; sum) {\n        printf(&quot;No Answer&quot;);\n        return 0;\n    }\n\n    for (int i = 0; i &lt; (1 &lt;&lt; n); i++)\n    {\n        for (int j = n; j &gt;= 0; j--)\n        {\n            if (i &amp; (1 &lt;&lt; j)) {\n                continue;\n            }\n            int next = i | (1 &lt;&lt; j);\n            curTime[next] = curTime[i] + cost[j];\n        }\n    }\n\n    for (int i = 0; i &lt;= (1 &lt;&lt; n); i++)\n    {\n        for (int j = n; j &gt;= 0; j--)\n        {\n            int cur = 1 &lt;&lt; j;\n            if (i &amp; cur) {\n                int prev = i &amp; (~cur);\n                int getscore = rest[j] - curTime[prev] - cost[j];\n                if (getscore &lt; 0) {\n                    getscore = 0;\n                }\n                if (dp[i].score &lt;= dp[prev].score + getscore) {\n                    dp[i].score = dp[prev].score + getscore;\n                    dp[i].cur = j;\n                    dp[i].prev = prev;\n                }\n            }\n        }\n    }\n\n    int state = (1 &lt;&lt; n) - 1;\n\n    if (dp[state].score &gt;= m) {\n        printf(&quot;%d\\n&quot;, dp[state].score);\n    } else {\n        printf(&quot;No Answer&quot;);\n        return 0;\n    }\n\n    stack&lt;int&gt; S;\n    while (state != 0)\n    {\n        S.push(dp[state].cur);\n        state = dp[state].prev;\n    }\n\n    while (!S.empty())\n    {\n        int id = S.top();\n        S.pop();\n        printf(&quot;%s&quot;, name[id]);\n        if (!S.empty()) {\n            printf(&quot;\\n&quot;);\n        }\n    }\n\n    return 0;\n}\n<\\/code><\\/pre>\n",
      "excerpt": "<p>复赛在即，我们学校里面的四个撒币不知道是谁突发奇想，说要出一套模拟题。于是我们四个人分别出了一道要多恶心有多恶心的题= =本来嘛是要在学校内部自己测的，不过人太少，不好玩，于是就连夜 py 到洛谷上搞了公开赛。从早上 8 点到中午 12 点，虽然出了很多的锅，不过还是要记录一下我的第一次出题经历（<\\/p>",
      "slug": "my-first-contest-problem",
      "published": true,
      "layout": "post",
      "path": "blog/post/my-first-contest-problem/",
      "permalink": "https://kirainmoe.com/blog/post/my-first-contest-problem/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "algorithm",
          "slug": "algorithm",
          "path": "tags/algorithm/",
          "permalink": "https://kirainmoe.com/tags/algorithm/",
          "length": 8
        }
      ],
      "categories": []
    },
    {
      "title": "浅谈 KMP 字符串匹配算法",
      "date": "2017-10-17T05:01:43.000Z",
      "modified": "2018-01-07T05:18:28.578Z",
      "content": "<p>因为上周末 MFE 群里有位成员提到了这个算法，所以那天晚上就稍微认识了一下这个算法，感觉 KMP 对于匹配字符串上的做法还是好神奇的，值得水篇文章整理一下。<\\/p>\n<a id=\"more\"><\\/a>\n<blockquote>\n<p>很久没有更文了w 最近真的是非常非常非常忙qwq，刚刚送走了第二次阶段考就迎来了 NOIP 的初赛，然后接下来的一整个月都要在忙碌的准备中度过，11 月回来又是期中考qwq 所以你们会发现我的解题报告停更了半个月，这篇文章权当是补偿吧（ <\\/p>\n<\\/blockquote>\n<h1 id=\"KMP-算法\"><a href=\"#KMP-算法\" class=\"headerlink\" title=\"KMP 算法\"><\\/a>KMP 算法<\\/h1><blockquote>\n<p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现，因此人们称它为克努特——莫里斯——普拉特操作（简称KMP算法）。KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个next()函数，函数本身包含了模式串的局部匹配信息。时间复杂度O(m+n)。<\\/p>\n<\\/blockquote>\n<p>以上摘自百科，这段话已经详尽地阐明了什么是 KMP 算法、它的应用场景和高效性的核心原因。下面就不再多做介绍了w。<\\/p>\n<h1 id=\"原始的字符串匹配方法\"><a href=\"#原始的字符串匹配方法\" class=\"headerlink\" title=\"原始的字符串匹配方法\"><\\/a>原始的字符串匹配方法<\\/h1><p>首先回忆一下，如果我们要匹配两个字符串，一般是怎么做的？我想大部分的人应该会想到这样的答案：<\\/p>\n<ul>\n<li>用两个下标指针 i, j 分别指向我们要匹配的目标字符串 (target) 和给我们的模式串 (pattern)。<\\/li>\n<li>从 i = 0 作为起点开始，如果 target[i] == pattern[j]，就一步一步向右移动 i, j 指针。<\\/li>\n<li>当 target[i] != pattern[j] 的时候，就让 i 的起点右移一位，让 j = 0.<\\/li>\n<li>重新开始尝试匹配，直到匹配成功（返回 target 与 pattern 匹配的起始为止）或者 i = target.length 时仍然没有结果为止（此时 target 与 pattern 不匹配，返回 -1）。<\\/li>\n<\\/ul>\n<p>当然，这样的方法确实是正确的说，但是我们还需要考虑<s>这个效率 efficiency<\\/s>。很明显这个方法的时间复杂度是 O(n*m) 的~ 要是数据量很大的话就可能会超时哟（<\\/p>\n<p>那么有没有什么好一点的方法来优化我们匹配两个字符串的方式呢？<\\/p>\n<h1 id=\"优化的思想\"><a href=\"#优化的思想\" class=\"headerlink\" title=\"优化的思想\"><\\/a>优化的思想<\\/h1><p>下文中，我们把目标串 target 记作 T, 模式串 pattern 记作 P. 首先，让我们考虑这样两个字符串：<\\/p>\n<pre><code>target (T): ABCABCABDAB\npattern(P): ABCABD\n<\\/code><\\/pre><p>我们用上面的方法匹配的时候，让 i = j = 0，然后当 T[i] == P[j] 的时候，我们不断让 i, j 右移，直到 i = j = 5 的时候，我们发现 T[i](C) != P[j](D) 了。<\\/p>\n<p>按照我们上面的思路，我们会把 i 和 j 回溯：<\\/p>\n<pre><code> ↓ i = 1\nABCABCABDAB\n ABCABD\n ↑ j = 0\n<\\/code><\\/pre><p>这时候第一个字符就不匹配了，所以 i 继续右移，直到 i = 3, j = 0 的时候往下匹配，最后 i = 8, j = 5 的时候匹配成功：<\\/p>\n<pre><code>   ↓ i = 3\nABCABCABDAB\n   ABCABD\n   ↑ j = 0\n\n......\n\n        ↓ i = 8\nABCABCABDAB\n   ABCABD\n        ↑ j = 5\n<\\/code><\\/pre><p>但是我们发现了一件有趣的事情，就是，如果这件事让我们人为来做的话，当 i, j 从 0 开始匹配到 5 失败的时候，我们不会让 i = 1, 2, … 这样一直试到匹配为止。<br>因为我们发现我们在 i = 5 的时候匹配失败，P[0] = A, 但是 i = 5 的前面只有 i = 3 的时候 T[i] = A，所以 i = 1, 2 的时候我们根本不需要去匹配。我们能这么想，是因为我们已经知道匹配过的 i = 0~5 的情况了——这也正是 KMP 算法的精髓所在，<strong>KMP 算法高效的原因之一正是由于它能够利用已经匹配到的有效信息。<\\/strong><\\/p>\n<p>所以呢，上面提到的三个人就想到了一个方案：i 指针可以不动呀，我们只要移动 j 指针就可以了。<\\/p>\n<pre><code>     ↓ i = 5\nABCABCABDAB\nABCABD\n     ↑ j = 5\n<\\/code><\\/pre><p>这个时候让 i 不动，只移动 j：<\\/p>\n<pre><code>     ↓ i = 5\nABCABCABDAB\n   ABCABD\n     ↑ j = 2\n<\\/code><\\/pre><p>哎，你会发现这样比一起移动 i 和 j 快多了，对吗？这就是 KMP 算法的思想：<\\/p>\n<blockquote>\n<p>利用已经部分匹配这个有效信息，保持 i 指针不回溯，通过修改 j 指针，让模式串尽量地移动到有效的位置。<\\/p>\n<\\/blockquote>\n<h1 id=\"KMP-算法的灵魂-——-j-指针移动的位置\"><a href=\"#KMP-算法的灵魂-——-j-指针移动的位置\" class=\"headerlink\" title=\"KMP 算法的灵魂 —— j 指针移动的位置\"><\\/a>KMP 算法的灵魂 —— j 指针移动的位置<\\/h1><p>但是有人会问，我们要怎么知道 j 指针移动到哪个地方才合适呢？因为 j 的下一个位置很关键，如果 j 的下一个位置太提前，那么这个想法无异于没有优化；如果太靠后，那么两个字符串就无法匹配了。所以 j 指针的下一个位置是很重要的。KMP 算法中，用一个叫 <strong>next 数组<\\/strong> 的东西来记录 j 指针的下一个位置。<\\/p>\n<p>next 数组也是 KMP 的难点所在。如果你觉得 next 数组的求解很难理解，这里有几篇文章可以辅助你理解；下面我也会理一下从这几篇文章里整理出来的比较容易理解的东西：<\\/p>\n<blockquote>\n<p><a href=\"http:\\/\\/www.cnblogs.com\\/yjiyjige\\/p\\/3263858.html\" target=\"_blank\" rel=\"external\">http:\\/\\/www.cnblogs.com\\/yjiyjige\\/p\\/3263858.html<\\/a><br><a href=\"http:\\/\\/blog.csdn.net\\/henuyx\\/article\\/details\\/44653799\" target=\"_blank\" rel=\"external\">http:\\/\\/blog.csdn.net\\/henuyx\\/article\\/details\\/44653799<\\/a><\\/p>\n<\\/blockquote>\n<p>我们用 k 表示当 T[i] 与 P[j] 不匹配的时候，j 要移动的下一个位置，则 next[j] = k. 现在你可以猜到，<strong>next[j] 存储的是：当 T[i] 与 P[j] 匹配失败时，j 将要移动的下一个位置。<\\/strong><\\/p>\n<p>我们还是举上面那个例子吧：<\\/p>\n<pre><code>ABCABD\n     ↑ j = 5，匹配失败\n\nABCABD\n  ↑ j = 2，把 j 移动到这个位置\n<\\/code><\\/pre><p>有没有发现什么？没错， P[0~1] 和 P[3~4] 是重合的！<\\/p>\n<p>再比如说：<\\/p>\n<pre><code>       ↓ i = 7\nABCDABCDNAIVE\nABCDABCB\n       ↑ j = 7\n<\\/code><\\/pre><p>这个时候又匹配失败了。虽然我们作为人类，很容易看出这两个字符串无论怎么移动都不能匹配。不过我们这个时候还是要<s>假装尝试一下<\\/s>，我们会这样移动 j 指针：<\\/p>\n<pre><code>移动前：\n       ↓ i = 7\nABCDABCDNAIVE\nABCDABCB\n       ↑ j = 7\n移动后：\n       ↓ i = 7\nABCDABCDNAIVE\n    ABCDABCB\n       ↑ j = 3\n<\\/code><\\/pre><p>哎，是不是还是刚才的那个规律呢，模式串的 P[0~2] 和 P[4~6] 是重合的，而恰恰又是 j 移动的位置 3 把它们隔开了。<\\/p>\n<p>现在我们可以总结出这样的性质了：<strong>当 T[i] 与 P[j] 匹配失败的时候，j 移动到下一个位置 k，k 即为使得 <code>P[0, k-1] = P[j-k, j-1] (或者说 P[k+1, j-1])<\\/code> 的那个值。<\\/strong><\\/p>\n<p>引用一下一篇文章的证明：<\\/p>\n<blockquote>\n<p>当T[i] != P[j]时<br>有T[i-j ~ i-1] == P[0 ~ j-1]<br>由P[0 ~ k-1] == P[j-k ~ j-1]<br>必然：T[i-k ~ i-1] == P[0 ~ k-1]<\\/p>\n<\\/blockquote>\n<p>进一步我们还可以发现，这个 k 的位置完全取决于模式串 P 自身的性质，与目标串 T 无关。所以我们就可以预处理计算出对于每一个 j 的 k 值了。就如我们刚才所说的我们把 k 存储在 next 数组当中，那么接下来我们就来计算 next 数组。<\\/p>\n<h1 id=\"next-数组的计算\"><a href=\"#next-数组的计算\" class=\"headerlink\" title=\"next 数组的计算\"><\\/a>next 数组的计算<\\/h1><p>先温习一下 next 数组的含义和作用：<\\/p>\n<blockquote>\n<p> next[j] 存储的是：当 T[i] 与 P[j] 匹配失败时，j 将要移动的下一个位置。<\\/p>\n<\\/blockquote>\n<p>接下来我们分类讨论一下：<\\/p>\n<ol>\n<li>当 j = 0 的时候，显然 j 已经不能再往前移动了，我们这个时候应该保持 j 不动，然后向右移动 i 指针继续匹配。所以我们让 next[0] = -1，告诉 KMP 主算法已经不能再移动 j 指针了。<\\/li>\n<li>当 j = 1 的时候，显然 j 只能移动到 0，所以 next[1] = 0.<\\/li>\n<li>那么其他情况呢？如果 P[j] = P[k] 的话，那么 next[j+1] = next[j] + 1.<\\/li>\n<li>最后一种情况就是 P[j] != P[k]，那么我们就让 k = next[k], 重复这个步骤直到符合上面三个条件之一为止。<\\/li>\n<\\/ol>\n<p>至于为什么这样做，这里主要介绍一下 3 和 4：<\\/p>\n<h3 id=\"为什么-P-j-P-k-的时候，next-j-1-next-j-1-呢？\"><a href=\"#为什么-P-j-P-k-的时候，next-j-1-next-j-1-呢？\" class=\"headerlink\" title=\"为什么 P[j] = P[k] 的时候，next[j+1] = next[j] + 1 呢？\"><\\/a>为什么 P[j] = P[k] 的时候，next[j+1] = next[j] + 1 呢？<\\/h3><p>考虑这样一个字符串：<\\/p>\n<pre><code>index 0 1 2 3 4 5 6 7 8\nstr   A B C D A B C D E\nnext -1 0 0 0 0 0 0 3 4\n<\\/code><\\/pre><p>通过计算我们可以发现 next[7] = 3, 因为 3 的左边和右边都是 ABC，这个时候我们发现 P[7] = P[3] = D.<\\/p>\n<p>所以，我们发现，当 j = j+1 = 8 之后，next[8] = 4 = next[7] + 1. 这个规律也是可以证明的。这个证明同样是引用：<\\/p>\n<blockquote>\n<p>因为在P[j]之前已经有P[0 ~ k-1] == p[j-k ~ j-1]。（next[j] == k）<br>这时候现有P[k] == P[j]，我们可以得到P[0 ~ k-1] + P[k] == p[j-k ~ j-1] + P[j]。<br>即：P[0 ~ k] == P[j-k ~ j]，即next[j+1] == k + 1 == next[j] + 1。<\\/p>\n<\\/blockquote>\n<h3 id=\"那-P-j-P-k-的时候呢？\"><a href=\"#那-P-j-P-k-的时候呢？\" class=\"headerlink\" title=\"那 P[j] != P[k] 的时候呢？\"><\\/a>那 P[j] != P[k] 的时候呢？<\\/h3><p>如果没有赋值的时候，next[j] 默认是等于 0 的，否则 k 就是上一次计算的 k 值。<br>这样，当 P[j] != P[k] 的时候，我们就一直让 k = next[k]，直到 k 符合上面的条件之一为止。<\\/p>\n<p>鉴于……这个东西我也讲不清楚qwq 所以我找到了一篇总结的挺好的文章：<a href=\"https:\\/\\/www.zhihu.com\\/question\\/21474082。\" target=\"_blank\" rel=\"external\">https:\\/\\/www.zhihu.com\\/question\\/21474082。<\\/a> 虽然内容不长，但是我就不贴过来了。<\\/p>\n<h2 id=\"那么，我们可以整理出计算-next-数组的整个过程了：\"><a href=\"#那么，我们可以整理出计算-next-数组的整个过程了：\" class=\"headerlink\" title=\"那么，我们可以整理出计算 next 数组的整个过程了：\"><\\/a>那么，我们可以整理出计算 next 数组的整个过程了：<\\/h2><pre><code>初始化 next[] = 0\nnext[0] ← -1\nj ← 0, k ← -1, len ← (pattern 长度 - 1)\nwhile j &lt; len do\n  if k = -1 || pattern[j] = pattern[k] then\n    j ← j+1, k ← k+1\n    next[j] = k\n  else\n    k ← next[k]\n<\\/code><\\/pre><p>下面是一个用 C++ 实现的方式：<\\/p>\n<pre><code class=\"cpp\">void calcNextArr()\n{\n  next[0] = -1;\n  int j = 0, k = -1, len = strlen(pattern) - 1;\n  while (j &lt; len)\n  {\n    if (k == -1 || pattern[j] == pattern[k]) {\n      next[++j] = ++k;\n      \\/\\/ 如果要做时间复杂度优化，就加上下面的代码\n      if (pattern[j] == pattern[k]) {\n        next[j] = next[k];\n      }\n    } else {\n      k = next[k];\n    }\n  }\n}\n<\\/code><\\/pre>\n<h2 id=\"优化-next-数组的求解\"><a href=\"#优化-next-数组的求解\" class=\"headerlink\" title=\"优化 next 数组的求解\"><\\/a>优化 next 数组的求解<\\/h2><p>注意到我们在实现上面的伪代码的时候多了两句：<\\/p>\n<pre><code class=\"cpp\">if (pattern[j] == pattern[k]) {\n  next[j] = next[k];\n}\n<\\/code><\\/pre>\n<p>为什么要加这一句呢？我们可以看出如果 P[j] = P[k] 的时候，让 next[j] = next[k]. 但是我们上文不是说到，如果 P[j] = P[k] 的时候，next[j+1] = next[j] + 1 嘛，为什么又回去了呐？考虑这样的一个模式串：<\\/p>\n<pre><code>ABCABDNAIVE\nABCABCABDAB\n     ↑ j = 5\n<\\/code><\\/pre><p>如上，当我们在 j = 5 的地方匹配失败的时候，按照我们上面的算法，next[j] = 2，所以 j 会回溯到 2 的地方，指向 C. 但是我们发现就算 j 回溯到 j = 2 的时候，P[j] 仍然等于 C，依旧不能和目标串匹配啊。所以我们还是要把 j 继续回溯，那么这时候 next[j] = 0. 相信大家想到了，只要我们让 j = 5 的时候直接跳回 0，就可以省去多跳一步的步骤了，这就是这段代码的作用。<\\/p>\n<h1 id=\"KMP-主算法\"><a href=\"#KMP-主算法\" class=\"headerlink\" title=\"KMP 主算法\"><\\/a>KMP 主算法<\\/h1><p>了解了 next[] 数组之后，你已经完全了解 KMP 不远了。 接下来是 KMP 算法的整个流程<br>：<\\/p>\n<pre><code>T ← 目标串，P ← 模式串\ni ← 0, j ← 0\nnext[] ← calcNext(P)                   \\/\\/ 对模式串 P 计算其 next 数组的值\nwhile i &lt; T.length &amp;&amp; j &lt; P.length do\n  \\/\\/ 如果 j 已经指向模式串的起点了，就把 i 下移一位，j 置零；或者 T[i] 和 P[j] 匹配了，那么就把 i, j 一起下移一位\n  if j == -1 || T[i] == P[j] then\n    i ← i+1, j ← j+1\n  \\/\\/ 如果不匹配，那就让 j 回溯到 next[j] 位置\n  else\n    j ← next[j]\nif j &gt;= P.length                  \\/\\/ 此时匹配成功\n  return i-j                      \\/\\/ i-j 即为 T 与 P 匹配时 T 串开始的位置\nelse\n  return -1                       \\/\\/ 否则返回不匹配，用 -1 表示\n<\\/code><\\/pre><p>仍旧是一份 C++ 实现的模板：<\\/p>\n<pre><code class=\"cpp\">int KMP()\n{\n  int i = 0, j = 0;\n  int tlen = strlen(target), plen = strlen(pattern);\n  while (i &lt; tlen &amp;&amp; j &lt; plen)\n  {\n    if (j == -1 || target[i] == pattern[j]) {\n      i++, j++;\n    } else {\n      j = next[j];\n    }\n  }\n\n  if (j == plen) {\n    return i - j;\n  } else {\n    return -1;\n  }\n}\n<\\/code><\\/pre>\n<h1 id=\"解决实际问题\"><a href=\"#解决实际问题\" class=\"headerlink\" title=\"解决实际问题\"><\\/a>解决实际问题<\\/h1><h2 id=\"HDU2087\"><a href=\"#HDU2087\" class=\"headerlink\" title=\"HDU2087\"><\\/a>HDU2087<\\/h2><p>地址在这里：<a href=\"http:\\/\\/acm.hdu.edu.cn\\/showproblem.php?pid=2087\" target=\"_blank\" rel=\"external\">http:\\/\\/acm.hdu.edu.cn\\/showproblem.php?pid=2087<\\/a><\\/p>\n<p>分析题目我们可以发现这就是一道简单的裸题字符串匹配，我们当然可以直接上 KMP 啦。下面是这题的 AC 代码：<\\/p>\n<pre><code class=\"cpp\">#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n\nconst int MAXN = 1e3 + 10;\nint n[MAXN];\nchar target[MAXN], pattern[MAXN];\n\nvoid init()\n{\n  memset(target, 0, sizeof target);\n  memset(pattern, 0, sizeof pattern);\n  memset(n, 0, sizeof n);\n}\n\nvoid calcNext()\n{\n  n[0] = -1;\n  int i = 0, k = -1, len = strlen(pattern) - 1;\n  while (i &lt; len)\n  {\n    if (k == -1 || pattern[i] == pattern[k]) {\n      n[++i] = ++k;\n      if (pattern[i] == pattern[k]) {\n        n[i] = n[k];\n      }\n    } else {\n      k = n[k];\n    }\n  }\n}\n\nint KMP()\n{\n  int ans = 0, i = 0, j = 0;\n  int tlen = strlen(target), plen = strlen(pattern);\n\n  while (i &lt; tlen)\n  {\n    if (j == -1 || target[i] == pattern[j]) {\n      i++, j++;\n    } else {\n      j = n[j];\n    }\n    if (j == plen) {\n      j = 0;\n      ans++;\n    }    \n  }\n  return ans;\n}\n\nint main()\n{\n  while (~scanf(&quot;%s&quot;, target))\n  {\n    if (target[0] == &#39;#&#39;)\n      break;\n    scanf(&quot;%s&quot;, pattern);\n    calcNext();\n    int ans = KMP();\n    printf(&quot;%d\\n&quot;, ans);\n    init();\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h2 id=\"luogu-3375\"><a href=\"#luogu-3375\" class=\"headerlink\" title=\"luogu 3375\"><\\/a>luogu 3375<\\/h2><p>这题也是个 KMP，可能有多个匹配，那么它要输出每个匹配的位置；以及这题的 next 数组不能优化，因为他还要输出= =我就是用了优化的 next 数组然后 WA 了好多次（<br>总之写起来大概像下面这样：<\\/p>\n<pre><code class=\"cpp\">#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int MAXN = 1000050;\nint next[MAXN], n[MAXN];\nint len1, len2;\nchar target[MAXN], pattern[MAXN];\n\nvoid calcNext()\n{\n    int j = 0, k = -1;\n    next[0] = -1, n[0] = -1;\n    while (j &lt; len2)\n    {\n        if (k == -1 || pattern[j] == pattern[k]) {\n            next[++j] = ++k;\n            n[j] = k;\n            if (pattern[j] == pattern[k]) {\n                n[j] = n[k];\n            }\n        } else {\n            k = next[k];\n        }\n    }\n}\n\nvoid kmp()\n{\n    int i = 0, j = 0;\n    while (i &lt; len1)\n    {\n        if (j == -1 || target[i] == pattern[j]) {\n            i++, j++;\n        } else {\n            j = n[j];\n        }\n\n        if (j == len2) {\n            printf(&quot;%d\\n&quot;, i - j + 1);\n            j = n[j];\n        }\n    }\n}\n\nint main()\n{\n    scanf(&quot;%s%s&quot;, target, pattern);\n    len1 = strlen(target);\n    len2 = strlen(pattern);\n    calcNext();\n    kmp();\n    for (int i = 1; i &lt;= len2; i++)\n    {\n        printf(&quot;%d &quot;, next[i]);\n    }    \n    printf(&quot;\\n&quot;);\n    return 0;\n}\n<\\/code><\\/pre>\n<p>至此，我们对 KMP 的算法就有了一个比较完整的了解了。<\\/p>\n",
      "excerpt": "<p>因为上周末 MFE 群里有位成员提到了这个算法，所以那天晚上就稍微认识了一下这个算法，感觉 KMP 对于匹配字符串上的做法还是好神奇的，值得水篇文章整理一下。<\\/p>",
      "slug": "kmp-algorithm-for-matching-string",
      "published": true,
      "layout": "post",
      "path": "blog/post/kmp-algorithm-for-matching-string/",
      "permalink": "https://kirainmoe.com/blog/post/kmp-algorithm-for-matching-string/",
      "tags": [
        {
          "name": "algorithm",
          "slug": "algorithm",
          "path": "tags/algorithm/",
          "permalink": "https://kirainmoe.com/tags/algorithm/",
          "length": 8
        },
        {
          "name": "kmp",
          "slug": "kmp",
          "path": "tags/kmp/",
          "permalink": "https://kirainmoe.com/tags/kmp/",
          "length": 1
        }
      ],
      "categories": []
    },
    {
      "title": "使用 LaTeX + Beamer 制作幻灯片 (Windows)",
      "date": "2017-09-17T08:32:47.000Z",
      "modified": "2018-01-07T05:18:30.179Z",
      "content": "<p>因为这周的演讲涉及到一些很难用嘴巴讲明白的东西，就打算做一个幻灯片在演讲的时候放映辅助理解。看着自己在 PowerPoint 下这里调调那里改改，挣扎了两天之后才憋出了 3 页的效率，于是果断打算另寻一种方法来做幻灯片。突然想到前几个月省夏的时候讲师的幻灯片都做得很漂亮（但是很明显不是 PPT 做的），于是去查找了一下相关的资料，就发现了下文中制作幻灯片的一个神器：LaTeX + Beamer.<\\/p>\n<a id=\"more\"><\\/a>\n<h1 id=\"为什么选用-LaTeX-Beamer\"><a href=\"#为什么选用-LaTeX-Beamer\" class=\"headerlink\" title=\"为什么选用 LaTeX + Beamer?\"><\\/a>为什么选用 LaTeX + Beamer?<\\/h1><blockquote>\n<p>LaTeX 是一种基于ΤΕΧ的排版系统，利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。<\\/p>\n<\\/blockquote>\n<p>Beamer 是基于 LaTeX 的一个制作幻灯片的框架。我之所以选用 Beamer 是因为有了两者的搭配，在制作幻灯片的时候你完全不用太过担心如何排版，如何布局，在不同的设备上显示的效果如何，就像用 Markdown 在写作那样，你只需要把你的内容按照格式打进去，它就会编译生成很漂亮、工整的幻灯片，你需要做的只是微调一下显示的效果，以及花更多的精力在雕琢你的内容而不是板式上。<\\/p>\n<p>配置 LaTeX + Beamer 环境比较复杂，因为自己在没有按照现有教程的情况下一步一步地尝试，就这一步折腾了两个小时。但是接下来真正制作幻灯片的时候是很省力省时的，至少是用 PowerPoint 效率的两倍以上，而且一次配置终身受益，也算是值得了。<\\/p>\n<h1 id=\"配置环境\"><a href=\"#配置环境\" class=\"headerlink\" title=\"配置环境\"><\\/a>配置环境<\\/h1><h2 id=\"1-安装-Tex-编译器-TeXLive\"><a href=\"#1-安装-Tex-编译器-TeXLive\" class=\"headerlink\" title=\"1. 安装 Tex 编译器 TeXLive\"><\\/a>1. 安装 Tex 编译器 TeXLive<\\/h2><p>我的工作环境系统是 Windows 10 1703 x64, 用的是 TeXLive 的发行版，编辑 tex 使用的是 Sublime Text 3 + LaTeXTools(不得不说 Sublime 对 LaTeX 的支持确实不错，不像某 VSCode). 需要注意的是我用相同的步骤在 32 位 Windows 10 下配置出现了一些问题，目前暂不知道由什么引起。<\\/p>\n<p>首先到 <a href=\"http:\\/\\/www.tug.org\\/texlive\\/acquire-netinstall.html\" target=\"_blank\" rel=\"external\">http:\\/\\/www.tug.org\\/texlive\\/acquire-netinstall.html<\\/a> 下载适用于 Windows 的最新的 TeXLive 安装程序。然后运行它。<\\/p>\n<p>接下来选择你要如何安装 TeXLive, 有简单安装（就是安装所有东西）和自定义安装，自定义安装里你可以选择一些你想装和不想装的东西，如果你选择完全安装，那装完会有接近 6 个 G 的样子。如果你选择自定义安装，接下来会让你选择安装的路径和需要的东西。勾选一些必要的东西和去掉一些你不需要的语言包就可以了。<\\/p>\n<p>然后是一个漫长的安装过程。TeXLive 的安装程序会自动下载刚刚你选择要安装的东西，默认的安装目录是 <code>C：\\texlive\\2017\\<\\/code> 下。安装完后你可以选择把安装目录下的 bin\\win32 文件夹 (例如<code>C:\\texlive\\2017\\bin\\win32<\\/code>) 加入到系统的环境变量中。<\\/p>\n<h2 id=\"2-安装-Sumatra-PDF\"><a href=\"#2-安装-Sumatra-PDF\" class=\"headerlink\" title=\"2. 安装 Sumatra PDF\"><\\/a>2. 安装 Sumatra PDF<\\/h2><p>这是一款轻便的 PDF 阅读器，用于接下来我们把 LaTeX 文件编译成 PDF 的时候阅览，以及在写作的时候通过 Sublime Text 的插件 LaTexTools 编译，然后实时查看更改（<s>传说中的热更新<\\/s>）。<\\/p>\n<p>这一步比较简单，可以在这里下载到 Sumatra PDF: <a href=\"https:\\/\\/www.sumatrapdfreader.org\\/free-pdf-reader.html\" target=\"_blank\" rel=\"external\">https:\\/\\/www.sumatrapdfreader.org\\/free-pdf-reader.html<\\/a><\\/p>\n<p>安装完成之后要把 Sumatra PDF 的安装路径加到环境变量里（你应该知道环境变量在哪儿设置的哦？此电脑\\/计算机\\/这台电脑\\/我的电脑 右键→属性→高级→环境变量，编辑 Path 值，在内容的后面加一个英文的分号然后把路径贴进去）。<\\/p>\n<h2 id=\"3-安装和配置-Sublime-Text\"><a href=\"#3-安装和配置-Sublime-Text\" class=\"headerlink\" title=\"3. 安装和配置 Sublime Text\"><\\/a>3. 安装和配置 Sublime Text<\\/h2><p>Sublime Text 3 很容易可以下载到并且安装，这里就不赘述了，各位码农们一定很熟悉这个编辑器了。安装完后我们打开它，先安装它的插件包管理器 Package Control, 键盘按 Ctrl + ~，打开控制台，粘贴：<\\/p>\n<pre><code class=\"python\">import urllib.request,os,hashlib; h = &#39;6f4c264a24d933ce70df5dedcf1dcaee&#39; + &#39;ebe013ee18cced0ef93d5f746d80ef60&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#39;http:\\/\\/packagecontrol.io\\/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by)\n<\\/code><\\/pre>\n<p>然后回车，等待它有反应之后就是安装好了。接着按 Ctrl + Shift + P, 选择 Package Control: Install Package, 搜索 LaTexTools 并且安装。<\\/p>\n<p>安装好后，我们在 Preference -&gt; Package Settings -&gt; LaTexTools -&gt; Settings - User，一路点是，然后我们接下来要修改它的配置文件。主要是修改两个地方就行：<\\/p>\n<p>第一个是修改 LaTeX 发行版和 Sumatra PDF 的位置，在文件大概 209 行的位置，找到：<\\/p>\n<pre><code class=\"json\">  &quot;windows&quot;: {\n    \\/\\/ 修改这里的值为 texlive 安装位置的 bin\\win32 文件夹的路径，然后在最后补上一个 ;$PATH 即可，如下\n    &quot;texpath&quot; : &quot;D:\\\\texlive\\\\2017\\\\bin\\\\win32;$PATH&quot;,\n    \\/\\/ TeX 发行版，修改成 texlive\n    &quot;distro&quot; : &quot;texlive&quot;,\n    \\/\\/ Sumatra PDF 的安装位置，要精确到 exe 文件的路径\n    &quot;sumatra&quot;: &quot;C:\\\\Program Files\\\\SumatraPDF\\\\SumatraPDF.exe&quot;,\n    \\/\\/ ...\n  },\n<\\/code><\\/pre>\n<p>第二个是修改编译 tex 文件的方法，在大概 379 行的位置找到：<\\/p>\n<pre><code class=\"json\">  \\/\\/ 把 traditional 改成 simple 或者 basic\n  &quot;builder&quot;: &quot;traditional&quot;,\n<\\/code><\\/pre>\n<p>这样我们就搭建好了环境。接下来就只需要创建一个 tex 文件，写好之后 Ctrl+B 编译就行了，记得在 Tools -&gt; Build system 里设置为 Auto.<\\/p>\n<h1 id=\"Beamer-基本用法\"><a href=\"#Beamer-基本用法\" class=\"headerlink\" title=\"Beamer 基本用法\"><\\/a>Beamer 基本用法<\\/h1><pre><code class=\"latex\">\\documentclass{beamer}\n\\usepackage[utf8]{inputenc}\n% 引入中文支持\n\\usepackage{CJKutf8}\n% 插入图片用的 package\n\\usepackage{graphicx}\n\\usepackage{ulem}\n% 主题和配色\n\\usetheme{Hannover}\n\\usecolortheme{spruce}\n\n\n% 幻灯片信息\n\\title{Slide Title}\n\\author{Slide Author}\n\\institute{Slide Subtitle}\n\\date{\\today}\n\n\\begin{document}\n  % 中文支持\n  \\begin{CJK}{UTF8}{gbsn}\n    % 插入标题页面\n    \\frame{titlepage}\n\n    % 一张幻灯片\n    \\begin{frame}\n      \\frametitle{幻灯片标题}\n      % 无序列表\n      \\begin{itemize}\n        % \\pause 用于单步放映\n        \\item Item 1\\pause\n        \\item Item 2\\pause\n        \\item Item 3\\pause\n      \\end{itemize}\n    \\end{frame}\n\n    % 模块\n    \\section{分类1}\n      \\subsection{标题1}\n      \\begin{frame}\n        \\frametitle{LaTeX + Beamer 基本用法}\n        % 居中\n        \\begin{Center}\n          Contents that will be displayed on center.\n        \\end{center}\n\n        % 插入一张图片\n        \\includegraphics[height=4cm]{img\\/1.png}\n\n        % 表格\n          \\begin{table}[h]\n          \\centering\n          \\begin{tabular}{|c|c|}\n            \\hline 基因型 &amp; 血型 \\\\\n            \\hline I$^{A}$I$^{A}$, I$^{A}$i &amp; A 型 \\\\\n            \\hline I$^{B}$I$^{B}$, I$^{B}$i &amp; B 型 \\\\\n            \\hline I$^{A}$I$^{B}$ &amp; AB 型 \\\\\n            \\hline ii &amp; O 型 \\\\\n            \\hline\n          \\end{tabular}\n          \\caption{基因型和血型的对应关系}\n          \\label{tab:Margin_settings}\n      \\end{frame}\n  \\end{CJK}\n\\end{document}\n<\\/code><\\/pre>\n<p>大概是这样的。其实用起来还是非常简单的。写完之后按上面的方法编译，然后你就可以找到 tex 文件目录下的 pdf 文件，这个就是编译出的幻灯片。至此我们就完成了 LaTeX + Beamer 环境在 Windows 下的配置。 Linux 和 macOS 下大同小异，就是安装发行版的过程和插件配置时的路径有区别，具体请自行搜索。<\\/p>\n",
      "excerpt": "<p>因为这周的演讲涉及到一些很难用嘴巴讲明白的东西，就打算做一个幻灯片在演讲的时候放映辅助理解。看着自己在 PowerPoint 下这里调调那里改改，挣扎了两天之后才憋出了 3 页的效率，于是果断打算另寻一种方法来做幻灯片。突然想到前几个月省夏的时候讲师的幻灯片都做得很漂亮（但是很明显不是 PPT 做的），于是去查找了一下相关的资料，就发现了下文中制作幻灯片的一个神器：LaTeX + Beamer.<\\/p>",
      "slug": "making-slider-with-latex-beamer-on-windows",
      "published": true,
      "layout": "post",
      "path": "blog/post/making-slider-with-latex-beamer-on-windows/",
      "permalink": "https://kirainmoe.com/blog/post/making-slider-with-latex-beamer-on-windows/",
      "tags": [
        {
          "name": "latex",
          "slug": "latex",
          "path": "tags/latex/",
          "permalink": "https://kirainmoe.com/tags/latex/",
          "length": 1
        },
        {
          "name": "beamer",
          "slug": "beamer",
          "path": "tags/beamer/",
          "permalink": "https://kirainmoe.com/tags/beamer/",
          "length": 1
        }
      ],
      "categories": []
    },
    {
      "title": "每周解题报告 (4th, 8/20~9/10)",
      "date": "2017-09-10T03:16:22.000Z",
      "modified": "2018-01-07T05:18:35.990Z",
      "content": "<p>经过了一周阶段考的折磨过后，这一周终于有时间更新解题报告了。上一周因为时间太少，加上填 MUSE 的坑，只做了一题，索性都屯到这一周来发了，但虽然这样这周的题量还是没有多到哪里去……<\\/p>\n<p>有些比较简单的题目我就两句话带过就好了。特地在 GitHub 上开了个仓库，这一篇包括之前那些解题报告中题目的所有完整代码（以及部分题的数据）以及接下来做的 HDU 的题都会汇总在<a href=\"https:\\/\\/github.com\\/kirainmoe\\/oh-my-hdu\" target=\"_blank\" rel=\"external\">这个地方<\\/a>。<\\/p>\n<a id=\"more\"><\\/a>\n<h1 id=\"13-200-HDU1069-Monkey-and-Banana\"><a href=\"#13-200-HDU1069-Monkey-and-Banana\" class=\"headerlink\" title=\"13\\/200, HDU1069, Monkey and Banana\"><\\/a>13\\/200, HDU1069, Monkey and Banana<\\/h1><h2 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution\"><\\/a>Solution<\\/h2><p>经典 DP，最开始的思路是……设一个四维的状态…反正数据范围这么小是吧 (x) 后来写了好久写不下去了。查了一发题解，随便点开一个，看到第一句话：先把 x 排序，然后把 y 排序……会了……<\\/p>\n<p>那么，首先输入一组 xyz，然后排序一下，选择其中两个当做 width 和 length，然后最后一个数当 height；把 x, y 分别按照从大到小的顺序排序一遍，然后对 z 求满足第 i 层的 x, y 小于第 i-1 层的 x, y 时的最大 z 之和就好了。<\\/p>\n<p>转移方程：<code>dp[i] = dp[j] + block[i].height, 其中 j = 0...i-1<\\/code><\\/p>\n<p><em>\\/\\/ PS. 嘛，顺序枚举 j 似乎会 WA，所以 j 要从 i-1 倒回去。 <\\/em><\\/p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"><\\/a>Code<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nusing namespace std;\nconst int MAXN = 35 * 6 + 10;\nstruct Block {\n  int x, y, z;\n};\nBlock b[MAXN];\nint T, kases = 0;\nint size = 0, ans = 0;\nint dp[MAXN];\n\nbool cmp(const Block a, const Block b)\n{\n  if (a.x &gt; b.x)\n    return true;\n  if (a.x == b.x &amp;&amp; a.y &gt; b.y)\n    return true;\n  return false;\n}\n\nint main()\n{\n  while (scanf(&quot;%d&quot;, &amp;T) != EOF &amp;&amp; T != 0)\n  {    \n    size = 0, ans = 0;\n    memset(b, 0, sizeof(b));\n    memset(dp, 0, sizeof(dp));\n\n    for (int i = 0; i &lt; T; i++)\n    {\n      int tx, ty, tz;\n      scanf(&quot;%d%d%d&quot;, &amp;tx, &amp;ty, &amp;tz);\n      int arr[3] = {tx, ty, tz};\n\n      sort(arr, arr + 3);\n\n      \\/\\/ permutation\n      b[size].x = arr[0], b[size].y = arr[1], b[size++].z = arr[2];\n      b[size].x = arr[0], b[size].y = arr[2], b[size++].z = arr[1];\n      b[size].x = arr[1], b[size].y = arr[2], b[size++].z = arr[0];\n\n      sort(b, b+size, cmp);\n    }\n\n    for (int i = 0; i &lt; size; i++)\n    {\n      dp[i] = b[i].z;\n      for (int j = i - 1; j &gt;= 0; j--)\n      {\n        if (b[i].x &lt; b[j].x &amp;&amp; b[i].y &lt; b[j].y) {\n          dp[i] = max(dp[j] + b[i].z, dp[i]);\n        }\n      }\n      ans = max(ans, dp[i]);\n    }\n    printf(&quot;Case %d: maximum height = %d\\n&quot;, ++kases, ans);\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"14-200-HDU1176-免费馅饼\"><a href=\"#14-200-HDU1176-免费馅饼\" class=\"headerlink\" title=\"14\\/200, HDU1176, 免费馅饼\"><\\/a>14\\/200, HDU1176, 免费馅饼<\\/h1><h2 id=\"Solution-1\"><a href=\"#Solution-1\" class=\"headerlink\" title=\"Solution\"><\\/a>Solution<\\/h2><p>这题有两种做法。<\\/p>\n<ol>\n<li><p>第一种是直接 DP，注意的是可以不要想太多去检查状态是否合法，状态表示和转移方程：<code>dp[i][j]<\\/code> 表示第 i 秒的时候站在第 j 个位置能接到的最大馅饼数，<br>则：<code>dp[i][j]  = max(dp[i-1][j], dp[i-1][j-1], dp[i-1][j+1]) + items[i][j] (如果 j-1 和 j+1 存在)<\\/code><\\/p>\n<\\/li>\n<li><p>数塔做法：联想一下数字三角形，从下往上递推回去就行了。<code>dp[i][j]<\\/code> 还是表示第 i 秒在第 j 个位置能取到的最大值，不同的是要逆推，并且可以直接覆盖掉之前的值（因为计算完就没有用了），则：<br><code>dp[i][j] =  max(dp[i+1][j-1], dp[i+1][j], dp[i+1][j+1]) + dp[i][j]<\\/code><\\/p>\n<\\/li>\n<\\/ol>\n<h2 id=\"Code-1\"><a href=\"#Code-1\" class=\"headerlink\" title=\"Code\"><\\/a>Code<\\/h2><pre><code class=\"cpp\">\\/\\/ Solution 1\n#include &lt;bits\\/stdc++.h&gt;\nusing namespace std;\n\nconst int MAXT = 1e5 + 10;\nconst int MAXP = 11;\n\nint n, mt, ans = 0;\nint items[MAXT][MAXP];\nint dp[MAXT][MAXP];\n\nint cmp(int a, int b, int c)\n{\n  return max(a, max(b, c));\n}\n\nint main()\n{\n  while (scanf(&quot;%d&quot;, &amp;n) != EOF &amp;&amp; n != 0)\n  {\n    memset(items, 0, sizeof(items));\n    memset(dp, 0, sizeof(dp));\n    mt = 0, ans = 0;\n    for (int i = 0; i &lt; n; i++)\n    {\n      int x, t;\n      scanf(&quot;%d%d&quot;, &amp;x, &amp;t);\n      items[t][x]++;\n      mt = max(t, mt);\n    }\n\n    dp[1][4] = items[1][4];\n    dp[1][5] = items[1][5];\n    dp[1][6] = items[1][6];\n\n    for (int i = 2; i &lt;= mt; i++)\n    {\n      for (int j = 0; j &lt; MAXP; j++)\n      {\n        dp[i][j] = dp[i-1][j];\n        if (j == 0) {\n          dp[i][j] = max(dp[i-1][j], dp[i-1][j+1]) + items[i][j];\n        } else if (j == MAXP - 1) {\n          dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + items[i][j];\n        } else {\n          dp[i][j] = cmp(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]) + items[i][j];\n        }\n        ans = max(ans, dp[i][j]);\n      }\n    }\n\n    printf(&quot;%d\\n&quot;, ans);\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<pre><code class=\"cpp\">\\/\\/ Solution 2\n#include &lt;bits\\/stdc++.h&gt; \nusing namespace std;\nconst int MAXT = 1e5 + 10;\nconst int MAXP = 11;\n\nint n, mt, ans = 0;\nint pies[MAXT][MAXP];\n\nint main()\n{\n  while (scanf(&quot;%d&quot;, &amp;n) != EOF &amp;&amp; n)\n  {\n    memset(pies, 0, sizeof(pies));\n    ans = 0;\n    for (int i = 0; i &lt; n; i++)\n    {\n      int x, t;\n      scanf(&quot;%d%d&quot;, &amp;x, &amp;t);\n      pies[t][x]++;\n      mt = max(mt, t);\n    }\n\n    for (int i = mt - 1; i &gt;= 0; i--)\n    {\n      for (int j = 0; j &lt; MAXP; j++)\n      {\n        int tmp = pies[i][j];       \\/\\/ current\n        pies[i][j] = pies[i+1][j];\n\n        if (j &gt; 0) {\n          pies[i][j] = max(pies[i+1][j-1], pies[i][j]);\n        }\n\n        if (j &lt; MAXP - 1) {\n          pies[i][j] = max(pies[i+1][j+1], pies[i][j]);\n        }\n\n        pies[i][j] += tmp;\n      }\n    }\n\n    printf(&quot;%d\\n&quot;, pies[0][5]);\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"15-200-Codeforces-846A-Curriculum-Vitae\"><a href=\"#15-200-Codeforces-846A-Curriculum-Vitae\" class=\"headerlink\" title=\"15\\/200, Codeforces 846A, Curriculum Vitae\"><\\/a>15\\/200, Codeforces 846A, Curriculum Vitae<\\/h1><h2 id=\"Solution-2\"><a href=\"#Solution-2\" class=\"headerlink\" title=\"Solution\"><\\/a>Solution<\\/h2><p>题意就是一个人要找工作，要在简历上介绍他所完成过的游戏，游戏有成功的和失败的，这个人不想让任何失败的游戏出现在成功的游戏之后，然后求他最多可以在他的简历上放上多少个这样的符合要求的游戏。<\\/p>\n<p>↑ 说成人话就是：求一个由 0 和 1 组成的序列的子序列，这个子序列满足没有一个 0 在 1 的右边，且长度尽可能大。例如 0 1 0 0 1 0 的符合要求的子序列为 0 0 0 1 或 0 0 0 0.<\\/p>\n<p>翻译完之后我们可以发现，只要找到一个最长的数列的，使得它的左边都是 0，右边都是 1 就可以了。然后我们可以发现这个子序列满足<strong>最长不下降（注意不是最长上升）<\\/strong>的性质。鉴于数据范围 &lt;= 100，所以我们可以用 O(n^2) 的最长不下降子序列算法直接过。<\\/p>\n<p>第二天想了一下，突然觉得这题似乎还有线性的做法：考虑第 i 件作品是否入选，和它的上一件符合性质要求的作品有关。假如第 i 件作品是失败的，那么第 i 件写入简历时，最大值为 <strong>上一件失败作品的最大值 + 1<\\/strong>；如果第 i 件作品是成功的，那么第 i 件写入简历时最大值为 <strong>上一件失败作品的最大值 和 上一件成功作品的最大值 两者的最大值 + 1<\\/strong>。这样，我们可以用一个 <code>last0<\\/code> 表示上一件失败作品的位置，用 <code>last1<\\/code> 表示上一件成功作品的位置。具体的转移方程可以看代码：<\\/p>\n<h2 id=\"Code-2\"><a href=\"#Code-2\" class=\"headerlink\" title=\"Code\"><\\/a>Code<\\/h2><pre><code class=\"cpp\">\\/\\/ Solution 1: O(n^2)\n#include &lt;bits\\/stdc++.h&gt; \nusing namespace std;\nconst int MAXN = 105;\nconst int INF = 1e9 + 7;\nint n, ans = 0;\nint arr[MAXN];\nint dp[MAXN];\nint main()\n{\n  memset(arr, 0, sizeof(arr));\n  memset(dp, 0, sizeof(dp));\n\n  scanf(&quot;%d&quot;, &amp;n);\n  for (int i = 0; i &lt; n; i++)\n  {\n    scanf(&quot;%d&quot;, &amp;arr[i]);\n  }\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    dp[i] = 1;\n    for (int j = 0; j &lt; i; j++)\n    {\n      if (arr[j] &lt;= arr[i] &amp;&amp; dp[i] &lt; dp[j] + 1)\n      {\n        dp[i] = dp[j] + 1;\n      }\n    }\n    ans = max(dp[i], ans);\n  }\n\n  printf(&quot;%d&quot;, ans);\n\n  return 0;\n}\n<\\/code><\\/pre>\n<pre><code class=\"cpp\">\\/\\/ Solution 2: O(n)\n#include &lt;bits\\/stdc++.h&gt;\nusing namespace std;\nconst int MAXN = 105;\nint n;\nint dp[MAXN];\nint last0 = -1, last1 = -1;\nint main()\n{\n    memset(dp, 0, sizeof(dp));\n    scanf(&quot;%d&quot;, &amp;n);\n    for (int i = 0; i &lt; n; i++)\n    {\n        int tmp;\n        scanf(&quot;%d&quot;, &amp;tmp);\n        if (tmp == 0) {\n            dp[i] = (last0 == -1 ? 1 : dp[last0] + 1);\n            last0 = i;\n        } else {\n            if (i == 0) {\n                dp[i] = 1;\n            } else {\n              dp[i] = 1;\n                if (last0 != -1) {\n                    dp[i] = max(dp[last0] + 1, dp[i]);\n                }\n                if (last1 != -1) {\n                    dp[i] = max(dp[last1] + 1, dp[i]);\n                }\n            }\n            last1 = i;\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i &lt; n; i++)\n    {\n      ans = max(ans, dp[i]);\n  }\n  printf(&quot;%d&quot;, ans);\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"16-200-Codeforces-854A-Fraction\"><a href=\"#16-200-Codeforces-854A-Fraction\" class=\"headerlink\" title=\"16\\/200, Codeforces 854A, Fraction\"><\\/a>16\\/200, Codeforces 854A, Fraction<\\/h1><p>嗯……太水了，不想写了，就是单纯的计算。<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nconst int INF = 1e9 + 7;\nint gcd(int a, int b)\n{\n  return (a == 0) ? b : gcd(b % a, a);\n}\nint main()\n{\n  int ori, curi = 1, curj = INF;\n\n  scanf(&quot;%d&quot;, &amp;ori);\n  for (int i = 1; i &lt; ori; i++)\n  {\n    for (int j = i + 1; j &lt; ori; j++)\n    {\n      int gcder = gcd(j, i);\n      double a = (double) i, b = (double) j;\n\n      if (\n        (i + j) == ori &amp;&amp;\n        gcder == 1 &amp;&amp;\n        (double)(a \\/ b) &gt; (double)((double)curi \\/ (double)curj)\n      ) {\n        curi = i, curj = j;\n      }\n    }\n  }\n\n  printf(&quot;%d %d&quot;, curi, curj);\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"17-200-HDU4568-Hunter\"><a href=\"#17-200-HDU4568-Hunter\" class=\"headerlink\" title=\"17\\/200, HDU4568, Hunter\"><\\/a>17\\/200, HDU4568, Hunter<\\/h1><p>这题前前后后花了我两星期的时间……这星期又花了三天的时间看它，终于理解并且 A 掉了这题……果然状态压缩还是一个大坑 Orz……<\\/p>\n<h2 id=\"Solution-3\"><a href=\"#Solution-3\" class=\"headerlink\" title=\"Solution\"><\\/a>Solution<\\/h2><p>题目大意是给定一个 n*m 的地图，其中有一些点当中有宝藏，经过地图中的每个点都需要花费相应的代价。一个人要从边界进入这个地图，经过所有的宝藏点，然后从边界走出，问这样做的最小代价是多少。n, m &lt;= 200, 宝藏数目 1 &lt;= k &lt;= 13.<\\/p>\n<p>首先题目的模型说成人话就是从边界的任何一点进入，取走所有宝藏，然后从边界的任意一点走出，所以我们可以知道最小代价应该是：从边界到第一个点的代价+第一个点到第二个点的代价+……+从终点走出边界的代价，这样这道题就被我们分解成了一个个的子问题了，我们只需要分别计算这些子问题就可以了。现在：<\\/p>\n<ol>\n<li><p>从边界到第一个点的最小代价和从终点走出的边界如何知道？从第 i 个点到第 j 个点的最小代价又如何知道？SPFA 对每一个宝藏点跑一遍就行了，这样我们总共需要进行 k 次 SPFA。<\\/p>\n<\\/li>\n<li><p>如何决策？每次拓展都选择当前一步代价最小的方案走显然有可能不是最优解，所以我们还是用动态规划来解全局最优的最小代价。<\\/p>\n<\\/li>\n<li><p>用 DP 如何表示状态？这道题的要求是走完所有的宝藏点，那么我们首先考虑如何表示经过的和未经过的宝藏点。因为 k &lt;= 13，我们的第一反应应该是状态压缩。用二进制表示状态点的经过情况，二进制第 i 位为 0 表示未经过第 i 个宝藏点，为 1 则表示已经经过，然后把二进制状态转换成十进制的整数即可。还有一个问题，假如只设置这样的一个状态，那么只能表示经过的点情况，不能表示终点在哪一个点，而我们到达终点的时候还需要从边界走出去，这样就还差一步，所以我们再设计一维状态，那么：<\\/p>\n<\\/li>\n<\\/ol>\n<blockquote>\n<p>设 <code>dp[i][j]<\\/code> 为当前经过的点状态为 i 且最后所在的终点位置为 j 时，所花费的最小代价。这样我们还能顺便得到转移方程：<code>dp[s | (1 &lt;&lt; next)][next] = min(dp[s | (1 &lt;&lt; next)][next], dp[s][cur] + toEach[cur][next])<\\/code>, 其中 s 是当前状态，cur 是当前状态的终点，next 是下一步的点。<\\/p>\n<\\/blockquote>\n<p>（为什么这里不需要表示起点？因为我们用 <code>dp[1 &lt;&lt; i][i] = toEdge[i]<\\/code> 可以很容易地表示以第 i 个点为起点时的代价，又我们的状态从 0 开始，所以起点在哪可以直接决策；但是终点我们很难通过 DP 方程直接决策，所以我们多一维状态。）<\\/p>\n<p>首先我们用 SPFA 先求出每两个宝藏点之间的距离和每个宝藏点到边界的距离（注意节点的拓展方向），然后就可以状态压缩了。DP 完之后，别忘了要回到边界，所以最终 <code>ans = min(dp[(1 &lt;&lt; k) - 1][i] + toEdge[i], ans), 其中 i = 0...k<\\/code>.<\\/p>\n<p>这样我们就完美地解决了这个问题。<\\/p>\n<h2 id=\"Code-3\"><a href=\"#Code-3\" class=\"headerlink\" title=\"Code\"><\\/a>Code<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt;\nusing namespace std;\nconst int INF = 1e9 + 7;\nconst int MAXN = 205;\nconst int MAXT = 14;\n\nstruct Point {\n  int x, y;\n};\nPoint target[MAXT];    \\/\\/ 宝藏坐标\n\nint k, cases, row, col;\n\n\\/\\/ dp[i][j] 表示当前已经过的宝藏点状态为 i, 并且终点为 j 时所花费的最小代价\n\\/\\/ 那么有 DP 方程：dp[s|(1&lt;&lt;next)][next] = min(dp[s|(1&lt;&lt;next)][s], dp[s][cur] + toEach[cur][next]);\n\\/\\/ 其中 next 是下一个目标状态点，cur 是当前状态的终点\nint dp[1 &lt;&lt; MAXT][MAXT];\n\n\\/\\/ 用于 SPFA 计算每个宝藏点之间的距离\nint dist[MAXN][MAXN];\n\n\\/\\/ toEdge[i] 表示第 i 个宝藏点到边界的最小代价（不包括本身）\n\\/\\/ toEach[i][j] 表示第 i 个宝藏点到第 j 个宝藏点的最小代价\nint toEdge[MAXT], toEach[MAXT][MAXT];\n\n\\/\\/ SPFA 拓展节点的方向\nint dir[2][4] = {\n  { 0, 0, 1, -1 },\n  { 1, -1, 0, 0 }\n};\n\n\\/\\/ SPFA 记录点访问情况的数组\nbool vis[MAXN][MAXN];\n\n\\/\\/ 用不定长数组存储地图\nvector&lt;int&gt; G[MAXN];\n\nvoid SPFA(int s)\n{\n  \\/\\/ 初始化 SPFA\n  memset(vis, 0, sizeof(vis));\n  for (int i = 0; i &lt; MAXN; i++)\n    for (int j = 0; j &lt; MAXN; j++)\n      dist[i][j] = INF;\n\n  queue&lt;Point&gt; Q;\n\n  Point start;\n  start.x = target[s].x, start.y = target[s].y;\n  vis[start.x][start.y] = 1;    \\/\\/ 标记起点为已访问\n  dist[start.x][start.y] = 0;   \\/\\/ 起点到自身的最短路为 0\n  Q.push(start);\n\n  while (!Q.empty())\n  {\n    Point cur = Q.front();\n    Q.pop();\n    vis[cur.x][cur.y] = 0;    \\/\\/ 当前节点出队，标记为未访问\n\n    \\/\\/ 到达边界，更新该点到边界的距离\n    if (cur.x == 0 || cur.y == 0 || cur.x == row - 1 || cur.y == col - 1) {\n      toEdge[s] = min(toEdge[s], dist[cur.x][cur.y]);\n    }\n\n    \\/\\/ 拓展节点\n    for (int i = 0; i &lt; 4; i++)\n    {\n      Point next;\n      next.x = cur.x + dir[0][i], next.y = cur.y + dir[1][i];\n      \\/\\/ 检验节点合法性以及是否可到达\n      if (next.x &gt;= 0 &amp;&amp; next.y &gt;= 0 &amp;&amp; next.x &lt; row &amp;&amp; next.y &lt; col &amp;&amp; G[next.x][next.y] != -1) {\n        \\/\\/ 松弛操作\n        if (dist[next.x][next.y] &gt; dist[cur.x][cur.y] + G[next.x][next.y]) {\n          dist[next.x][next.y] = dist[cur.x][cur.y] + G[next.x][next.y];\n          if (!vis[next.x][next.y]) {\n            Q.push(next);\n            vis[next.x][next.y] = 1;\n          }\n        }\n      }\n    } \\/\\/ end for i\n  } \\/\\/ end while\n}\n\nvoid init()\n{\n  for (int i = 0; i &lt; MAXN; i++)\n    G[i].clear();\n\n  for (int i = 0; i &lt; (1 &lt;&lt; MAXT); i++)\n    for (int j = 0; j &lt; MAXT; j++)\n      dp[i][j] = INF;\n\n  fill(toEdge, toEdge + MAXT, INF);\n\n  for (int i = 0; i &lt; MAXT; i++)\n    for (int j = 0; j &lt; MAXT; j++)\n      toEach[i][j] = INF;\n}\n\nint main()\n{\n  scanf(&quot;%d&quot;, &amp;cases);\n  while (cases--)\n  {\n    init();\n    scanf(&quot;%d%d&quot;, &amp;row, &amp;col);\n    for (int i = 0; i &lt; row; i++)\n    {\n      for (int j = 0; j &lt; col; j++)\n      {\n        int tmp;\n        scanf(&quot;%d&quot;, &amp;tmp);\n        G[i].push_back(tmp);\n      }\n    }\n    scanf(&quot;%d&quot;, &amp;k);\n    for (int i = 0; i &lt; k; i++)\n    {\n      scanf(&quot;%d%d&quot;, &amp;target[i].x, &amp;target[i].y);\n    }\n\n    \\/\\/ 求每两个宝藏点之间的最短距离（最小代价）\n    for (int i = 0; i &lt; k; i++)\n    {\n      SPFA(i);\n      for (int j = 0; j &lt; k; j++)\n      {\n        \\/\\/ 自身到自身的代价为 0\n        if (i == j) {\n          toEach[i][j] = 0;\n          continue;\n        }\n        int jx = target[j].x, jy = target[j].y;\n        toEach[i][j] = min(toEach[i][j], dist[jx][jy]);\n      }\n      \\/\\/ dp[1 &lt;&lt; i][i] 表示只访问了第 i 个点时的代价\n      \\/\\/ 等于：从边界进来时的代价 + 自身的代价\n      dp[1 &lt;&lt; i][i] = toEdge[i] + G[target[i].x][target[i].y];\n    }\n\n    \\/\\/ solve\n    \\/\\/ 枚举从 0 到 (1 &lt;&lt; k) - 1 的每个状态\n    for (int state = 0; state &lt; (1 &lt;&lt; k); state++)\n    {\n      \\/\\/ 枚举该状态当前的终点\n      for (int i = 0; i &lt; k; i++)\n      {\n        \\/\\/ 如果状态不包含当前点，则回溯\n        if ((state &amp; (1 &lt;&lt; i)) == 0) {\n          continue;\n        }\n\n        \\/\\/ 如果当前状态下到终点的距离还没有计算，则回溯？\n        \\/\\/ 不太清楚是不是这样的，因为我注释掉这段代码仍然是 AC 的\n        if (dp[state][i] == INF) {\n          continue;\n        }\n\n        \\/\\/ 枚举在当前状态时，下一个目标是去哪一个宝藏点呢\n        for (int j = 0; j &lt; k; j++)\n        {\n          \\/\\/ 如果这个宝藏点已经访问过了，就回溯，因为每个点只能走一次\n          if ((state &amp; (1 &lt;&lt; j)) == 1) {\n            continue;\n          }\n          \\/\\/ 下一个状态\n          int next = (state | (1 &lt;&lt; j));\n\n          \\/\\/ 下一个状态 next，终点为 j 的最小代价等于 这个代价 和 当前代价+(cur, next)两点间最短距离 的最小值\n          dp[next][j] = min(dp[next][j], dp[state][i] + toEach[i][j]);\n        } \\/\\/ for j\n      } \\/\\/ for i\n    } \\/\\/ for state\n\n    \\/\\/ 输出答案\n    int ans = INF;\n    for (int i = 0; i &lt; k; i++)\n    {\n      \\/\\/ 最终的最优答案是 min(dp[(1 &lt;&lt; k) - 1][i]), i = 0...k\n      \\/\\/ 因为 dp[i][j] 是以 j 为终点，但是我们最终需要从边界出去，所以还要加上终点到边界的最短距离\n      ans = min(dp[(1 &lt;&lt; k) - 1][i] + toEdge[i], ans);\n    }\n    printf(&quot;%d\\n&quot;, ans);\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<p>\\/\\/ EOF<\\/p>\n",
      "excerpt": "<p>经过了一周阶段考的折磨过后，这一周终于有时间更新解题报告了。上一周因为时间太少，加上填 MUSE 的坑，只做了一题，索性都屯到这一周来发了，但虽然这样这周的题量还是没有多到哪里去……<\\/p>\n<p>有些比较简单的题目我就两句话带过就好了。特地在 GitHub 上开了个仓库，这一篇包括之前那些解题报告中题目的所有完整代码（以及部分题的数据）以及接下来做的 HDU 的题都会汇总在<a href=\"https:\\/\\/github.com\\/kirainmoe\\/oh-my-hdu\">这个地方<\\/a>。<\\/p>",
      "slug": "practicing-record-4th-8-20-9-10",
      "published": true,
      "layout": "post",
      "path": "blog/post/practicing-record-4th-8-20-9-10/",
      "permalink": "https://kirainmoe.com/blog/post/practicing-record-4th-8-20-9-10/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "algorithm",
          "slug": "algorithm",
          "path": "tags/algorithm/",
          "permalink": "https://kirainmoe.com/tags/algorithm/",
          "length": 8
        }
      ],
      "categories": []
    },
    {
      "title": "开发一个简单的 webpack 插件",
      "date": "2017-09-02T03:59:44.000Z",
      "modified": "2018-01-07T05:18:45.784Z",
      "content": "<p>之前为了尝试实现 <a href=\"https:\\/\\/kotori.love\" target=\"_blank\" rel=\"external\">dalao<\\/a> 的一个 idea，浅浅地踩了一下 webpack 插件开发的坑。今天才想起来，趁着有时间，应该整理一下开发 webpack 插件的思路。<\\/p>\n<a id=\"more\"><\\/a>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"><\\/a>前言<\\/h1><p>首先呢，webpack 的强大功能其中有很大的一部分是离不开插件的，通过插件你几乎可以<s>为所欲为<\\/s>，也能更充分地利用 webpack. 事实上 webpack 的配置什么的很多看起来很复杂，文档也很多，所以会给很多人一种它的插件也很难搞的错觉……和其它的程序类似， webpack 的插件也有一个模子，也就是基本框架。<\\/p>\n<p>为了让整理出来的东西看起来具体一些，我以前文提到的那个想法为例，这个想法具体如下：<\\/p>\n<blockquote>\n<p>在我们使用 webpack-dev-server 结合 webpack 开发的时候，webpack-dev-server 会把 console 中的错误和警告信息转发到浏览器端，但是单纯用 <code>webpack --watch<\\/code> 的时候，webpack 除了会检测文件变动重新 compile 之外并不会把其他信息转发到浏览器上，以至于有时候我们发现了一些问题，到最后切到 console 才发现是编译的过程出现了偏差。所以有没有什么办法让 <code>webpack --watch<\\/code> 的时候也能把错误和警告显示到浏览器的 console？<\\/p>\n<\\/blockquote>\n<p>当然我不把具体的实现过程展开了。这样的需求显然可以通过 webpack 插件实现，监听 webpack 的 compile 事件，获取异常信息，然后前端和后端建立一个 socket 连接，实时输出这些信息。<\\/p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"><\\/a>实现<\\/h1><p>是的，以上所有的步骤都可以通过一个 webpack 插件做到。不多说废话，在开发之前稍微浏览一下 webpack 的官方开发文档还是很重要的：<\\/p>\n<blockquote>\n<p>How to write a plugin: <a href=\"https:\\/\\/webpack.js.org\\/development\\/how-to-write-a-plugin\\/#compiler-and-compilation\" target=\"_blank\" rel=\"external\">https:\\/\\/webpack.js.org\\/development\\/how-to-write-a-plugin\\/#compiler-and-compilation<\\/a><br>Plugin API: <a href=\"https:\\/\\/webpack.js.org\\/api\\/\" target=\"_blank\" rel=\"external\">https:\\/\\/webpack.js.org\\/api\\/<\\/a><\\/p>\n<\\/blockquote>\n<p>先来看看我们是怎么在 webpack 中应用插件的：<\\/p>\n<pre><code class=\"js\">\\/\\/ webpack.config.js\nplugins: [\n  new webpack.HotModuleReplacementPlugin(),\n  new webpack.NoEmitOnErrorsPlugin()\n],\n<\\/code><\\/pre>\n<p>可以看到，我们在 <code>webpack config<\\/code> 中的 <code>plugins<\\/code> 字段里实例化一个对象来应用插件，所以我们的新插件也应该有一个 class. 官方文档中用的是 ES5 的 <code>function + prototype<\\/code> 的写法，我们可以直接用上 ES6 的 class. 假设插件名字为 <code>MyAwesomePlugin<\\/code>, 首先我们创建一个 <em>MyAwesomePlugin.js<\\/em>：<\\/p>\n<pre><code class=\"js\">module.exports = class MyAwesomePlugin {\n    constructor(options) {\n        this.options = options;\n    }\n\n    apply(compiler) {\n        console.log(&#39;Hello world!&#39;);\n    }\n};\n<\\/code><\\/pre>\n<p>在这个文件里我们 export 了一个叫做 <code>MyAwesomePlugin<\\/code> 的类。其中有一个 <code>apply()<\\/code> 方法，它表示在 webpack 初次加载完此插件的时候应该做的事情，也就是只会在 webpack 启动的时候被执行一次。接下来如果我们监听 compile 的事件等等，首先就要在这里写一下；假如我们的插件依赖于一个 express 的后端服务器，那么我们也可以在 <code>apply()<\\/code> 里初始化 express。<\\/p>\n<p>然后我们试着应用这个插件，在你的 <code>webpack.config.js<\\/code> 中：<\\/p>\n<pre><code class=\"js\">const MyAwesomePlugin = require(&#39;.\\/MyAwesomePlugin&#39;);\n\n\\/\\/ ...\n\nplugins: [\n    \\/\\/ ...\n    new MyAwesomePlugin()\n]\n<\\/code><\\/pre>\n<p>然后尝试着启动 webpack，如果一切正常，你应该在 console 中看到 <code>Hello, world!<\\/code> 了。<\\/p>\n<p>接下来我们就开始做实事了，回头看看我们的需求，这是一个需要前后端配合的工作，首先我们需要在后端拥有一个 socket 服务器，然后监听 webpack 每次编译完后的结果，把信息通过这个 socket 服务器发送到浏览器。要实现这一步，还需要浏览器加载和后端服务器通信的相关 JS.启动 socket 服务器这件事我们在 <code>apply()<\\/code> 方法中完成就可以了，接下来是事件监听。<\\/p>\n<p>说到事件监听，首先这里要区分一下 webpack 中的两个概念：<code>compiler<\\/code> 和 <code>compilation<\\/code>.<\\/p>\n<hr>\n<h2 id=\"compiler\"><a href=\"#compiler\" class=\"headerlink\" title=\"compiler\"><\\/a>compiler<\\/h2><p>首先你一定已经注意到上文的代码中，<code>apply()<\\/code> 方法传入了一个叫 <code>compiler<\\/code> 的参数。这个所谓的 <code>compiler<\\/code> 对象从字面意思上看是编译器的意思，实际上它也就指向了当前运行的 webpack 实例。这个实例包含了 webpack 的所有 options, loaders 和 plugins, 它随着 webpack 的启动而产生，可以说是 webpack 的“灵魂”。当我们运用一个插件时（即插件类被实例化，同时类中的 <code>apply()<\\/code> 方法被调用的时候），<code>apply()<\\/code> 方法便会接收到一个指向这个 <code>compiler<\\/code> 的参数，我们可以通过这个 <code>compiler<\\/code> 访问整个 webpack 环境。<\\/p>\n<h3 id=\"compilation\"><a href=\"#compilation\" class=\"headerlink\" title=\"compilation\"><\\/a>compilation<\\/h3><p>对 <code>compiler<\\/code> 有了一定的了解之后，大概我们就可以猜到 <code>compilation<\\/code> 是干什么用的了。所谓 <code>compilation<\\/code> 包含了 webpack 每次 build 后的详细信息，包括编译出的结果、错误信息、模块、编译后的资源、改变的文件和依赖等的当前状态，同时它提供了很多的事件挂钩，以便于插件来执行一些<s>黑魔法<\\/s>。<\\/p>\n<hr>\n<p>具体的 API 可以在上文给出的链接中找到，这里我们直接贴出代码后再解释：<\\/p>\n<pre><code class=\"js\">apply(compiler) {\n    compiler.plugin(&#39;compilation&#39;, this.injectScriptToBundle.bind(this));\n    compiler.plugin(&#39;done&#39;, this.onBuildCompleted.bind(this));\n}\n<\\/code><\\/pre>\n<p>这一段代码中我们监听了 <code>compiler<\\/code> 的两个事件（可以看到我们是用 <code>compiler.plugin(hook, method)<\\/code> 方法注册事件的）：<\\/p>\n<ul>\n<li>第一是在每次文件变动，重新编译的时候，执行 <code>this.injectScriptToBundle()<\\/code> 方法；<\\/li>\n<li>第二是编译完成之后，执行 <code>this.onBuildCompleted()<\\/code> 方法。<\\/li>\n<\\/ul>\n<p>根据方法名我们大致可以构想一下，前一个方法用于把前端与后端交互用的 JS 代码注入到 bundle 中（显然，我们是不会直接把这样的调试用代码写到源代码里的），后一个方法大概就是把编译完成之后异常信息发送出去了。<\\/p>\n<p>我们先来看看 <code>injectScriptToBundle()<\\/code> 方法：<\\/p>\n<pre><code class=\"js\">injectScriptToBundle(compilation) {\n    compilation.mainTemplate(&#39;startup&#39;, source =&gt; {\n        return &quot;\\nconsole.log(&#39;Hello world!&#39;);\\n&quot; + source;\n    });\n}\n<\\/code><\\/pre>\n<p>我已经截掉了一些对这篇文章没有什么用的代码。首先我们可以看到这个方法有一个参数，而这个参数正是上文提到的 <code>compilation<\\/code>. 这一段代码的作用就是在即将编译的源代码的开头部分插入一段我们自定义的 JS 代码。<\\/p>\n<p>对了，这里面出现了一个 <code>mainTemplate<\\/code> 方法，具体可以看看 webpack 的官方文档：<a href=\"https:\\/\\/webpack.js.org\\/api\\/plugins\\/template\\/#src\\/components\\/Sidebar\\/Sidebar.jsx\" target=\"_blank\" rel=\"external\">https:\\/\\/webpack.js.org\\/api\\/plugins\\/template\\/#src\\/components\\/Sidebar\\/Sidebar.jsx<\\/a><\\/p>\n<p>然后接下来我们只需要在 <code>onBuildCompleted()<\\/code> 方法中获取并向前端发送信息即可：<\\/p>\n<pre><code class=\"js\">onBuildCompleted(stats) {\n    const detail = stats.toJson({\n        errorDetails: false\n    });\n\n    this.sendWarnings(statsJson.warnings);\n    this.sendErrors(statsJson.errors);\n}\n<\\/code><\\/pre>\n<p>忽略掉发送信息那部分的代码，我们只要看上半部分就好了。<code>stats<\\/code> 参数随着 <code>compiler<\\/code> 的 <code>done<\\/code> 事件被触发后产生，包含本次编译的结果统计信息。它提供了一个 <code>toJson()<\\/code> 方法，可以把这些信息转换成直观的 JSON，然后我们也就可以从这个 JSON 里拿到我们想要的内容了。<\\/p>\n<p>做好了这一切之后，大概已经实现了我们的目标了。上文的示例代码可以在<a href=\"https:\\/\\/github.com\\/moefront\\/webpack-plugin-console-to-browser\" target=\"_blank\" rel=\"external\">这里<\\/a>找到。<\\/p>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"><\\/a>推荐阅读<\\/h1><ul>\n<li>细说webpack之流程篇：<a href=\"http:\\/\\/www.cnblogs.com\\/yxy99\\/p\\/5852987.html\" target=\"_blank\" rel=\"external\">http:\\/\\/www.cnblogs.com\\/yxy99\\/p\\/5852987.html<\\/a><\\/li>\n<li>Compiler and Compilation: <a href=\"https:\\/\\/webpack.js.org\\/development\\/how-to-write-a-plugin\\/#compiler-and-compilation\" target=\"_blank\" rel=\"external\">https:\\/\\/webpack.js.org\\/development\\/how-to-write-a-plugin\\/#compiler-and-compilation<\\/a><\\/li>\n<li>Accessing the compilation: <a href=\"https:\\/\\/webpack.js.org\\/development\\/how-to-write-a-plugin\\/#accessing-the-compilation\" target=\"_blank\" rel=\"external\">https:\\/\\/webpack.js.org\\/development\\/how-to-write-a-plugin\\/#accessing-the-compilation<\\/a><\\/li>\n<li>webpack 插件开发简要：<a href=\"http:\\/\\/www.cnblogs.com\\/sampapa\\/p\\/6958166.html\" target=\"_blank\" rel=\"external\">http:\\/\\/www.cnblogs.com\\/sampapa\\/p\\/6958166.html<\\/a><\\/li>\n<\\/ul>\n",
      "excerpt": "<p>之前为了尝试实现 <a href=\"https:\\/\\/kotori.love\">dalao<\\/a> 的一个 idea，浅浅地踩了一下 webpack 插件开发的坑。今天才想起来，趁着有时间，应该整理一下开发 webpack 插件的思路。<\\/p>",
      "slug": "webpack-plugin-developing-tutorial",
      "published": true,
      "layout": "post",
      "path": "blog/post/webpack-plugin-developing-tutorial/",
      "permalink": "https://kirainmoe.com/blog/post/webpack-plugin-developing-tutorial/",
      "tags": [
        {
          "name": "frontend",
          "slug": "frontend",
          "path": "tags/frontend/",
          "permalink": "https://kirainmoe.com/tags/frontend/",
          "length": 4
        },
        {
          "name": "webpack",
          "slug": "webpack",
          "path": "tags/webpack/",
          "permalink": "https://kirainmoe.com/tags/webpack/",
          "length": 3
        }
      ],
      "categories": []
    },
    {
      "title": "八月のif",
      "date": "2017-08-26T10:27:16.000Z",
      "modified": "2018-01-07T05:18:27.776Z",
      "content": "<p>炎夏的阳光在远处悠悠荡荡地摇曳<br>注视着西下的夕阳 心中无限遐思<br>倘若当初我们没有相遇相识<br>等待着我们的会是怎样的夏天呢<br><a id=\"more\"><\\/a><br>想象着 （这不一样的夏天）<br>大家追寻着 （各自的梦想）<br>可是真的会 变成那样吗<br>到底还是会 在某一天 走到一起的吧<\\/p>\n<p>这熠熠生辉的 八月的遐想<br>来探索这转瞬即逝的夏天的秘密吧<br>就这样下去 屏住呼吸就好<br>放弃那遐想吧 把当下紧紧拥入怀中吧<\\/p>\n<hr>\n<p><em>算下来已经很久没有在自己的博客里写过日记了。自从换了 Hexo 之后惊喜地发现某辣鸡爬虫站（对，就是那个叫什么推酷的）终于不爬我的文章了，所以就可以没有后顾之忧地在这里写一点什么乱七八糟的东西了。一直以来都认认真真并且很谨慎地在写博客的每一篇文章，是时候加点什么不一样的东西了。<\\/em><br>这个八月很快就要结束了。八月，对于很多孩子们来说大概是很令人享受的暑假时光，只不过这个八月对我来说似乎并没有什么特别的地方，除了过完这个月距离 2017 年高考倒计时又少了好几天罢了。<br>是的，过完这个八月，我就真的正式踏进高三的门了。所以从另一个角度来说，这也是我人生中意义最非凡的一个八月之一了吧。<br>过去的二十多天里经历了很多的事情。接踵而来的来自四面八方的打击，失去了陪伴自己很久的东西……以及其它无法一一列举的让人不愉快的事情。我大概就是那种只有在心情很糟糕的时候才会有想法的人，所以说每次情绪低落的时候，我都会想写点什么东西。有时候把自己的想法通过文字表达出来会让自己好受很多，但是自己的文笔又非常烂，以至于总是有时候心血来潮想到哪里写到哪里的时候突然就不知道往下要怎么动笔了，只好又把自己的那些负情绪咽回去。<\\/p>\n<hr>\n<p><div id=\"muse-container\"><\\/div><\\/p>\n<script type=\"text\\/javascript\">\n    var playlist = [{\n        title: '八月のif',\n        artist: 'Poppin\\'Party',\n        cover: 'https:\\/\\/dn-iidream.qbox.me\\/_20170820_081434.jpg',\n        src: 'https:\\/\\/dn-iidream.qbox.me\\/%E5%85%AB%E6%9C%88%E3%81%AEif-Poppin%20Party.mp3',\n        lyric: '[by:吟梦]\\n[00:20.58](香澄) 陽炎がゆらゆら揺れてる\\n[00:27.06]沈む太陽を見つめながら考えてた\\n[00:36.49](沙綾) 私達もしも出会えてなかったなら\\n[00:42.84]どんな夏が待っていたんだろう\\n[00:50.18](香澄) 違う夏\\n[00:52.43](沙綾) 探してた\\n[00:54.28](香澄) それぞれ\\n[00:56.29](香澄＆沙綾) 夢追いかけた\\n[00:58.53](香澄) でもホントに\\n[01:00.50](沙綾) そうなのかな\\n[01:02.19](香澄) やっぱりね\\n[01:04.20](沙綾) いつかは\\n[01:06.20](香澄＆沙綾) 出会ってたのかな\\n[01:10.66]煌めいた八月のif\\n[01:18.37](香澄) 短い夏の\\n[01:20.90](沙綾) 秘密捜し\\n[01:23.62](香澄＆沙綾) に行こうよ\\n[01:26.36](香澄＆沙綾) 息を止めてそのままでいて\\n[01:34.22](香澄) もしかじゃない\\n[01:35.71](沙綾) 今を\\n[01:37.38](香澄＆沙綾) 抱きしめている',\n        translation: '炎夏的阳光在远处悠悠荡荡地摇曳\\n注视着西下的夕阳 心中无限遐思\\n倘若当初我们没有相遇相识\\n等待着我们的会是怎样的夏天呢\\n想象着\\n这不一样的夏天\\n大家追寻着\\n各自的梦想\\n可是真的会\\n变成那样吗\\n到底还是会\\n在某一天\\n走到一起的吧\\n这熠熠生辉的 八月的遐想\\n来探索\\n这转瞬即逝的夏天的\\n秘密吧\\n就这样下去 屏住呼吸就好\\n放弃那遐想吧\\n把当下\\n紧紧拥入怀中吧'\n    }];\n    var player = MUSE.render(playlist, document.getElementById('muse-container'), {\n        layout: 'muse-layout-landscape'\n    });\n    MUSE.changeState(player.id, 'volume', 0.75);\n\n\n    function is_pc() {\n        var userAgentInfo = navigator.userAgent;\n        var Agents = [\"Android\", \"iPhone\",\n        \"SymbianOS\", \"Windows Phone\",\n        \"iPad\", \"iPod\"];\n        var flag = true;\n        for (var v = 0; v < Agents.length; v++) {\n            if (userAgentInfo.indexOf(Agents[v]) > 0) {\n                flag = false;\n                break;\n            }\n        }\n        return flag;\n    }\n\n    if (is_pc()) {\n        MUSE.togglePlay(player.id);\n    }\n<\\/script>\n\n<p>这是 《BanG Dream! OVA》 里的一首插曲《八月のif》，可以算是目前为止 Poppin’Party 的歌里我最喜欢的一首了，尽管还没有出完整版。<br>抛开作画崩什么的，真心觉得这部动漫 &amp; 企划不错。推 PPP 让我找到了刚开始推缪那一会的那种感觉，这也是我对<s>梦幻少女乐队<\\/s>这个企划评价很高的原因之一。也许有梦想之人的故事是最能打动人的了吧，无论是追逐那一束的光的穗乃果和 μ’s，还是幻想、仰望着星空的香澄和 popipa.<\\/p>\n<p>真正的梦想，应该就是像这样，哪怕是在别人眼中的再不切实际、再难以达成，也要咬紧牙关去尝试实现它的吧。这样的梦想不仅仅是一种单纯的利益驱动型的动力，更多的是一种信仰。<\\/p>\n<p>我？大概也有一个藏了很久的所谓“不切实际”的梦呢。<\\/p>\n<hr>\n<p>初中毕业快要三年，初中班级群总是安安静静的，最长的纪录是半年没人讲一句话，最后打破沉默的是同学的 QQ 号被盗之后群发的诈骗信息。今天，这个沉默了很久的群突然在会话列表里冒了出来。初中的班主任（之前也是从来不怎么说话的）发了一条信息。<\\/p>\n<p>她说，亲爱的同学们，你们已经是高三的学生了，大家要用自己的智慧和勤奋去走进人生的大礼堂。要杀出气魄，杀出豪迈。<br>看到她说的话那会儿我还是被震撼到了。震撼的不只是毕业三年她仍然记得我们，记得她当年带过的班级（当时我们那一届和她的关系确实还不错），我对其中一句话很有感触，宁可是不快乐的少年，也不要委曲求全的成年。<\\/p>\n<p>高三确实很累。有很多漏洞需要去修补，有很多东西需要去巩固，于此同时你还要继续接触和吸收很多新的内容，日复一日，直到第二年的六月，将会是一个很枯燥很无聊的过程。每每想到这将会是个很漫长的过程，就很想放弃。可是从另一个角度想，努力熬过这个漫长、无聊、“不快乐”的过程，总比明年委曲求全来的值得。这可能就是人为什么要把眼光放的远一点的原因吧，如果只图去追求眼前的片刻的安逸，将来真的会后悔和愧疚比这一段时间长不知道多少倍。<\\/p>\n<hr>\n<p>感觉自己度过了一个很奇葩的高中三年，比起班级里其他普通的高中同学来说我算是比较特殊的，因为过去的两年当中一直在“学业”和“竞赛”的两头徘徊。最终竞赛的结果大都不尽人意，倒是给我带来了一些很珍贵和难忘的经历。今年 11 月过后，算是可以抛开除了学业之外的全部的杂念了。也算是一种解脱吧。<br>自己的拖延症和总是把事情做一半就丢下的问题，是时候该改一改了。<br>总是觉得自己的时间不够用，也许是时候对自己的时间有更严格的规划了。<\\/p>\n<p>虽然身边的人都很理解很支持，但是无论周围的人怎样说“高三你不是一个人”，归根结底高三还是自己一个人的战役。无论是挑灯夜读还是最终坐在考场上的那个人都是你自己，不是其他任何一个人。<br>一定要学会适应这种孤独呢。<\\/p>\n<p>我有时候在想，我如果能像我对待和接触前端这么热忱，能像我写博客这么谨慎和一丝不苟去对待我的学习就好了。也许我真的应该这么尝试着做一下。<\\/p>\n<hr>\n<p>从六点半开始对着编辑器，想了很多事情，一直在删删改改，最后才发现把我脑子里那些零碎的感觉和想法拼凑出来也不过是篇连事情都讲不清楚的语无伦次日记。这一刻我有些犹豫要不要删掉这一篇乱七八糟毫无逻辑的日记，但是想了想我还是决定留下它。正如我说的那样，“博客是将我本人性格最真实地体现得最淋漓尽致的地方”。<\\/p>\n<p>好了，那就这样吧，反正没有人看。如果有人忍着各种吐槽耐心地看我说一堆废话读到这儿的话，那么希望你和我能在接下来的日子里努力朝着自己的梦想前行，让这个八月的遐想成为现实吧。<\\/p>\n<p>共勉。<\\/p>\n",
      "excerpt": "<p>炎夏的阳光在远处悠悠荡荡地摇曳<br>注视着西下的夕阳 心中无限遐思<br>倘若当初我们没有相遇相识<br>等待着我们的会是怎样的夏天呢<br>",
      "slug": "hachigatsu-no-if",
      "published": true,
      "layout": "post",
      "path": "blog/post/hachigatsu-no-if/",
      "permalink": "https://kirainmoe.com/blog/post/hachigatsu-no-if/",
      "tags": [
        {
          "name": "diary",
          "slug": "diary",
          "path": "tags/diary/",
          "permalink": "https://kirainmoe.com/tags/diary/",
          "length": 3
        },
        {
          "name": "life",
          "slug": "life",
          "path": "tags/life/",
          "permalink": "https://kirainmoe.com/tags/life/",
          "length": 1
        }
      ],
      "categories": []
    },
    {
      "title": "每周解题报告 (3rd, 8/14~8/20)",
      "date": "2017-08-20T06:43:46.000Z",
      "modified": "2018-01-07T05:18:35.157Z",
      "content": "<p>这周主要是尝试了一些新的东西（ 做了一些之前一直想看但是一直没看懂和没做的题目。依旧是做 HDU 的题。虽然写得不是很熟练，不过慢慢来应该也是可以的。<br>另外下周由于要阶段考试这样子，可能就没有时间做题目了。<\\/p>\n<a id=\"more\"><\\/a>\n<div class=\"muse-app\"><\\/div>\n\n<script type=\"text\\/javascript\">\nvar playList = [{\n    title: 'やくそく',\n    artist: '三森すずこ \\/ 花澤香菜',\n    src: 'https:\\/\\/api.kotori.love\\/netease\\/mp3?id=488256626',\n    cover: 'http:\\/\\/p1.music.126.net\\/9uq04GzHBnhhJCgQTccq_Q==\\/19012755067719433.jpg',\n    lyric: '[by:lyricshare]\\n[00:25.93]さよならじゃない今未来が始まるんだ\\n[00:37.23]淡い蕾は花開いて祝福を歌う\\n[00:48.93]秘密の場所に埋めたのは\\n[00:54.65]密かな夢と宝の地図\\n[01:00.94]時間巡りを閉じ込めた\\n[01:06.41]小さなガラスの欠片だった\\n[01:11.87]あの時 君は君は勇気を得た\\n[01:17.79]友を信じ抜く勇気を得た\\n[01:23.80]永遠に消えない誇りになるだろう\\n[01:29.83]最後の鐘が響き出す\\n[01:35.33]たとえ涙が落ちてしまうとしても\\n[01:41.03]下を向いたりしないと誓おう\\n[01:47.39]そっと重ねた思い出の数だけ\\n[01:53.20]光ゆらめいて背中を押した\\n[02:05.22]流れ続ける砂時計のような時よ\\n[02:16.67]翼広げてさあ飛び立とう地平線の果て\\n[02:28.44]あどけなかった横顔が\\n[02:34.10]凛々しくなったはいつの日か\\n[02:40.03]速まる日々に負けぬよう\\n[02:45.85]毎日夢中で追いかけてた\\n[02:51.57]あの時君は君は希望を見た\\n[02:57.28]暗闇に浮かぶ 希望を見た\\n[03:03.14]行き先照らす明かりになるだろう\\n[03:09.24]もう迷うことはないんだ\\n[03:14.94]いつか傷つくことがあるとしても\\n[03:20.64]友がくれた言葉を胸に\\n[03:27.03]傷を癒して進み続けるよ\\n[03:32.70]きっとその先でまた会えるから\\n[04:01.90]あの時君は君は勇気を得た\\n[04:07.50]友を信じ抜く勇気を得た\\n[04:13.36]永遠に消えない誇りになるだろう\\n[04:19.78]最後の鐘が響き出す\\n[04:24.82]たとえ 涙が落ちてしまうとしても\\n[04:30.82]下を向いたりしないと誓おう\\n[04:37.28]そっと重ねた思い出の数だけ\\n[04:42.95]光ゆらめいて背中を押した\\n[04:54.83]あのね ありがとう またあの場所で',\n    translation: '这并不是永别 未来从现在才开始\\n含苞待放的花蕾盛开 颂唱祝福之歌\\n在秘密场所里埋藏的是\\n潜藏于心的梦想与藏宝图\\n将反复的时间紧闭门中\\n化成了小小的玻璃碎片\\n那时候 是你让我获得了勇气\\n让我获得了坚信朋友的勇气\\n它会成为我永不消逝的骄傲吧\\n终结的钟声响起\\n让我们发誓 即便再流下眼泪\\n也不再低下头\\n只有那默默积累下的记忆\\n在虚渺的光芒中一直支持着我\\n时间仿佛不断流逝的沙漏\\n张开双翼 向着地平线的尽头翱翔吧\\n你那天真烂漫的侧脸\\n不知在何时已变得如此冷酷严峻\\n为了不输给忙碌的生活\\n每日都不顾一切地追赶\\n在那时 是你让我看见了希望\\n让我看见了在黑暗中浮现的希望\\n它会成为我通向终点的照明灯吧\\n我已经不会再次迷失自我了\\n即便在未来某刻会受伤\\n朋友托付于我的咒语 也会在我心中\\n治愈着我的伤痕 让我向前迈进\\n一定会在前方再次相遇吧\\n那时候 是你让我获得了勇气\\n让我获得了坚信朋友的勇气\\n它会成为我永不消逝的骄傲吧\\n终结的钟声响起\\n让我们发誓 即便再流下眼泪\\n也不再低下头\\n只有那默默积累下的记忆\\n在虚渺的光芒中一直支持着我\\n我想对你说 谢谢你 让我们再次在那个地方相遇吧'\n}];\n\nMUSE.render(playList, document.querySelector('.muse-app'));\n<\\/script>\n\n<h1 id=\"8-200-HDU5489-Removed-Interval\"><a href=\"#8-200-HDU5489-Removed-Interval\" class=\"headerlink\" title=\"8\\/200, HDU5489, Removed Interval\"><\\/a>8\\/200, HDU5489, Removed Interval<\\/h1><h2 id=\"题意-amp-扯淡\"><a href=\"#题意-amp-扯淡\" class=\"headerlink\" title=\"题意 &amp; 扯淡\"><\\/a>题意 &amp; 扯淡<\\/h2><p>题意就是已知一个数列，从中删除连续的 n 个数，然后要使得删除完之后它的最长上升子序列最大。n &lt;= 1e5.<\\/p>\n<p>这题好像有很多的解法，有用传统 LIS 做的，还有用 LIS + BIT 或者 LIS + Segment Tree 做的……后面两种做法没能理解（说实话，第一种做法也没怎么能理解），所以我还是硬着头皮看了一下直接做的。<\\/p>\n<h2 id=\"所谓题解\"><a href=\"#所谓题解\" class=\"headerlink\" title=\"所谓题解\"><\\/a>所谓题解<\\/h2><p>因为要从数列中删除一些数之后求 LIS，然后就是我们枚举删除的数的终点，然后对终点右边的第一个数为起点求一次 LIS<br>然后再从最左边到删除的起点求一次 <strong>最大的数不超过终点右边第一个数<\\/strong> 的 LIS<br>从右往左的这个 LIS 必须在枚举起点之前预处理求出，所以：<br>从右往左求 LIS 可以用负数的方法来做，然后倒着求回来，一直从 n 求到 l 为止。<\\/p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"><\\/a>代码<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nusing namespace std;\n\nconst int MAXN = 1e5 + 10;\nconst int INF = 1e9 + 7;\n\nint kases, tmp;\nint n, l;\nint a[MAXN], b[MAXN], dp[MAXN], LIS[MAXN];\n\nint main()\n{\n  scanf(&quot;%d&quot;, &amp;kases);\n\n  while (kases--)\n  {\n    tmp++;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;l);\n\n    fill(dp, dp + MAXN, INF);\n\n    for (int i = 0; i &lt; n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;a[i]);\n      b[i] = -a[i];\n    }\n\n    \\/\\/ reverse LIS\n    int pos = 0;\n    fill(LIS, LIS + MAXN, INF);\n\n    for (int i = l; i &gt;= l; i--)\n    {\n      pos = lower_bound(LIS, LIS + n, b[i]) - LIS;\n      LIS[pos] = b[i];\n      dp[i] = pos + 1;\n    }\n\n    int ans = 0, maxlen = 0;\n    fill(LIS, LIS + MAXN, INF);\n    for (int i = l; i &lt; n; i++)\n    {\n      pos = lower_bound(LIS, LIS + n, a[i]) - LIS;      \\/\\/ from left to right\n      ans = max(ans, pos + 1 + dp[i] - 1);        \\/\\/ &gt;=\n\n      pos = lower_bound(LIS, LIS + n, a[i - l]) - LIS;    \\/\\/ update left LIS\n      LIS[pos] = a[i-l];\n      maxlen = max(maxlen, pos + 1);\n    }\n    ans = max(ans, maxlen);\n    printf(&quot;Case #%d: %d\\n&quot;, tmp, ans);\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"9-200-HDU1074-Doing-Homework\"><a href=\"#9-200-HDU1074-Doing-Homework\" class=\"headerlink\" title=\"9\\/200, HDU1074, Doing Homework\"><\\/a>9\\/200, HDU1074, Doing Homework<\\/h1><h2 id=\"扯淡\"><a href=\"#扯淡\" class=\"headerlink\" title=\"扯淡\"><\\/a>扯淡<\\/h2><p>DP，而且不是一般的 DP……是状压 DP 的说。这种 DP 也不是很好理解也很难想……主要还是要写题积累经验。算是我的第一道状压吧 QAQ，之前一直以为状压 DP 涉及各种二进制和位操作挺可怕的……看理论什么的也一直看不太懂。<\\/p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"><\\/a>题解<\\/h2><p>嘛……这是我有生以来写过的第一道状态压缩 DP 的题……第一眼看到 N &lt;= 15 就有种不好的预感 2333……<\\/p>\n<p>状态压缩嘛，就是把 DP 中用到的状态用二进制来表示，然后就这道题目理解了一下状态压缩 DP 的基本的写法，下面是我稍微总结的一下状态压缩 DP 的框架：<\\/p>\n<pre><code>const MAXN = 最大的状态点数目\nconst MAXS = 1 &lt;&lt; MAXN            \\/\\/ 最多的状态数，表示 2^MAXN 个\nvar dp[MAXS]                \\/\\/ DP 数组\n\nread n\n\nfor (i = 1...(1 &lt;&lt; n))            \\/\\/ 枚举每个用二进制表示的状态\n    for (j = 0....n)            \\/\\/ 枚举每一个点\n        var cur = 1 &lt;&lt; j        \\/\\/ 当前点用二进制表示后的整数\n    if (i &amp; cur)            \\/\\/ 判断当前状态是否合法，即当前枚举的状态 (i) 必须包含当前枚举的点 (cur)\n            var last = i - cur        \\/\\/ 这一步是可选的，如果你要获得当前状态的上一个状态\n                    \\/\\/ 那么可以用当前枚举的状态减去当前枚举的点的二进制状态\n\n            dp equation            \\/\\/ 那么现在就可以开始你的 DP 方程了\n\nprint dp[(1 &lt;&lt; n) - 1]            \\/\\/ 最终答案就是 dp[(1 &lt;&lt; n) - 1] 了\n<\\/code><\\/pre><p>然后说回到这一题上吧。题意就是某人要做好多的作业，每个作业有一个上交期限 deadline 和需要花费的时间 cost。如果每超过一天上交就扣一分，然后让你求出扣分最少的方案并输出字典序最小的方案。<\\/p>\n<p>由于最多只有 15 个状态点，那么用二进制表示这 15 个状态点的话，十进制的数不会超过 2^15 = 32768，所以我们想到用状压 DP 来解。那么，设整数 i 为用二进制表示了当前状态然后转换后的十进制数，然后我们就可以开一个数组 dp[1…MAXS] 来表示对于每个状态扣的分最少是多少，这里我们用二进制来表示状态，即用 0 来表示未完成这个作业，1 表示已完成这个作业。然后我们就可以从低位向高位填充来表示是否坐过这个作业了。<\\/p>\n<p>例如说有 5 门作业，你做了 第一门、第二门和第五门，那么用二进制表示就是 10011，然后转成十进制数就是 19.<\\/p>\n<p>我们用 i 枚举当前状态，然后再枚举一维 j 表示当前枚举的状态点（每一科的作业），当 i 状态包含了当前状态点的时候我们就可以根据我们的 DP 方程对 dp 数组进行更新。具体地，我们可以判断 i &amp; (1 &lt;&lt; j) 是否等于 1 的结果来看，如果等于 1 的话那么 i 状态就完成了第 j 门功课。<\\/p>\n<p>dp 方程如下（不要忘记转移的同时更新时间）：<\\/p>\n<pre><code>dp[i].score = dp[prev].score + max(dp[prev].time + lesson[j].cost - lesson[j].deadline, 0)\n<\\/code><\\/pre><p>我们记 curscore = 在完成第 j 门作业前的上一个状态（可以用 i - (1 &lt;&lt; j) 来求得上一个状态）已经花费掉的时间 + 做当前作业需要花费的时间 - 当前作业的 deadline，那么 curscore 有两种情况：1. 当 curscore &gt; 0 的时候，就是当前决策会被扣掉的分数；2. 当 curscore &lt;= 0 的时候，表明当前决策还不会被扣分，但是提早上交作业也不会加分，所以我们要把它设为 0.<\\/p>\n<p>然后呢看题目要求除了输出最小代价之外还要输出方案，那么我们可以用一个结构体来表示当个状态，除了记录代价 score 和所用时间 times 外还需要记录上一个状态 prev 和当前的科目 subject. 利用最终答案是 dp[(1 &lt;&lt; n) - 1] 这个性质，我们就可以通过 prev 回溯回去输出方案了，具体的做法就是从最终状态往前搜寻，并把它们加入一个栈中。然后你知道怎么做了。<\\/p>\n<p>还有一个要注意的地方就是边界处理，不然会无限 WA。<\\/p>\n<h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"><\\/a>代码<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \n\nusing namespace std;\n\nconst int MAXN = 15;\nconst int MAXS = 1 &lt;&lt; MAXN;\nconst int INF = 1e9 + 7;\n\nstruct Lesson {\n  int deadline;\n  int need;\n  char name[105];\n};\n\nstruct State {\n  int day;\n  int doing;\n  int score;\n  int previous;\n};\n\nLesson les[MAXN];\nState dp[MAXS];\n\nint cases;\nint n, l;\n\nint main()\n{\n  scanf(&quot;%d&quot;, &amp;cases);\n  while (cases--)\n  {\n    memset(dp, 0, sizeof(dp));\n\n    scanf(&quot;%d&quot;, &amp;n);\n\n    for (int i = 0; i &lt; n; i++)\n    {\n      cin &gt;&gt; les[i].name &gt;&gt; les[i].deadline &gt;&gt; les[i].need;\n    }\n\n    int terminal = 1 &lt;&lt; n;\n\n    \\/\\/ state-compressing\n    for (int i = 1; i &lt; terminal; i++)\n    {\n      dp[i].score = INF;\n      for (int j = n - 1; j &gt;= 0; j--)\n      {\n        int current = 1 &lt;&lt; j;\n        if (i &amp; current)\n        {\n          int prev = i - current;     \\/\\/ previous state\n          int score = dp[prev].day + les[j].need - les[j].deadline;\n          if (score &lt; 0)\n            score = 0;\n\n          int newState = score + dp[prev].score;\n          if (newState &lt; dp[i].score)\n          {\n            dp[i].score = newState;\n            dp[i].day = dp[prev].day + les[j].need;\n            dp[i].previous = prev;\n            dp[i].doing = j;\n          }\n        }\n      } \\/\\/ for j = n-1 =&gt; 0\n    } \\/\\/ for i = 1 =&gt; terminal\n\n    printf(&quot;%d\\n&quot;, dp[terminal - 1].score);\n\n    \\/\\/ print solutions\n    stack&lt;int&gt; solutions;\n    int cur = terminal - 1;\n    while (cur != 0)\n    {\n      solutions.push(dp[cur].doing);\n      cur = dp[cur].previous;\n    }\n\n    while (!solutions.empty())\n    {\n      printf(&quot;%s\\n&quot;, les[solutions.top()].name);\n      solutions.pop();\n    }\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"10-100-HDU3192-Hamburger-Magi\"><a href=\"#10-100-HDU3192-Hamburger-Magi\" class=\"headerlink\" title=\"10\\/100, HDU3192, Hamburger Magi\"><\\/a>10\\/100, HDU3192, Hamburger Magi<\\/h1><h2 id=\"题意-amp-扯淡-1\"><a href=\"#题意-amp-扯淡-1\" class=\"headerlink\" title=\"题意 &amp; 扯淡\"><\\/a>题意 &amp; 扯淡<\\/h2><p>第二道状压。具体的题意看题解吧，其实这些解题报告都是我把写完一题的时候 YY 出来的题解拼出来的，所以就不想浪费时间排版什么的了，看得懂找得到就行。<\\/p>\n<h2 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"><\\/a>题解<\\/h2><p>感觉状态压缩的题目写的还是不太多，然后就没有那种感觉……不过经过上一题之后看到这道题就有些靠谱的思路了，虽然因为掉进了上一题的思维定式里然后 WA 了好几回 QAQ……<\\/p>\n<p>这一题的话，题意大概就是要做汉堡包，然后每个汉堡包有自己的价值 v（下文用 val 表示） 和制作所需要的能量 e（用 cost 表示），总共可以消耗的能量为 E. 再然后就是有些种类的汉堡包可能有“依赖”，也即在做他们之前需要有些汉堡包已经做好了。每种汉堡包最多做一个，然后综合上述条件，求出满足题意的最大价值 maxVal. 1 &lt;= n &lt;= 15.<\\/p>\n<p>老规律，看到 n &lt;= 15 就想到状态压缩 DP。这道题和上一题有个比较不一样的地方在于，上一题是根据当前枚举到的状态作为已知，而当前状态的先前一个状态未知，所以是从后向前推的；这道题是把当前枚举到的状态作为已知，当前状态的下一个状态未知，然后要从前向后推。<\\/p>\n<p>我们记 i 为当前汉堡种类的状态，用 j 表示下一个状态相较当前状态多做的汉堡种类，在 DP 之前我们先要判断条件是否合适。由于这题当中有一个“依赖”的概念，又有一个能量的限定，所以我们在判断 DP 状态是否合法的时候要注意一下。由于前一个“依赖”的限定是硬性的，也就是这个限制只能在我们 DP 下一个状态之前先判断当前状态能否推出下一个状态；但是对于“能量”这个限定就显得比较宽松，我们既可以边 DP 边剪枝，把所需能量大于总能量的解答直接剪掉；也可以暂时不剪掉，但是记录它们的花费（尽管有时候该花费已经超过了总能量），然后在 DP 完成之后循环一遍 dp 数组，这个时候就可以很方便地根据 dp[i].cost 来判断状态是否合法了，因为这个值已经固定下来不会改变了，所以我们可以在状态合法的前提下更新答案。网上的题解大致也分这两种写法，我觉得后面一种比较好理解也好写，所以我们用第二种做法。<\\/p>\n<p>至于判断依赖是否满足的话，我们遍历 j 的每一个依赖 deps[j][x]，如果 (i &amp; (1 &lt;&lt; j 的每一个依赖))，说明当前状态合法，可以由当前状态推向下一个状态；反之则不能从当前状态通过做第 j 个汉堡包达到下一个状态。<\\/p>\n<p>DP 方程如下，设 items[j] 为第 j 种汉堡的信息，i 为在 n 个不同的状态点的二进制状态转换成的十进制数，那么：<\\/p>\n<pre><code>dp[i | (1 &lt;&lt; j)].val = dp[i].val + items[j].val, dp[i | (1 &lt;&lt; j)].cost = dp[i].cost + items[j].cost;\n<\\/code><\\/pre><p>这里的 (1 &lt;&lt; j) 表示一个“只做当前枚举的第 j 个汉堡的二进制状态”，i 是当前状态，由于 (1 &lt;&lt; j) 二进制下只有第 j 位是 1 其他都是 0（注意这里 j 的下标是从 0 开始的），所以 i 与 1 &lt;&lt; j 按位或返回的结果就是下一个状态。<\\/p>\n<p>做完 DP 之后循环一遍 dp 数组更新 ans 就可以了： <code>ans = max(ans, dp[i].val), 其中 dp[i].cost &lt;= E.<\\/code><\\/p>\n<h2 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"><\\/a>代码<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt;\nusing namespace std;\n\nconst int MAXN = 15;\nconst int MAXS = 1 &lt;&lt; 15;\nconst int INF = 1e9 + 7;\n\nstruct Hamburger {\n  int val;\n  int cost;\n  int dep;\n  int deps[15];\n};\nHamburger items[MAXN];\n\nstruct State {\n  int val;\n  int cost;\n};\nState dp[MAXS];\n\nint cases;\nint n, e;\n\nint main()\n{\n  scanf(&quot;%d&quot;, &amp;cases);\n\n  while (cases--)\n  {\n    memset(items, 0, sizeof(items));\n    memset(dp, -1, sizeof(dp));\n\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;e);\n    for (int i = 0; i &lt; n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;items[i].val);\n    }\n    for (int i = 0; i &lt; n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;items[i].cost);\n    }\n    for (int i = 0; i &lt; n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;items[i].dep);\n      if (items[i].dep &gt; 0)\n      {\n        for (int j = 0; j &lt; items[i].dep; j++)\n        {\n          scanf(&quot;%d&quot;, &amp;items[i].deps[j]);\n          items[i].deps[j]--;\n        }\n      }\n    } \\/\\/ end read\n\n    int end = 1 &lt;&lt; n;\n    int ans = 0;\n\n    dp[0].cost = 0, dp[0].val = 0;\n\n    for (int i = 0; i &lt; end; i++)\n    {\n      if (dp[i].cost == -1)\n        continue;\n\n      for (int j = 0; j &lt; n; j++)\n      {\n        int cur = 1 &lt;&lt; j;\n        if (!(i &amp; cur))\n        {\n          int next = i | cur;\n\n          bool flag = true;\n          if (items[j].dep &gt; 0)\n          {\n            for (int x = 0; x &lt; items[j].dep; x++)\n            {\n              int depState = 1 &lt;&lt; items[j].deps[x];\n              if (!(i &amp; depState)) {\n                flag = false;\n                break;\n              }\n            } \\/\\/ for x = 0 -&gt; items[j].dep\n          } \\/\\/ if items[j].dep &gt; 0\n\n          if (flag)\n          {\n            dp[next].val = dp[i].val + items[j].val;\n            dp[next].cost = dp[i].cost + items[j].cost;\n          }\n\n        } \\/\\/ if i &amp; cur\n      } \\/\\/ for j = 0 -&gt; n\n    } \\/\\/ for i = 1 -&gt; end\n\n    for (int i = 0; i &lt; end; i++)\n    {\n      if (dp[i].cost &lt;= e)\n        ans = max(ans, dp[i].val);\n    }\n\n    printf(&quot;%d\\n&quot;, ans);\n\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"11-200-HDU1520-Anniversary-Party\"><a href=\"#11-200-HDU1520-Anniversary-Party\" class=\"headerlink\" title=\"11\\/200, HDU1520, Anniversary Party\"><\\/a>11\\/200, HDU1520, Anniversary Party<\\/h1><h2 id=\"题意-amp-扯淡-2\"><a href=\"#题意-amp-扯淡-2\" class=\"headerlink\" title=\"题意 &amp; 扯淡\"><\\/a>题意 &amp; 扯淡<\\/h2><p>树形 DP 入门题，是之前突然想学学树形 DP 的时候找到的。题意大概就是一个宴会上要邀请员工，每个员工都有一个开心指数，只有在宴会上见不到自己的直属上司的时候才会开心，然后要求出开心指数的最大值。<\\/p>\n<h2 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"><\\/a>题解<\\/h2><p>这道题有个很坑的地方就是它一个样例有好多个子任务，但是它什！么！都！没！说！ <\\/p>\n<ul>\n<li>然后我交了 7 遍还是不知道为什么 WA 的……找了个 std 一看，卧槽要处理多组数据……<\\/li>\n<\\/ul>\n<p>设 dp[i][0] 为不邀请第 i 个人的最大值， dp[i][1] 为邀请第 i 个人的最大值。如果我们邀请了第 i 个人，那么我们就不能邀请第 i 个人的直接下属，但是他的直接下属的下属是可以邀请的……然后按照这个思路转移方程就出来了。<\\/p>\n<p>首先要建树，然后这里我采用的是用图的保存方法，直接用了 vector<int>[MAXN] 数组来存第 i 个人的直接下属。首先找到树根，也就是入度为 0 的（没有父亲或者说父亲是本身的）那个节点 Q，然后以此节点为起点做一遍 DFS，边 DFS 边状态转移，之后输出答案就好了。<\\/int><\\/p>\n<p>状态转移方程如下：<\\/p>\n<pre><code>dp[i][0] = max(dp[k1][0], dp[k1][1]) + ... + max(dp[kx][0], dp[kx][1])\n\\/\\/ 其中 k1 ... kx 是第 i 个员工的所有直属下属的下标\n\ndp[i][1] = dp[k1][0] + dp[k2][0] + ... + dp[kx][0]\n\\/\\/ 假如第 i 个员工要出席宴会，这种情况下他的直接下属都不能参加\n<\\/code><\\/pre><p>然后答案就是 <code>ans = max(dp[Q][0], dp[Q][1]);<\\/code>.<\\/p>\n<h2 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"><\\/a>代码<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nusing namespace std;\n\nconst int MAXN = 6010;\nint n;\nint rate[MAXN], p[MAXN];\nint dp[MAXN][2];\nvector&lt;int&gt; T[MAXN];\n\nvoid dfs(int s)\n{\n  if (T[s].size() == 0)\n  {\n    dp[s][1] = rate[s];\n    dp[s][0] = 0;\n    return;\n  }\n\n  for (int i = 0; i &lt; T[s].size(); i++)\n  {\n    int cur = T[s][i];\n    dfs(cur);\n    dp[s][0] += max(dp[cur][1], dp[cur][0]);\n    dp[s][1] += dp[cur][0];\n  }\n  dp[s][1] += rate[s];\n  return;\n}\n\nint main()\n{\n  while (scanf(&quot;%d&quot;, &amp;n) != EOF)\n  {\n    memset(rate, 0, sizeof(rate));\n    memset(p, 0, sizeof(p));\n    memset(dp, 0, sizeof(dp));\n\n    for (int i = 0; i &lt;= MAXN; i++)\n    {\n      T[i].clear();\n    }\n\n    for (int i = 1; i &lt;= n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;rate[i]);\n    }\n\n    int x, y;\n    while (scanf(&quot;%d%d&quot;, &amp;x, &amp;y) != EOF &amp;&amp; x != 0 &amp;&amp; y != 0)\n    {\n      T[y].push_back(x);\n      p[x] = y;\n    }\n\n    int s;\n    for (int i = 1; i &lt;= n; i++)\n    {\n      if (p[i] == 0)\n      {\n        s = i;\n        break;\n      }\n    }\n\n    dfs(s);\n    int ans = max(dp[s][0], dp[s][1]);\n    printf(&quot;%d\\n&quot;, ans);    \n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"12-200-HDU1166-敌兵布阵\"><a href=\"#12-200-HDU1166-敌兵布阵\" class=\"headerlink\" title=\"12\\/200, HDU1166, 敌兵布阵\"><\\/a>12\\/200, HDU1166, 敌兵布阵<\\/h1><p>题意自己看原题吧 Orz 反正是中文的，这题用 BIT 和单点修改的线段树都可以做，是个裸的板子题。记一下这道题的板子代码以防将来需要。<\\/p>\n<h2 id=\"BIT-version\"><a href=\"#BIT-version\" class=\"headerlink\" title=\"BIT version\"><\\/a>BIT version<\\/h2><p>因为只有单点修改，所以用树状数组完全可以胜任。<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt;\n\nconst int MAXN = 50005;\nint n;\nint c[MAXN];\n\nint lowbit(int x)\n{\n  return x &amp; (-x);\n}\n\nvoid add(int i, int value)\n{\n  while (i &lt;= n)\n  {\n    c[i] += value;\n    i += lowbit(i);\n  }\n}\n\nint sum(int x)\n{\n  int res = 0;\n  while (x &gt; 0)\n  {\n    res += c[x];\n    x -= lowbit(x);\n  }\n  return res;\n}\n\nint main()\n{\n  int t;\n  scanf(&quot;%d&quot;, &amp;t);\n\n  for (int i = t; i &gt; 0; i--)\n  {\n    printf(&quot;Case %d:\\n&quot;, t - i + 1);\n    scanf(&quot;%d&quot;, &amp;n);\n    memset(c, 0, sizeof(c));\n\n    for (int j = 1; j &lt;= n; j++)\n    {\n      int x;\n      scanf(&quot;%d&quot;, &amp;x);\n      add(j, x);\n    }\n\n    char str[10];\n    int x, y;\n    while (scanf(&quot;%s&quot;, str) != EOF &amp;&amp; str[0] != &#39;E&#39;)\n    {\n      scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\n      if (str[0] == &#39;Q&#39;) {\n        int res = sum(y) - sum(x-1);\n        printf(&quot;%d\\n&quot;, res);\n      }\n\n      if (str[0] == &#39;A&#39;) {\n        add(x, y);\n      }\n\n      if (str[0] == &#39;S&#39;) {\n        add(x, -y);\n      }\n    }\n\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n<h2 id=\"Segment-Tree-version\"><a href=\"#Segment-Tree-version\" class=\"headerlink\" title=\"Segment Tree version\"><\\/a>Segment Tree version<\\/h2><p>线段树的单点修改区间查询版也可以做这题，如下。写起来会比树状数组的版本麻烦一些。记得一个很重要的地方就是线段树的数组要开到 MAXN 的 4 倍。<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nconst int MAXN = 50010;\n\nint n;\nint kases, tmp;\n\nstruct SegTree\n{\n  int sum[MAXN &lt;&lt; 2];\n\n  void pushUp(int root) \n  {\n    sum[root] = sum[root * 2] + sum[root * 2 + 1];\n  }\n\n  void build(int left, int right, int root)\n  {\n    if (left == right)\n    {\n      scanf(&quot;%d&quot;, &amp;sum[root]);\n      return;\n    }\n    int middle = (left + right) \\/ 2;\n    build(left, middle, root * 2);\n    build(middle + 1, right, root * 2 + 1); \n\n    pushUp(root);\n  }\n\n  void update(int left, int right, int root, int pos, int addVal)\n  {\n    if (left == right)\n    {\n      sum[root] += addVal;\n      return;\n    }\n    int middle = (left + right) \\/ 2;\n\n    if (pos &lt;= middle)\n    {\n      update(left, middle, root * 2, pos, addVal);\n    }\n    else\n    {\n      update(middle + 1, right, root * 2 + 1, pos, addVal);\n    }\n\n    pushUp(root);\n  }\n\n  int query(int from, int to, int left, int right, int root)\n  {\n    if (from &lt;= left &amp;&amp; right &lt;= to)\n    {\n      return sum[root];\n    }\n\n    int middle = (left + right) \\/ 2;\n\n    int res = 0;\n    if (to &lt;= middle)\n    {\n      res += query(from, to, left, middle, root * 2);\n    }\n    else if (from &gt; middle)\n    {\n      res += query(from, to, middle + 1, right, root * 2 + 1);\n    }\n    else\n    {\n      res += query(from, to, left, middle, root * 2) + query(from, to, middle + 1, right, root * 2 + 1);\n    }\n\n    return res;\n  }\n\n  void init()\n  {\n    for (int i = 0; i &lt; MAXN; i++)\n    {\n      sum[i] = 0;\n    }\n  }\n};\n\nSegTree tree;\n\nint main()\n{\n  scanf(&quot;%d&quot;, &amp;kases);\n\n  while (kases--) \n  {\n    tmp++;\n    printf(&quot;Case %d:\\n&quot;, tmp);\n\n    scanf(&quot;%d&quot;, &amp;n);\n\n    tree.init();\n    tree.build(1, n, 1);\n\n    char commands[20];\n    while (scanf(&quot;%s&quot;, commands) != EOF &amp;&amp; commands[0] != &#39;E&#39;)\n    {\n      if (commands[0] == &#39;Q&#39;)\n      {\n        int x, y;\n        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\n        int res = tree.query(x, y, 1, n, 1);\n        printf(&quot;%d\\n&quot;, res);\n      }\n\n      if (commands[0] == &#39;A&#39;)\n      {\n        int x, y;\n        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n        tree.update(1, n, 1, x, y);\n      }\n\n      if (commands[0] == &#39;S&#39;)\n      {\n        int x, y;\n        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n        tree.update(1, n, 1, x, -y);\n      }\n    }\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n",
      "excerpt": "<p>这周主要是尝试了一些新的东西（ 做了一些之前一直想看但是一直没看懂和没做的题目。依旧是做 HDU 的题。虽然写得不是很熟练，不过慢慢来应该也是可以的。<br>另外下周由于要阶段考试这样子，可能就没有时间做题目了。<\\/p>",
      "slug": "practicing-record-3rd-8-14-8-20",
      "published": true,
      "layout": "post",
      "path": "blog/post/practicing-record-3rd-8-14-8-20/",
      "permalink": "https://kirainmoe.com/blog/post/practicing-record-3rd-8-14-8-20/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "algorithm",
          "slug": "algorithm",
          "path": "tags/algorithm/",
          "permalink": "https://kirainmoe.com/tags/algorithm/",
          "length": 8
        }
      ],
      "categories": []
    },
    {
      "title": "每周解题报告 (2nd, 8/7~8/13)",
      "date": "2017-08-13T08:46:17.000Z",
      "modified": "2018-01-07T05:18:34.286Z",
      "content": "<p>这一周主要在看 DP 的题目，嘛，都是一些我觉得很好<s>但是我写不出来的<\\/s>题。本周的话做的都是 HDU 的题，虽然看了一下 Codeforces 上的一两道这样子。感觉收获还是蛮多的。<\\/p>\n<a id=\"more\"><\\/a>\n<h1 id=\"偶然学到的黑科技\"><a href=\"#偶然学到的黑科技\" class=\"headerlink\" title=\"偶然学到的黑科技\"><\\/a>偶然学到的黑科技<\\/h1><p>在开始正式的记题之前，想先记一下这周做题和看题解的时候新学到的东西。<\\/p>\n<h2 id=\"STL-的-unique\"><a href=\"#STL-的-unique\" class=\"headerlink\" title=\"STL 的 unique()\"><\\/a>STL 的 unique()<\\/h2><p>STL 中提供了一个很方便的去重函数 unique(), 其功能是去除相邻的重复元素（只保留一个），所以使用前需要对数组进行排序。用 unique 之后对于有序数组就不用手动循环去重了。<\\/p>\n<h2 id=\"STL-lower-bound-和-upper-bound\"><a href=\"#STL-lower-bound-和-upper-bound\" class=\"headerlink\" title=\"STL lower_bound() 和 upper_bound()\"><\\/a>STL lower_bound() 和 upper_bound()<\\/h2><p>lower_bound(arr, arr + n, val) 返回在有序数组 arr 的 [0, n) 区间中的第一个不小于 val 的值的地址。<\\/p>\n<p>相反的，upper_bound(arr, arr + n, val) 则返回第一个不小于 val 的值的地址。<\\/p>\n<p>所以，我们可以利用这个好东西：<\\/p>\n<h2 id=\"四行写出最长上升子序列-LIS-的-O-nlogn-解法\"><a href=\"#四行写出最长上升子序列-LIS-的-O-nlogn-解法\" class=\"headerlink\" title=\"四行写出最长上升子序列 (LIS) 的 O(nlogn) 解法\"><\\/a>四行写出最长上升子序列 (LIS) 的 O(nlogn) 解法<\\/h2><p>LIS 的话，传统的写法是 O(n^2) 的，用二分优化过后可以降到 O(nlogn). 至于具体的原理我就不想详细在这里记录了，不然文章又要很长。<\\/p>\n<p>设 arr[] 为要求 LIS 的数列，lis[] 为保存 LIS 的数组。那么我们可以通过下面的代码来求 LIS：<\\/p>\n<pre><code class=\"cpp\">fill(lis, lis + n, INF);\nfor (int i = 0; i &lt; n; i++)\n    *lower_bound(lis, lis + n, arr[i]) = arr[i];\nint len = lower_bound(lis, lis + n, INF) - lis;            \\/\\/ LIS 的长度\n<\\/code><\\/pre>\n<p>简单快捷。<\\/p>\n<h1 id=\"4-200-HDU1024-Max-Sum-Plus-Plus\"><a href=\"#4-200-HDU1024-Max-Sum-Plus-Plus\" class=\"headerlink\" title=\"4\\/200, HDU1024, Max Sum Plus Plus\"><\\/a>4\\/200, HDU1024, Max Sum Plus Plus<\\/h1><h2 id=\"题意-amp-扯淡\"><a href=\"#题意-amp-扯淡\" class=\"headerlink\" title=\"题意 &amp; 扯淡\"><\\/a>题意 &amp; 扯淡<\\/h2><p>DP, 最大 m 子段和。没错题目很眼熟，是 P1003 的升级版，原题是最大连续子段和，这题是 n 子段和。是个挺不错的题目，之所以这么说是因为<s>我不会<\\/s>它的时间和空间限制挺严格的，尤其是空间限制是 32M….emmm….<\\/p>\n<p>题意还是给你一个很长的数列 a1….an，然后让你找出它的 m 个子序列使得这些子序列的总和最大，输出这个总和。1 &lt;= n &lt;= 1e6, m 的范围未知。注意就是求出的区间不能相交。<\\/p>\n<p>和上一题比一个比较人道的地方就是这一题不用输出位置了。但是反而比上一题更难了。看到 32M 的内存限制，反正你想到的不是正解的解法表示状态都需要二维，肯定就 GG 了。这道题的正解是用滚动数组优化，非常巧妙，<s>以至于我到现在还不是很理解。<\\/s><\\/p>\n<p>说的不太清楚，如果没明白的可以看看别人写的。直接从 notepad 复制过来的，不想理通顺了，凑合着看吧。<\\/p>\n<h2 id=\"开始正文\"><a href=\"#开始正文\" class=\"headerlink\" title=\"开始正文\"><\\/a>开始正文<\\/h2><p>虽然这道题的数据范围感人，n &lt;= 1e6, m 未知，内存 32M. 基本上告诉我们的信息就是二维的数组都开不下了，那么肯定要做一些黑科技的优化。但是这道题直接看正解是很难理解的，包括我现在看了正解还是有些地方不太明白，下面的解析是我按自己的理解 YY 的，可能有些地方并不一定对。<\\/p>\n<p>在正解之前，我们先来理解不做没优化的情况。如果抛开限制不谈，那么这道题的状态还是很好表示的。用 dp[i][j] 表示当子区间个数为 i，选取第 j 个数的时候的最大值。<\\/p>\n<p>对于 dp[i][j] 的值有两种决策：<\\/p>\n<p>1.将第 j 个数合并到第 i 个区间，区间个数不变，最大和为 dp[i][j-1]+a[j].<br>2.将第 j 个数单独划一个区间，此时区间个数由 i-1 变为 i，最大和为当区间长度为 i-1 的时候能取到的最大值 (也就是 dp[i-1][k]) 加上 a[j].<\\/p>\n<p>我们可以得到这样的状态转移方程：<\\/p>\n<pre><code>dp[i][j] = max(dp[i][j-1] + a[j], dp[i-1][k] + a[j]), 其中 k∈[i-1, j-1]\n<\\/code><\\/pre><p>也即<\\/p>\n<pre><code>dp[i-1][k] = max(dp[i-1][i-1], dp[i-1][i], ....., dp[i-1][j-1]).\n<\\/code><\\/pre><p>意思是，<strong>dp[i][j] 的取值只和 dp[i][j-1] 和 dp[i-1][k] 有关<\\/strong>。由于 i = 1 =&gt; m，那么我们事实上可以将数组降成两个一维的，也就是运用滚动数组来解这道题目：<\\/p>\n<p>设 d[j] 表示第 j 个数一定取的时候的最大值(dp[i][j])，premax[j] 表示 max(dp[i][i], …, dp[i][j])。那么原方程就可以化为 <code>dp[j] = max(dp[j-1] + a[j], premax[j-1] + a[j]);<\\/code><\\/p>\n<p>我们首先枚举区间的数量，用 curmax 表示当区间个数为 i 的时候能取得的最大值是多少，初始值为 -INF。<\\/p>\n<p>接着，我们枚举剩余的所有没有划分区间的数，每次枚举首先计算 dp[j]，然后再将 premax[j-1] 设为 curmax，然后更新 curmax 的值为 max(curmax, dp[j]). curmax 在这里的作用就相当于表示了 max(dp[i-1][i-1], …, dp[i-1][j-1])，我们可以利用滚动数组边 DP 边计算 curmax，然后把 curmax 更新给 premax 来保存. 全部计算完之后最后的结果就是最后一次更新后的 curmax 值了。<\\/p>\n<p>核心的伪代码如下：<\\/p>\n<pre><code>initialize curmax\nfor (i = 1 =&gt; m)\n    let curmax = -infinity\n    for (j = i =&gt; n)\n        calculate dp[j] = max(dp[j-1] + a[j], premax[j-1] + a[j])\n        update    premax[j-1] = curmax\n        update    curmax = max(dp[j], curmax)\nprint curmax\n<\\/code><\\/pre><h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"><\\/a>代码<\\/h2><pre><code class=\"cpp\">\\/**\n* HDU1024 DP 最大连续 m 区间和 \n*\\/\n#include &lt;bits\\/stdc++.h&gt;\nusing namespace std;\n\nconst int MAXN = 1e6 + 10;\nconst int INF = 1e9 + 7;\n\nint n, m;\nint a[MAXN];\nint dp[MAXN];\nint premax[MAXN];\n\nint main()\n{\n  while (scanf(&quot;%d%d&quot;, &amp;m, &amp;n) != EOF)\n  {\n    for (int i = 1; i &lt;= n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;a[i]);\n    }\n\n    for (int i = 0; i &lt;= n; i++)\n    {\n      dp[i] = 0;\n      premax[i] = 0;\n    }\n\n         \\/\\/ start solution\n    int curmax;\n    for (int i = 1; i &lt;= m; i++)\n    {\n      curmax = -INF;\n      for (int j = i; j &lt;= n; j++)\n      {\n        dp[j] = max(dp[j-1] + a[j], premax[j-1] + a[j]);\n        premax[j-1] = curmax;\n        curmax = max(curmax, dp[j]);\n      }\n    }\n\n    printf(&quot;%d\\n&quot;, curmax);\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"5-200-HDU1028-Ignatius-and-the-Princess-III\"><a href=\"#5-200-HDU1028-Ignatius-and-the-Princess-III\" class=\"headerlink\" title=\"5\\/200, HDU1028, Ignatius and the Princess III\"><\\/a>5\\/200, HDU1028, Ignatius and the Princess III<\\/h1><h2 id=\"题意-amp-扯淡-1\"><a href=\"#题意-amp-扯淡-1\" class=\"headerlink\" title=\"题意 &amp; 扯淡\"><\\/a>题意 &amp; 扯淡<\\/h2><p>依旧是 DP，虽然传闻有母函数的做法，但是本蒟蒻不知道也不会写什么母函数。题意大概就是给你一个整数 n，然后你看看这个整数 n 有多少种划分方法，例如说:<\\/p>\n<blockquote>\n<p>4 = 4<br>  = 3 + 1<br>  = 2 + 2<br>  = 2 + 1 + 1<br>  = 1 + 1 + 1 +1<\\/p>\n<\\/blockquote>\n<p>所以 4 有 5 种划分方法。<\\/p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"><\\/a>正文<\\/h2><p>题意就是整数划分嘛，给定一个整数 n，求 n 有多少种分法，然后不能重复。<\\/p>\n<p>一开始都没想到是 DP 题……为什么可以用 DP 呢，一定是因为有重复计算的步骤啦。比如说我们要划分整数 4，把 4 划分到 3+1 的时候，显然 3 还能再往下划分，那么我们就可以直接利用之前已经计算过的结果了。<\\/p>\n<p>网上现成的 DP 题解大概有两种说法，但是状态转移方程是一样的。这个方程挺好写，但是不好想。<\\/p>\n<p>第一种解法是设 dp[i][j] 为将整数 i 划分为<strong>最多 j 个数的和<\\/strong>的时候最多的方案数量。我觉得这种方案不太好理解，尤其是分类讨论的时候。所以以下分析以第二种解法为基础：设 dp[i][j] 为将整数 i 划分为<strong>不超过 j 的数的和<\\/strong>的时候最多的方案数量。<\\/p>\n<p>  1) 显然，当 i = 1 的时候，区间长度只能是 1，那么只有一种方法，也即 dp[1][1] = 1.<\\/p>\n<p>  2) 当 i &lt; j 的时候，由于不可能出现“目标数是 i，但是 j(j &gt; i) 是 i 的一个加数”的情况，所以我们让 dp[i][j] = dp[i][i].<\\/p>\n<p>  3) 当 i = j 的时候，dp[i][j] = dp[i][j-1] + 1<\\/p>\n<p>   (1) 用不超过 j 的整数划分的时候，我们考虑是否要分出 j 这个数，如果要分的话由于 n = m 那么只有一种方案，就是 m 本身（对应状态转移方程中的 1），如果不分，那么就是继承 dp[i][j-1] 的结果，即把 i 分成最大加数不超过 j-1 的多少份。<\\/p>\n<p>  (2) 如果我们用第一种解法来理解这个式子，那么 dp[i][j] = 将 i 分成 j-1 段的方案数最大值 + 将 i 分成 j 段的方案数，由于 i = j，那么将 i 分成 j 段只有一种方案，就是有 j 个 1 的情况。<\\/p>\n<p>  4) 当 i &gt; j 的时候，也是最不好理解的一个部分。这个时候我们可以发现一个包含 i 个数的集合 U={1, 2, 3, …, i} 可以被 j 划分为两部分：一个是 A={j}，一个是 CU(A). 那么这个时候我们可以考虑是否要分出 j 这个数：如果要分出 j，那么我们只要计算剩下来的数的分离方案数，就是 dp[i-j][j]；如果不分，那么答案还是把 i 分成不超过 j-1 的结果，也就是 dp[i][j-1]. 将两种方案相加，我们得到了 dp[i][j] = dp[i-j][j] + dp[i][j-1];<\\/p>\n<p>“这样我们就完美地解决了这个问题。”<\\/p>\n<h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"><\\/a>代码<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt;\nconst int MAXN = 120 + 5;\nint n;\nint dp[MAXN][MAXN];\n\nint main()\n{\n  while (scanf(&quot;%d&quot;, &amp;n) != EOF)\n  {\n    memset(dp, 0, sizeof(dp));\n    for (int i = 1; i &lt;= n; i++)\n    {\n      for (int j = 1; j &lt;= n; j++)\n      {\n        if (i &lt; j)\n        {\n          dp[i][j] = dp[i][i];\n        }\n        if (i == j)\n        {\n          dp[i][j] = dp[i][j-1] + 1;\n        }\n        if (i &gt; j)\n        {\n          dp[i][j] = dp[i][j-1] + dp[i-j][j];\n        }\n      }\n    }\n    printf(&quot;%d\\n&quot;, dp[n][n]);\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"6-200-HDU1025-Constructing-Roads-In-JGShining’s-Kingdom\"><a href=\"#6-200-HDU1025-Constructing-Roads-In-JGShining’s-Kingdom\" class=\"headerlink\" title=\"6\\/200, HDU1025 Constructing Roads In JGShining’s Kingdom\"><\\/a>6\\/200, HDU1025 Constructing Roads In JGShining’s Kingdom<\\/h1><p>还是 DP。懒得翻题意了，自己戳原链接看好了QAQ：<a href=\"http:\\/\\/acm.hdu.edu.cn\\/showproblem.php?pid=1025\" target=\"_blank\" rel=\"external\">http:\\/\\/acm.hdu.edu.cn\\/showproblem.php?pid=1025<\\/a><\\/p>\n<p>也就是在上文提到的最长上升子序列了，但是这一题的话用 O(n^2) 的解法是会 T 的。有两组数嘛，首先对一组排序（当然要保持和另外一组的对应关系），然后对另一组数做 LIS 就可以了。为什么是 LIS 自己画个图就知道了。<\\/p>\n<p>甚至可以，不用排序：在输入的时候只保存一组数据，而把另一组数作为数组的 key 即可，因为两组数是一一对应的，没有一对多的情况。<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt;\nusing namespace std;\n\nconst int MAXN = 5 * 1e5 + 10;\nconst int INF = 1e9 + 10;\n\nint n;\nint ans = 0, kases = 0;\nint maps[MAXN];\nint dp[MAXN];\nint LIS[MAXN];\nint main()\n{\n  while (scanf(&quot;%d&quot;, &amp;n) == 1)\n  {\n    kases++;\n\n    \\/\\/ read data\n    for (int i = 1; i &lt;= n; i++)\n    {\n      int x, y;\n      scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n      maps[x] = y;\n    }\n\n    \\/\\/ initialize\n    for (int i = 0; i &lt;= n; i++)\n    {\n      dp[i] = 0;\n      LIS[i] = INF;\n    }\n    dp[0] = 0;\n\n    \\/\\/ LIS\n    for (int i = 1; i &lt;= n; i++)\n    {\n      *lower_bound(LIS + 1, LIS + 1 + n, maps[i]) = maps[i];\n    }\n    ans = lower_bound(LIS + 1, LIS + 1 + n, INF) - LIS - 1;\n\n    printf(&quot;Case %d:\\n&quot;, kases);\n    printf(&quot;My king, at most %d &quot;, ans);\n    if (ans == 1)\n    {\n      printf(&quot;road can be built.\\n&quot;);\n    }\n    else\n    {\n      printf(&quot;roads can be built.\\n&quot;);\n    }\n    printf(&quot;\\n&quot;);\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n<p>以下是自己写的时候顺手 YY 的注释:<\\/p>\n<blockquote>\n<p>\\/**<\\/p>\n<ul>\n<li>附 nlogn 版的 LIS 写法：<\\/li>\n<li>设 LIS[MAXN] 为此数列的取得 LIS 最大值时的 LIS 一种可能的情况；<\\/li>\n<li>首先把 LIS 数组设为 INF：fill(LIS + 1， LIS + 1 + n, INF) ;<\\/li>\n<li>然后遍历数列，利用 lower_bound 函数二分查找到 LIS 中第一个不大于 a[i] 的值的位置 pos，<\\/li>\n<li>然后把 LIS[pos] 设为 a[i]. 也即 *lower_bound(LIS + 1, LIS + 1 , n, a[i]) = a[i];<\\/li>\n<li>最后统计 LIS 中不是 INF 的值的个数就可以了，即 ans = lower_bound(LIS + 1, LIS + 1 + n, INF);<br>*\\/<\\/li>\n<\\/ul>\n<\\/blockquote>\n<h1 id=\"6-1-HDU1029-Ignatius-and-the-Princess-IV\"><a href=\"#6-1-HDU1029-Ignatius-and-the-Princess-IV\" class=\"headerlink\" title=\"6.1, HDU1029, Ignatius and the Princess IV\"><\\/a>6.1, HDU1029, Ignatius and the Princess IV<\\/h1><p>之所以是 6.1 是因为这题实在是太。水。了。不是一般的水。要不是某个题目分类的帖子里说这题是 DP，我才不会做呢（<\\/p>\n<pre><code class=\"cpp\">\\/**\n* HDU1029 水题，谁说是 DP 的给我出来我保证打不死你 \n* 明明是这么简单的计数题！！ \n*\\/\n#include &lt;bits\\/stdc++.h&gt; \nconst int MAXN = 1e6 + 5;\nint data[MAXN];\nint main()\n{\n  int n, flag;\n  while (scanf(&quot;%d&quot;, &amp;n) != EOF)\n  {\n    bool state = true;\n    flag = (n + 1) \\/ 2;\n\n    memset(data, 0, sizeof(data));\n\n    for (int i = 0; i &lt; n; i++)\n    {\n      int x;\n      scanf(&quot;%d&quot;, &amp;x);\n      data[x]++;\n      if (data[x] &gt;= flag &amp;&amp; state)\n      {\n        printf(&quot;%d\\n&quot;, x);\n        state = false;\n      }\n    }\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"6-5-200-HDU1232-畅通工程\"><a href=\"#6-5-200-HDU1232-畅通工程\" class=\"headerlink\" title=\"6.5\\/200, HDU1232, 畅通工程\"><\\/a>6.5\\/200, HDU1232, 畅通工程<\\/h1><p>畅通工程系列的第一题，这是一道裸的并查集 OvO. 只要理解并查集的都会写啦。题目有个“温馨提示”，但是并不影响我们做题，管他什么多条道路连接的输入合不合法呢。<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \n\nconst int MAXN = 1e3 + 10;\nint p[MAXN];\nint n, m;\nint cnt = 0;\n\nvoid init()\n{\n  cnt = 0;\n  for (int i = 0; i &lt; MAXN; i++)\n  {\n    p[i] = i;\n  }\n}\n\nint find(int x)\n{\n  return x == p[x] ? x : p[x] = find(p[x]);\n}\n\nvoid unions(int x, int y)\n{\n  int px = find(x),\n      py = find(y);\n  if (px == py)\n  {\n    return;\n  }\n  else\n  {\n    p[px] = py;\n    cnt++;\n  }\n}\n\nint main()\n{\n  while (scanf(&quot;%d&quot;, &amp;n) != EOF &amp;&amp; n != 0)\n  {\n    init(); \n    scanf(&quot;%d&quot;, &amp;m);\n    for (int i = 0; i &lt; m; i++)\n    {\n      int x, y;\n      scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n      unions(x, y);\n    }\n    printf(&quot;%d\\n&quot;, (n - 1 - cnt));\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<p>剩下的是一些旧题重做的，然后就不贴上来了。<\\/p>\n",
      "excerpt": "<p>这一周主要在看 DP 的题目，嘛，都是一些我觉得很好<s>但是我写不出来的<\\/s>题。本周的话做的都是 HDU 的题，虽然看了一下 Codeforces 上的一两道这样子。感觉收获还是蛮多的。<\\/p>",
      "slug": "practicing-record-2nd-8-7-8-13",
      "published": true,
      "layout": "post",
      "path": "blog/post/practicing-record-2nd-8-7-8-13/",
      "permalink": "https://kirainmoe.com/blog/post/practicing-record-2nd-8-7-8-13/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "algorithm",
          "slug": "algorithm",
          "path": "tags/algorithm/",
          "permalink": "https://kirainmoe.com/tags/algorithm/",
          "length": 8
        }
      ],
      "categories": []
    },
    {
      "title": "每周解题报告 (1st, 8/3~8/6)",
      "date": "2017-08-07T04:49:06.000Z",
      "modified": "2018-01-07T05:18:33.532Z",
      "content": "<p>RT. 接下来打算在 11 月份之前刷个 200 题的算法题（包括线上和线下）……然后想着就是开个帖子来整理和记录题解什么的，大概能碰到电脑的话那就每周一篇这样子。<\\/p>\n<p>这一阶段的话主要是挑 <a href=\"http:\\/\\/acm.hdu.edu.cn\\/\" target=\"_blank\" rel=\"external\">HDUOJ<\\/a> 的题目来做（因为可以找到详细的题目分类），会从简单的题目开始（<s>比如 A+B Problem<\\/s>），然后辅以一些 Codeforces 的题。之前那个 LeetCode 的记录帖就这么弃坑了（<\\/p>\n<a id=\"more\"><\\/a>\n<h1 id=\"1-200-HDU1003-Max-Sum\"><a href=\"#1-200-HDU1003-Max-Sum\" class=\"headerlink\" title=\"1\\/200, HDU1003, Max Sum\"><\\/a>1\\/200, HDU1003, Max Sum<\\/h1><p>题意大概是给一个很长的数列，有正有负，然后要求这个数列的子序列的和的最大值。然后范围大概是 1e5 以内。有个比较迷的地方就是不仅要求最大值，而且还要求出取得最大值的时候，子区间的位置。时间 1s, 内存 64M.<\\/p>\n<p>第一反应是不是区间 DP 的题啊，然后看了一下数据范围果断把这个白痴的想法扔回肚子里去了。子序列最大值倒是会求啊，但是一开始没有反应过来要怎么统计位置。后来想了一下，开不下二维数组那我开一维的总可以了吧。所以这就是一道最大连续子区间和的动态规划问题了。<\\/p>\n<p>设 <code>dp[i]<\\/code> 表示以 <code>a[i]<\\/code> 为区间终点时能取到的和的最大值，然后开两个辅助数组 <code>left[i]<\\/code> 和 <code>right[i]<\\/code> 来表示当取到这个最大值的时候的区间左界和右界分别在哪里，然后最后 for 一遍统计最大值就做完了。需要注意这里一个地方就是数据可正可负，那么考虑一种情况就是假设 <code>dp[i-1]<\\/code> 小于 0 的时候，那么无论 <code>a[i]<\\/code> 是正数还是负数，显然只取 <code>a[i]<\\/code> 的结果会比取 <code>d[i-1] + a[i]<\\/code> 的结果更优，所以遇到这种情况就要重置一下区间的左右界。<\\/p>\n<p>还有一个要注意的地方就是输出的格式，当时做的时候各种 PE……<\\/p>\n<p>转移方程为 <code>dp[i] = max(dp[i-1] + a[i], a[i])<\\/code>.<\\/p>\n<p>Code:<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nconst int INF = 1e9 + 7;\nconst int MAXN = 1e5 + 10;\n\nint n, sn;\nint a[MAXN];\nint dp[MAXN];\nint left[MAXN], right[MAXN];\n\nvoid init()\n{\n  for (int i = 0; i &lt; MAXN; i++)\n  {\n    dp[i] = -INF;\n    left[i] = 0;\n    right[i] = 0;\n  }\n}\n\nint main()\n{\n  scanf(&quot;%d&quot;, &amp;n);\n  sn = n;\n\n  int tmp = 1;\n  while (sn--)\n  {\n    printf(&quot;Case %d:\\n&quot;, tmp++);\n    init();\n\n    int num;\n    scanf(&quot;%d&quot;, &amp;num);\n    for (int i = 0; i &lt; num; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;a[i]);\n    }\n\n    dp[0] = a[0], left[0] = 0, right[0] = 0;\n    for (int i = 1; i &lt;= num; i++) \n    {\n      \\/\\/ 遇到负数的时候重新计数 \n      if (dp[i-1] &lt; 0)\n      {\n        left[i] = right[i] = i;\n        dp[i] = a[i];\n        continue;\n      }\n\n      dp[i] = dp[i-1] + a[i];\n      left[i] = left[i-1];\n      right[i] = i;\n    }\n\n    int maximum = -INF;   \\/\\/ 维护最大值\n    int l, r;\n    for (int i = 0; i &lt; num; i++) \n    {\n      if (dp[i] &gt; maximum)\n      {\n        maximum = dp[i];\n        l = left[i], r = right[i];\n      }\n    }\n\n    printf(&quot;%d %d %d\\n&quot;, maximum, l+1, r+1);\n\n    if (tmp-1 != n)\n      printf(&quot;\\n&quot;);\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"2-200-HDU1004-Let-the-Balloon-Raise\"><a href=\"#2-200-HDU1004-Let-the-Balloon-Raise\" class=\"headerlink\" title=\"2\\/200, HDU1004, Let the Balloon Raise\"><\\/a>2\\/200, HDU1004, Let the Balloon Raise<\\/h1><p>题意就是已知有 n 个气球和它们的颜色，然后要问最受欢迎的气球（也就是出现次数最多的颜色种类）是哪个，颜色用字符串表示且长度不超过 15，有多个子任务，且对于每个子任务保证只有一个合法答案。<\\/p>\n<p>嘛，简单的字符串计数嘛。这个用什么方法达到都可以的，你开心就好了。在这里我是用一个奇怪的做法，首先用 STL 的 string 保存每个气球的颜色，然后再按字典序用 <code>sort()<\\/code> 排序一下，最后就可以很方便地统计出出现次数最多的那种气球来了。<\\/p>\n<p>Code:<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nusing namespace std;\nconst int MAXN = 1010;\nstring balloons[MAXN];\nint main()\n{\n  int num;\n  int maximum, tmp, handle;\n\n  while (scanf(&quot;%d&quot;, &amp;num) != EOF &amp;&amp; num != 0)\n  { \n    for (int i = 0; i &lt; num; i++)\n    {\n      cin &gt;&gt; balloons[i];\n    }\n    sort(balloons, balloons + num);\n\n    maximum = 0, tmp = 0, handle = 0;\n    for (int i = 1; i &lt; num; i++)\n    {\n      if (balloons[i] != balloons[i-1])\n      {\n        tmp = 1;\n      }\n      else\n      {\n        tmp++;\n      }\n\n      if (tmp &gt; maximum)\n      {\n        maximum = tmp;\n        handle = i;\n      }\n    }\n    cout &lt;&lt; balloons[handle]  &lt;&lt; endl;\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"3-200-HDU1005-Number-Sequence\"><a href=\"#3-200-HDU1005-Number-Sequence\" class=\"headerlink\" title=\"3\\/200, HDU1005, Number Sequence\"><\\/a>3\\/200, HDU1005, Number Sequence<\\/h1><p>题意是对于一个函数 f(n), 满足 f(1) = 1, f(2) = 1, f(n) = (A <em> f(n-1) + B <\\/em> f(n-2)) % 7, 然后求对于给定的 A, B 和 N, f(N) 的值是多少。1 &lt;= n &lt;= 1e8, 有多个子任务。<\\/p>\n<p>看数据范围我想没人敢一个一个算过去吧……而且还有好多个子任务，直接就 T 了。<\\/p>\n<p>这题的话一看我就猜到是递推……手推了 7 个之后发现好像没有什么规律……开始怀疑人生.jpg 后来才知道，因为结果要模 7，那么对于 f(n-1) 有 7 种可能的值 (0-6)，对于 f(n-2) 也是有 7 种可能的值，那么 f(n-1) 和 f(n-2) 一共有 7^2=49 种不同的组合可能，也就是最多 49 次就会出现一个循环节……找到循环节，接下来就可以直接算 f(N) 了，然后就做完了。<\\/p>\n<p>做的时候不知道为啥各种 RE，把计算输出的那部分改了一下就 AC 了。<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nint arr[55];\nint main()\n{\n  arr[0] = 1, arr[1] = 1;\n\n  int a, b, n;\n  int pot = 0;\n  while (scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;n) != EOF &amp;&amp; n != 0)\n  {\n    int pot;\n    for (int i = 2; i &lt;= 54; i++)\n    {\n      arr[i] = (a * arr[i-1] + b * arr[i-2]) % 7;\n      if (arr[i] == 1 &amp;&amp; arr[i-1] == 1)\n      {\n        pot = i;\n        break;\n      }\n    }\n\n    n = n % (pot-1);\n\n    if (n == 0)\n    {\n      printf(&quot;%d\\n&quot;, arr[pot-2]);\n    }\n    else\n    {\n      printf(&quot;%d\\n&quot;, arr[n-1]);\n    }\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n",
      "excerpt": "<p>RT. 接下来打算在 11 月份之前刷个 200 题的算法题（包括线上和线下）……然后想着就是开个帖子来整理和记录题解什么的，大概能碰到电脑的话那就每周一篇这样子。<\\/p>\n<p>这一阶段的话主要是挑 <a href=\"http:\\/\\/acm.hdu.edu.cn\\/\">HDUOJ<\\/a> 的题目来做（因为可以找到详细的题目分类），会从简单的题目开始（<s>比如 A+B Problem<\\/s>），然后辅以一些 Codeforces 的题。之前那个 LeetCode 的记录帖就这么弃坑了（<\\/p>",
      "slug": "practicing-record-1st-8-3-8-6",
      "published": true,
      "layout": "post",
      "path": "blog/post/practicing-record-1st-8-3-8-6/",
      "permalink": "https://kirainmoe.com/blog/post/practicing-record-1st-8-3-8-6/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "algorithm",
          "slug": "algorithm",
          "path": "tags/algorithm/",
          "permalink": "https://kirainmoe.com/tags/algorithm/",
          "length": 8
        }
      ],
      "categories": []
    }
  ],
  "menu": {
    "Home": "/",
    "Guestbook": "/pages/guestbook/",
    "Friends": "/pages/friends/",
    "About": "https://about.me/kirainmoe"
  },
  "socials": {
    "twitter": "https://twitter.com/yume_kankawa",
    "github": "https://github.com/kirainmoe",
    "weibo": "https://weibo.com/returnnnn",
    "medium": "https://medium.com/@kotori",
    "lastfm": "https://www.last.fm/user/kirainmoe"
  },
  "avatar": "https://secure.gravatar.com/avatar/c47187d311099868de825697fa419654?s=200&r=G",
  "menuIcon": {
    "Home": "home",
    "Guestbook": "book",
    "Friends": "users",
    "Archives": "tags",
    "About": "id-card-o"
  },
  "disqus": "yume-diary",
  "prev": 1,
  "next": 3
}</script>
  <!-- hook node of React -->
  <div id="himawari-app"></div>

  
    <!-- scripts list from theme config.yml -->
    
      <script src="https://unpkg.com/muse-player/dist/assets/muse-player.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/prism.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-clike.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-php.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-css.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-c.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-cpp.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-javascript.min.js"></script>
    
      <script src="/common.js"></script>
    
      <script src="/main.js"></script>
    
  

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-111347233-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-111347233-1');
  </script>

</body>
</html>
