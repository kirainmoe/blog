<!-- Himawari no Yakusoku -->

<!DOCTYPE html>
<html lang="Zh-cn">
<head>
  <meta charset="UTF-8">
  <meta name="theme-color" content="#FF98A8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>奇怪的道路 (FCS2017 D2T1) [ YumeのDiary ]</title>
  <meta name="description" content="6 年間、共に歩んでくれたあなたへ。">
  <link rel="manifest" href="/manifest.json">
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    
      <link rel="stylesheet" href="/himawari.css">
    
  
</head>
<body>
  
  <!-- infos -->
  <script type="text/json" id="himawari-json">{
  "title": "YumeのDiary",
  "siteTitle": "YumeのDiary",
  "description": "6 年間、共に歩んでくれたあなたへ。",
  "author": "Yume Kankawa",
  "route": "post",
  "format": "blog/:layout/:title/",
  "posts": {
    "title": "奇怪的道路 (FCS2017 D2T1)",
    "date": "2017-07-19T12:12:30.000Z",
    "modified": "2018-07-19T18:04:58.082Z",
    "content": "<p>emmm… FCS2017 夏令营的一道题目……用的是分治的算法，为了题目的一些细节本蒟蒻足足推了两个小时QAQ……所以要写篇文章记录一下不然哪天自己就看不明白了……<\\/p>\n<p>由于我比较啰嗦，以及我太弱了导致文章有可能有一些部分讲错了，所以，大家将就着看一下吧（虽然我不相信有人看）。<\\/p>\n<a id=\"more\"><\\/a>\n<h1 id=\"奇怪的道路\"><a href=\"#奇怪的道路\" class=\"headerlink\" title=\"奇怪的道路\"><\\/a>奇怪的道路<\\/h1><h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"><\\/a>问题描述<\\/h2><p>从前，有一座网格城市，城市中每个房子占据一个正方形小格子的中<br>心，每个正方形小格子的边长均为1。<\\/p>\n<p><img src=\"https:\\/\\/i.loli.net\\/2017\\/07\\/19\\/596f4bfc53442.png\" alt=\"road\"><\\/p>\n<p>这座城市道路的设计方式是这样的，首先，定义(𝑎)图为一个基本图形，其阶为1，之后，将(𝑎)图中每一个房子都用一个基本图形代替，得到(𝑏)图，那么(𝑏)图的阶即为2，再将(𝑏)图中的每一个房子都用基本图形替代，得到阶为3的(c)图，以此类推，只要知道这座城市的阶𝑛，就可以知道它的道路设计。<\\/p>\n<p>这种七拐八弯的道路设计使得这座城市之间的道路交通运输相当不便，于是该市的市长决定改造一下这座城市的道路，但在此之前他需要做一系列的评估，比如这座网格城市中，连接第𝑖1行第𝑗1列的房屋与第𝑖2行第𝑗2列的房屋之间（两座房屋可能相同）的道路有多长，由于这种道路设计太过奇怪，人力难以计算，于是这个任务就交给作为软件工程师的你了。<\\/p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"><\\/a>输入格式<\\/h2><p>每个测试点第一行有两个正整数𝑛, 𝑇，表示城市的阶数和询问数。<br>接下来𝑇行，每行4个正整数𝑖1 𝑗1 𝑖2 𝑗2，表示要查询的两个房屋的坐标。<\\/p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"><\\/a>输出格式<\\/h2><p>对每个询问输出一行相应的值表示答案。<\\/p>\n<h2 id=\"样例输入\"><a href=\"#样例输入\" class=\"headerlink\" title=\"样例输入\"><\\/a>样例输入<\\/h2><blockquote>\n<p>2 4<br>2 1 3 1<br>3 2 2 2<br>2 3 3 3<br>3 4 2 4<\\/p>\n<\\/blockquote>\n<h2 id=\"样例输出\"><a href=\"#样例输出\" class=\"headerlink\" title=\"样例输出\"><\\/a>样例输出<\\/h2><blockquote>\n<p>13<br>11<br>1<br>3<\\/p>\n<\\/blockquote>\n<h2 id=\"样例解释\"><a href=\"#样例解释\" class=\"headerlink\" title=\"样例解释\"><\\/a>样例解释<\\/h2><p>样例对应题目中的(𝑏)图。<br>第一个询问问的是图中编号为2的房子与编号为15的房子的距离。<br>第二个询问问的是图中编号为14的房子与编号为3的房子的距离。<br>第三个询问问的是图中编号为8的房子与编号为9的房子的距离。<br>第四个询问问的是图中编号为10的房子与编号为7的房子的距离。<\\/p>\n<h2 id=\"数据规模\"><a href=\"#数据规模\" class=\"headerlink\" title=\"数据规模\"><\\/a>数据规模<\\/h2><p>Easy：对于30%的数据，1 ≤ 𝑛 ≤ 3。<br>Normal：对于60%的数据，1 ≤ 𝑛 ≤ 8。<br>Hard：对于100%的数据，均有1 ≤ 𝑛 ≤ 15，1 ≤ 𝑖1, 𝑗1, 𝑖2, 𝑗2 ≤ 2𝑛，1 ≤ 𝑇 ≤ 10000。<\\/p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"><\\/a>思路<\\/h2><p>观察题意，不难看出，对于给定的坐标 (x1, y1) 和 (x2, y2)，记他们所对应的房子编号分别为 A, B，要求 A, B 两个房子之间的距离，可以看出<strong>这个距离等于编号A - 编号B 的绝对值<\\/strong>，记这个距离为 x，则我们可以看出：<code>x = abs(A - B)<\\/code>。既然距离是由两个房子的编号唯一决定，那么我们就可以将目标转移到<strong>求这两个坐标对应的房子的编号上<\\/strong>。<\\/p>\n<p>首先看 n 的范围不超过 15，也就是说最大的房子数量不超过 4 ^ 15 = 1073741824，做预处理的话开不下这么大的空间。这启示我们，一定存在一种方法，<strong>对于给定的一个城市坐标 (x, y)，通过这种方法能够直接推算出这个坐标所对应的房子编号<\\/strong>。<\\/p>\n<p>我们先观察这个图：观察当 n &gt;= 2 时候的图形，可以发现图形有这样的规律：基本图形总是会占满整个四分之一矩阵后，才会进入下一个四分之一矩阵。通过这样的规律，我们又能发现这四个被均分的矩阵<strong>具有相似的子结构<\\/strong>，所以我们可以想到——<strong>分！治！<\\/strong><\\/p>\n<p>接下来，目标转移到找到这个方法。题意告诉我们，对于任意已知的 n，以从上到下（行）为 x 轴正方向，以从左到右（列）为 y 轴正方向，第一个房子的坐标一定位于 (1, 1)，第 4^n 个房子一定位于 (2^n+1, 1)，所以根据这个性质我们一定能够推算出这个城市的具体道路规划图。<\\/p>\n<p>问题在于，编号和坐标之间有没有什么关系？<s>当然这种琢磨不透的题目<\\/s>一定不会让你一眼看出这个关系，所以我们需要一点小小的计算：<\\/p>\n<p>首先让我们看当 n = 1，即这个城市只有 1 阶，边长为 2^1=2，房子数 4^1 = 4。根据题意，我们有这样的关系：<\\/p>\n<pre><code>  1     2\n=========\n1 1 --- 2\n        |\n        |\n        |\n2 4 --- 3\n<\\/code><\\/pre><p>可以看到对于这样的矩阵，知道坐标的区间，就可以唯一确定城市的房子了。比如说在这里，(1, 1) 就对应房子 1。至于为什么和怎么确定，我们下面再说。不过说到这里有人还是会对这个 <s>flag<\\/s> 将信将疑：坐标对应的房子可能会受到这个“基本图形”开口的影响，凭什么说它可以唯一确定一个房子的编号？的确，假如它的开口不同，就会导致这个性质是错的。<s>既然如此我们就把这个反例消灭<\\/s>，保证一个子矩阵始终满足这个基本图形的性质。具体地说，对于已知 n = k 的 k 阶矩阵，一定要满足这个性质：<\\/p>\n<blockquote>\n<p>在最左上方取到这个矩阵中数的最小值，并在最左下方取到这个矩阵中数的最大值。<\\/p>\n<\\/blockquote>\n<p>具体的操作，比如说我们看下面的这个图，这也是由基本图形变形而来的：<\\/p>\n<pre><code> 1     4\n |     |\n |     |\n 2 --- 3\n<\\/code><\\/pre><p>那么怎么把它变成基本图形那样，可能大家的第一想法是旋转。但是旋转之后，并不满足在左上取最小值和左下取最大值的性质，所以旋转是不行的。所以我们采取另外一个方法，就是对称。例如上图中，我们取 1, 3 连接而成的对角线为对称轴，将这个图形沿着轴对称，那么这个图形就在还原回基本图形的同时，也保持了这个性质。<\\/p>\n<p>现在又有一个问题。如何知道什么时候对称，沿什么轴来对称？根据分治的思想我们再观察四个图形，我们发现，记当 n=k 的时候边长为 E, 则 E = 2^k，节点数为 N, 则 N = 4^k. 以中点为界将这个矩阵划分为相等的四个部分，<strong>右上角的矩阵和右下角的矩阵会始终保持着这个性质<\\/strong>，那么我们的对称操作只需要对左上和左下的两个矩阵执行就可以了。观察左上和左下的两个矩阵，我们在确定对称轴的时候只需要找到对称后<strong>还原出基本图形及满足其性质<\\/strong>（<s>窝说话太啰嗦了，所以希望你们还记得这个性质<\\/s>）的那一条对称轴即可。再看图形，我们很容易找出，使得左上部分矩阵符合以上性质的对称轴为<strong>从左上到原矩阵中心位置<\\/strong>的这条<strong>对角线<\\/strong>，同样我们为左下矩阵找到的对称轴为<strong>从左下到原矩阵中心位置<\\/strong>的这条<strong>对角线<\\/strong>。<\\/p>\n<p>下面开始用坐标推算房子的编号。我们规定<code>getnum(n, x, y)<\\/code>为<strong>第 n 阶中坐标位于 (x, y) 的房子的编号<\\/strong>，并且规定当 n = 0 的时候，<code>getnum(0, 1, 1) = 1<\\/code>。令 edgeMid = 当前阶的大矩阵边长的一半，有 <code>mid = 2^(n-1)<\\/code>，nodeNum = 当前阶的大矩阵被四均分后的节点数目，有 <code>node = 4^(n-1) = 2^(2n-2)<\\/code>.<\\/p>\n<p>注意到我们刚才提到的性质1：基本图形会先填满一个四分之一矩阵之后，才会进入下一个矩阵。而且无论 n 为何值，进入四个矩阵的先后顺序一定是：左上 =&gt; 右上 =&gt; 右下 =&gt; 左下。所以呢，对于右上的矩阵，编号最小的房子一定是 nodeNum + 1；对于右下的矩阵，编号最小的房子一定是 2 × nodeNum + 1；对于左下的矩阵，编号最小的房子一定是 3 × nodeNum + 1。最大的也很容易推出。<\\/p>\n<p>先从简单的两个子矩阵——也就是不需要做任何对称的两个矩阵入手：对于每个阶段右上和右下这两个不需要做对称操作的部分，其坐标和编号的关系是显然的一个递推式：<\\/p>\n<pre><code>\\/\\/ 右上\nindex = 1 * nodeNum + getnum(n - 1, x, y - edgeMid);\n\n\\/\\/ 右下\nindex = 2 * nodeNum + getnum(n - 1, x - edgeMid, y - edgeMid);\n<\\/code><\\/pre><p>其中进行坐标变换是为了确保起点为 (1, 1)，终点为 (2^n+1, 1)，这样根据坐标推出的编号才会成立。<\\/p>\n<p>进行对称操作的部分的坐标需要进行额外的小变化，因为<strong>进行了对称<\\/strong>，所以我们要<strong>将 x 和 y 进行反转<\\/strong>。同样也要进行坐标变换确保起点为 (1, 1) 和 (2^n+1, 1)。这里要注意一下左下矩阵的边界处理。<\\/p>\n<pre><code>\\/\\/ 左上\nindex = getnum(n - 1, y, x);\n\n\\/\\/ 左下\nindex = 3 * nodeNum + getnum(n - 1, edgeMid + 1 - y, 2 * edgeMid + 1 - x);\n<\\/code><\\/pre><p>注意这里的坐标轴方向是以向下为 x 轴正方向，向右为 x 轴负方向，这样大家画一画草图就可以很容易地推出左下矩阵这个让人看了十分害怕的递推式。<\\/p>\n<p>至此，我们的目的——根据节点坐标推算它的编号——已经达到了。不信的话你可以随便找个点按照上面的递推式试一下。<\\/p>\n<p>以下贴的是参考代码。事实上理解了上面的内容，代码也就不难出来了。<\\/p>\n<h2 id=\"示例代码-C\"><a href=\"#示例代码-C\" class=\"headerlink\" title=\"示例代码 (C++)\"><\\/a>示例代码 (C++)<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nint getNum(int stage, int x, int y)\n{\n  if (stage == 1) {\n    if (x == 1 &amp;&amp; y == 1)\n      return 1;\n    if (x == 1 &amp;&amp; y == 2)\n      return 2;\n    if (x == 2 &amp;&amp; y == 2)\n      return 3;\n    if (x == 2 &amp;&amp; y == 1)\n      return 4;\n  }\n\n  int edgeMid = 1 &lt;&lt; (stage - 1),                    \\/\\/ edgeMid = 2^(stage-1)\n      nodeNum = 1 &lt;&lt; (2 * (stage - 1));   \\/\\/ nodeNum = 4^(stage-1) = 2^2(stage-1)\n\n  if (x &lt;= edgeMid &amp;&amp; y &lt;= edgeMid)\n    return getNum(stage - 1, y, x);\n  if (x &lt;= edgeMid &amp;&amp; y &gt; edgeMid)\n    return nodeNum + getNum(stage - 1, x, y - edgeMid);\n  if (x &gt; edgeMid &amp;&amp; y &gt; edgeMid)\n    return 2 * nodeNum + getNum(stage - 1, x - edgeMid, y - edgeMid);\n  if (x &gt; edgeMid &amp;&amp; y &lt;= edgeMid)\n    return 3 * nodeNum + getNum(stage - 1, edgeMid + 1 - y, 2 * edgeMid + 1 - x);\n\n}\n\nint main()\n{\n  freopen(&quot;road.in&quot;, &quot;r&quot;, stdin);\n  freopen(&quot;road.out&quot;, &quot;w&quot;, stdout);\n\n  int n, T;\n  scanf(&quot;%d%d&quot;, &amp;n, &amp;T);\n\n  while (T--)\n  {\n    int x1, y1, x2, y2;\n    scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);\n    printf(&quot;%d\\n&quot;, abs(getNum(n, x1, y1) - getNum(n, x2, y2)));\n  }\n\n  fclose(stdin);\n  fclose(stdout);\n\n  return 0;\n}\n<\\/code><\\/pre>\n<blockquote>\n<p>这样我们就圆满地解决了这个问题。 —— 题解<\\/p>\n<\\/blockquote>\n<ul>\n<li>原题版权归出题人所有。<\\/li>\n<\\/ul>\n",
    "excerpt": "<p>emmm… FCS2017 夏令营的一道题目……用的是分治的算法，为了题目的一些细节本蒟蒻足足推了两个小时QAQ……所以要写篇文章记录一下不然哪天自己就看不明白了……<\\/p>\n<p>由于我比较啰嗦，以及我太弱了导致文章有可能有一些部分讲错了，所以，大家将就着看一下吧（虽然我不相信有人看）。<\\/p>",
    "slug": "strange-road-fcs2017-d2-solution",
    "published": true,
    "layout": "post",
    "path": "blog/post/strange-road-fcs2017-d2-solution/",
    "permalink": "https://kirainmoe.com/blog/post/strange-road-fcs2017-d2-solution/",
    "tags": [
      {
        "name": "algorithms",
        "slug": "algorithms",
        "path": "tags/algorithms/",
        "permalink": "https://kirainmoe.com/tags/algorithms/",
        "length": 1
      },
      {
        "name": "divide",
        "slug": "divide",
        "path": "tags/divide/",
        "permalink": "https://kirainmoe.com/tags/divide/",
        "length": 1
      }
    ],
    "categories": []
  },
  "menu": {
    "Home": "/",
    "Guestbook": "/pages/guestbook/",
    "Friends": "/pages/friends/",
    "About": "https://about.me/kirainmoe"
  },
  "socials": {
    "twitter": "https://twitter.com/yume_kankawa",
    "github": "https://github.com/kirainmoe",
    "weibo": "https://weibo.com/returnnnn",
    "medium": "https://medium.com/@kotori",
    "lastfm": "https://www.last.fm/user/kirainmoe"
  },
  "avatar": "https://secure.gravatar.com/avatar/c47187d311099868de825697fa419654?s=200&r=G",
  "menuIcon": {
    "Home": "home",
    "Guestbook": "book",
    "Friends": "users",
    "Archives": "tags",
    "About": "id-card-o"
  },
  "disqus": "yume-diary"
}</script>
  <!-- hook node of React -->
  <div id="himawari-app"></div>

  
    <!-- scripts list from theme config.yml -->
    
      <script src="https://unpkg.com/muse-player/dist/assets/muse-player.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/prism.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-clike.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-php.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-css.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-c.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-cpp.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-javascript.min.js"></script>
    
      <script src="/common.js"></script>
    
      <script src="/main.js"></script>
    
  

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-111347233-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-111347233-1');
  </script>

</body>
</html>
