<!-- Himawari no Yakusoku -->

<!DOCTYPE html>
<html lang="Zh-cn">
<head>
  <meta charset="UTF-8">
  <meta name="theme-color" content="#FF98A8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>6 年間、共に歩んでくれたあなたへ。 [ YumeのDiary ]</title>
  <meta name="description" content="6 年間、共に歩んでくれたあなたへ。">
  <link rel="manifest" href="/manifest.json">
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    
      <link rel="stylesheet" href="/himawari.css">
    
  
</head>
<body>
  
  <!-- infos -->
  <script type="text/json" id="himawari-json">{
  "title": "YumeのDiary",
  "siteTitle": "YumeのDiary",
  "description": "6 年間、共に歩んでくれたあなたへ。",
  "author": "Yume Kankawa",
  "route": "index",
  "format": "blog/:layout/:title/",
  "posts": [
    {
      "title": "第三方 Android ROM 无法连接 Google Play 的原因排查",
      "date": "2018-03-04T03:28:44.000Z",
      "modified": "2018-03-04T04:13:21.185Z",
      "content": "<p>现在用的手机已经服役快要四年了，这年头这种的手机大概也就真的只能拿来当手机用了，于是就刷了个第三方适配的 Flyme 好好用着。虽然平时不太从 Google Play 下载软件，必要时也可以用 APKPure 代替，但是聊聊 LINE 什么的没有 GCM 的推送十分不方便，有时候打开提示一条消息，结果已经是三小时前的了。于是想了想还是决定安装 Google 的那一套东西。然而，无论我用任何第三方工具安装，或者是下载 opengapps 的卡刷包刷入，Google Play 都无法工作。<\\/p>\n<a id=\"more\"><\\/a>\n<p>具体表现为在第一次进入 Play 提示要登录账号的时候提示“无法连接 与 Google 服务器通信出现问题”，而且完全看不到登录账号的界面。在确信梯子没有问题之后，我尝试了：<\\/p>\n<ul>\n<li>更换 WiFi\\/移动网络<\\/li>\n<li>使用魅族商店的谷歌安装器<\\/li>\n<li>清除 Google 服务框架的全部数据<\\/li>\n<li>开启定位服务并授予 Google 服务框架所有的权限<\\/li>\n<li>删除 \\/system\\/etc\\/hosts 文件<\\/li>\n<li>降级 Google 套件<\\/li>\n<li>重置手机<\\/li>\n<\\/ul>\n<p>都没有什么卵用。想到之前用 lineageOS 和 MIUI 的时候 Google 框架都正常工作，到网络上搜索相关问题找到的大部分也是 Flyme 用户问的，于是怀疑是不是 Flyme 偷偷做了什么不可描述的事情。但是，Flyme 用户提出的所有解决问题的办法对我来说都没有用。<\\/p>\n<p>在 StackOverflow 上，有玩家提到可以用 adb 排查原因，于是照做发现，确实可行。如果你也遇到相似的问题，可以尝试下面的步骤排查，然后解决。<\\/p>\n<p>首先到开发者选项中打开 USB 调试，连接电脑，在手机上操作授权调试。建议关闭后台的所有程序，然后在电脑端执行：<code>adb logcat<\\/code> 命令。接着终端会闪过一堆的字，这是在打印 log. 等到终端打出来的字差不多稳定的时候，在手机上打开 Google Play，进入添加账号界面。此时电脑上会显示 Google 框架的 log，查找是否有以 <code>E Checkin failed<\\/code> 类似的错误提示，例如在我这里是：<\\/p>\n<pre><code>CheckinTask: Checkin failed: https:\\/\\/android.clients.google.com\\/checkin (request #0): java.io.IOException: Rejected response from server: invalid hardware identifier: &quot;HM NOTE 1LTE&quot; is not a valid device.\n<\\/code><\\/pre><p>从错误信息当中我们可以知道，设备没有通过 Google 的设备验证 (checkin)，原因是当前设备无效，而前面那个很明显是手机的型号。然而，考虑到之前用 lineageOS 的时候是可以用的，跟手机型号的关系应该不是很大。于是进一步查找原因，root 后查看 <code>\\/system\\/build.prop<\\/code>, 发现上文的手机型号是 <code>ro.product.name<\\/code> 和 <code>ro.product.device<\\/code> 的值。<\\/p>\n<p>于是猜测问题应该出在这里了。找出之前用的 lineageOS 的包，对比两个 ROM 的 build.prop 文件，发现 <code>ro.product.name<\\/code> 大家都是一样的，但是在 lineageOS 中，<code>ro.product.device<\\/code> 是这台设备的代号 (dior) 而不是具体型号。尝试将当前系统的 <code>ro.product.device<\\/code> 修改，重启之后，问题解决，Google Play 可以正常使用，GCM 也 OK 了。<\\/p>\n<p>再搜索相关资料，发现原来在登录 Google 账号之前，Google 框架会先和 Google 服务器通信，对当前设备进行验证，提交的信息包括设备型号和 IMEI 等等。提交的设备型号就是 <code>ro.product.device<\\/code> 的值，但是 Google 要求提交的型号不允许带有空格和中文等值，于是就造成了上述验证不通过的问题。<\\/p>\n<p><s>所以这个锅 ROM 作者背定了。<\\/s><\\/p>\n",
      "excerpt": "<p>现在用的手机已经服役快要四年了，这年头这种的手机大概也就真的只能拿来当手机用了，于是就刷了个第三方适配的 Flyme 好好用着。虽然平时不太从 Google Play 下载软件，必要时也可以用 APKPure 代替，但是聊聊 LINE 什么的没有 GCM 的推送十分不方便，有时候打开提示一条消息，结果已经是三小时前的了。于是想了想还是决定安装 Google 的那一套东西。然而，无论我用任何第三方工具安装，或者是下载 opengapps 的卡刷包刷入，Google Play 都无法工作。<\\/p>",
      "slug": "android-rom-cannot-communicate-with-google-play",
      "published": true,
      "layout": "post",
      "path": "blog/post/android-rom-cannot-communicate-with-google-play/",
      "permalink": "https://kirainmoe.com/blog/post/android-rom-cannot-communicate-with-google-play/",
      "tags": [
        {
          "name": "android",
          "slug": "android",
          "path": "tags/android/",
          "permalink": "https://kirainmoe.com/tags/android/",
          "length": 1
        },
        {
          "name": "play",
          "slug": "play",
          "path": "tags/play/",
          "permalink": "https://kirainmoe.com/tags/play/",
          "length": 1
        },
        {
          "name": "google",
          "slug": "google",
          "path": "tags/google/",
          "permalink": "https://kirainmoe.com/tags/google/",
          "length": 1
        }
      ],
      "categories": []
    },
    {
      "title": "No Title",
      "date": "2018-02-16T15:14:44.000Z",
      "modified": "2018-02-16T16:27:10.693Z",
      "content": "<blockquote>\n<p>世上无所谓正解<br>我们只是<br>在做自己<br>想做的事罢了<\\/p>\n<\\/blockquote>\n<a id=\"more\"><\\/a>\n<p>每次在博客里写日记，不管写些什么，首先会在心里给自己打上一个“幼稚”的标签；但是偏偏唯一能让我好好静下心来写东西的地方又只有这里。我真的很喜欢在郁闷的时候写点东西，哪怕是一点条理都没有的流水账。<\\/p>\n<hr>\n<p>一周前刚送走了第一轮市质检。虽然在别人的眼里看来成绩并不算差，但是自己的心里真的对这一次的表现一点都不满意。我并不是在刻意跟自己过不去，但是实在不想看到自己会输给原本应当赢的人。还剩下 100 多天的时间，我不知道自己能做多少的改变，我能做的只是一直努力修补着自己身上不断被发现的 bug. 每天六七个小时的睡眠，也许这种日子很快就要到头了，或许是应该好好珍惜这段日子了。我和那一万六千人，甚至几亿人都是一样的啊，只是这一段路程里，我内心的那个终点，不一样罢了。<\\/p>\n<hr>\n<p>寒假前那天中午，QQ 突然收到一条信息，是关于今年我们学校开放日的安排的。今年学校要搞一个叫“景点自助介绍”的东西，需要我们社团提供技术支持。于是在分析了一下需求之后，和另一个社员在两个晚上剪录音、拉字幕，然后我随意地用了 react + react-router 把几个页面拼成了 SPA. 这大概是我第一次用自己的技能为学校官方弄东西吧，虽然全程面对着团委老师（同时是我的物理老师）都不怎么敢说话随便他们提需求，但是看着自己最后做出来的东西被使用，真的很有成就感，哪怕和我写过的其它东西比这个复杂度几乎是 0。<\\/p>\n<hr>\n<p>寒假找了个时间，终于把之前一直想看的告白实行委员会系列补完了。<\\/p>\n<p>最开始是被推荐了<a href=\"http:\\/\\/bangumi.bilibili.com\\/anime\\/6470?from=search&amp;seid=7649789000541346629\" target=\"_blank\" rel=\"external\">《无论何时我们的恋情都是 10 厘米。》<\\/a>，追完了短短的 6 集，但是感觉剧情很棒。我一直很喜欢看这种类型的恋爱番，虽然过程很虐很扣人心弦，但是结局很完美，哪怕在现实生活中不太可能遇到这种事情。<\\/p>\n<p>我的语文一直都是在不及格线徘徊，表达能力实在不行，以至于我每次看完一部番剧，感觉心中感慨万千，真的让我写漫评的时候，却是一句话都说不出来，除了“好看，好看”似乎我没有别的东西来表达自己对一部番的想法。绘本组的故事最虐，女主虽然等了很久很久最终才迎来了美满的结局，只是，无论是花时间去改变自己，或是花时间去等候一个命运之人，都是很值得的啊。<\\/p>\n<p>追完之后便产生了补完两部剧场版的想法，这其中被网易云推了很多首 HoneyWorks 的歌，更加刺激了我想补全集的决心。于是用两个晚上看完了讲夏树告白的《从很久以前就喜欢你了。》和以小雏为主线的《喜欢上你的那个瞬间。》。我认为这几部，包括 4 月的《月色真美》，都是非常值得看的。没有这些恋情，至少不辜负青春。<\\/p>\n<hr>\n<p>最近追了<a href=\"http:\\/\\/bangumi.bilibili.com\\/anime\\/21557?from=search&amp;seid=9207587491048957314\" target=\"_blank\" rel=\"external\">一部百合番<\\/a>，虽然尺度比较大，也不知道自己受了什么刺激会看这个而且还看得很爽，而且还去追了漫画。但是抛开这些不讲，这部作品里有一些东西，给我很深的感触。<\\/p>\n<blockquote>\n<p>我觉得将别人授予的东西单纯接受下来，和以自己的意志主动地接受，这两者是有很大的区别的。<\\/p>\n<p>这件事他人接受与否<br>是别人的想法<br>我们是 无法改变的<br>世上无所谓正解<br>我们只是<br>在做自己<br>想做的事罢了<\\/p>\n<\\/blockquote>\n<p>一直以来都在单纯地等待着，被动与主动的区别是在哪儿呢？希望自己也能把自己内心的想法坚持下去吧。虽然在别人看来是很疯狂的、无法接受的事情，但是或许只要自己认同、认真去对待就好了吧？虽然给自己做过接受现实的准备，但是连第一步都还没有迈出就退缩，这样的自己大概是无法原谅的吧。<\\/p>\n<div id=\"muse-app\"><\\/div>\n\n<hr>\n<p>Hello, 2018.<\\/p>\n<p>我真正在等待的，到底是什么呢？<\\/p>\n<p>在 Tick-Tick 里给自己列下了一整列的 2018 年度计划，耐心地解释了每个计划的动机、标了优先级。要说 2017 真的是经历了很多，一路的坎坷，到头来却觉得好像一年这样子过去，也没有多少的改变。没有好好规划 2017 的时间是去年的一个败笔，所以在 2018 应该吸取一下去年不足的地方吧？<\\/p>\n<p>2017 年，见识了很多东西，离开了居住的城市好几次，自我评价大概算是成长了一些，至少可以对自己负责了吧。虽然一路跌倒爬起走过去了，但是迎来的却将是另一个转折点：很快就要迎来高考了，很快就要 18 岁了。<\\/p>\n<p>其实我装作很开心，毕竟终于可以告别 12 年的小初高生涯，以一个成人的身份踏进大学的大门。而一想到接下来一百天的不分昼夜的地狱之日，三个月的未知，我会去往哪个城市的哪个地方，第一次和家人经受长时间的分别……我又变得很迷惘。虽然一直安慰自己，只要面对就好了，那些事情在适当的时侯一定会有解决的对策的，但是面对着无尽的未知，又有几个人可以真正地闭上眼睛放开自己的一切。<\\/p>\n<p>毫无疑问地，2018 最大的目标是考上自己心仪的大学，去往自己心仪地城市呀。我一直在等的合适的时机、自己的一个低头冲刺的时刻，应该已经到来了呢。<\\/p>\n<hr>\n<p>现在是 00:25, 一个半小时过去了，我并不知道自己又写了些什么东西，但是在这一个多小时里脑子里闪过的东西，几乎都被我敲下来了。现在郁闷的心情几乎消散殆尽了。有时候会觉得很累，自己孤独地趴在桌上，但是明天或许会变得不一样呢？<\\/p>\n<script type=\"text\\/javascript\">\nMUSE.render([\n  {\n    \"title\": \"アザレア\",\n    \"artist\": \"nano.RIPE\",\n    \"cover\": \"http:\\/\\/p1.music.126.net\\/uhrU5UT8CJwLJe2HUWuyiw==\\/109951163135769359.jpg\",\n    \"src\": \"https:\\/\\/api.kotori.love\\/netease\\/536096053.mp3\",\n    \"lyric\": \"[by:ZOHUR]\\n[00:00.00] 作曲 : 佐々木淳\\n[00:01.00] 作词 : きみコ\\n[00:03.300]編曲: nano.RIPE\\n[00:04.610]\\n[00:18.620]許されたことなんてそう多くはないでしょう？\\n[00:24.100]誰の目に適えば誰も傷つけずに済む？\\n[00:30.170]シアワセの定義は人の数あるけど\\n[00:36.300]掴むまでの道は一本と限らない\\n[00:40.960]\\n[00:41.210]迷子になる前にきみの声を標に\\n[00:47.170]耳の奥 鼓膜をもっと震わせて\\n[00:52.140]\\n[00:53.320]道なき道を行こう 初めてを捧げよう\\n[00:59.540]甘い夢 その魔法に掛かったフリで\\n[01:05.220]残酷にも思える運命のその中で\\n[01:11.220]見つからないように進もう 足跡は消して\\n[01:19.450]\\n[01:24.400]届かない夜にも寄り添える何かを\\n[01:30.210]いつの間にふたりはそっと育てていたんだよ\\n[01:36.370]叶えたいことなら星の数あるけど\\n[01:41.980]たとえそのすべてが夢と散ったって\\n[01:47.010]\\n[01:47.130]怖くはないようにきみの手を離さずに\\n[01:53.150]胸の奥 鼓動がぐっと高まれば\\n[01:58.410]\\n[01:59.330]道なき道を行こう 初めてを重ねよう\\n[02:05.690]名前のないこの感情に名前を付けて\\n[02:11.230]錯覚にも思える衝動に従って\\n[02:17.260]きみが望むなら落ちよう どこまでも闇へ\\n[02:25.110]\\n[02:38.180]迷子になる前にきみの声を標に\\n[02:44.090]耳の奥 鼓膜をもっと震わせて\\n[02:49.910]\\n[02:51.800]道なき道を行こう 初めてを続けよう\\n[02:58.000]甘い夢 その魔法が覚めてもまだ\\n[03:03.670]残酷にも思える運命を蹴散らして\\n[03:09.670]邪魔されない方へ進もう ふたりだけ消して\\n[03:18.220]\\n\",\n    \"translation\": \"[by:新-檀黎斗神]\\n[00:03.300]\\n[00:18.620]世上所谓百无禁忌的事情其实并不多吧？\\n[00:24.100]到底要让谁称心才能不伤及任何人？\\n[00:30.170]虽说幸福的定义因人而异\\n[00:36.300]但去抓住它的道路却不是唯一的\\n[00:41.210]在就要迷路前让我认出你的声音\\n[00:47.170]让我两耳深处的鼓膜 更为颤动\\n[00:53.320]直闯艰难的绝路吧 献上我的第一次吧\\n[00:59.540]沉浸在美梦中 佯装自己中了魔法般\\n[01:05.220]在不禁让人觉得残忍的命运当中\\n[01:11.220]为了不被人发现偷偷前进吧 不留一串足迹\\n[01:24.400]遥不可及的夜里也能作为依靠之物\\n[01:30.210]不知从何时起在两人之间日渐培养出来了\\n[01:36.370]虽说心中的愿望可谓多如繁星\\n[01:41.980]即使它们总有一天要如梦般烟消云散\\n[01:47.130]为使你不感到害怕 我紧握你的手不放\\n[01:53.150]只要令心中跳动更为加速的话\\n[01:59.330]直闯艰难的绝路吧 让我们共度第一次吧\\n[02:05.690]让我们给这份无名的感情起一个名字\\n[02:11.230]为这份也许是误会的冲动驱使\\n[02:17.260]既然你愿意那我就堕落吧 深深地向着黑暗\\n[02:38.180]在就要迷路前让我认出你的声音\\n[02:44.090]让我两耳深处的鼓膜 更为颤动\\n[02:51.800]直闯艰难的绝路吧 继续我们的第一次吧\\n[02:58.000]即使从美梦的魔法中醒来后亦然\\n[03:03.670]将不禁让人觉得残忍的命运驱散\\n[03:09.670]向着无人打扰那方前进吧 只让两人消失踪影\\n\"\n  }\n], document.getElementById('muse-app'), {\n    layout: 'muse-layout-landscape'\n});\n<\\/script>",
      "excerpt": "<blockquote>\n<p>世上无所谓正解<br>我们只是<br>在做自己<br>想做的事罢了<\\/p>\n<\\/blockquote>",
      "slug": "no-title",
      "published": true,
      "layout": "post",
      "path": "blog/post/no-title/",
      "permalink": "https://kirainmoe.com/blog/post/no-title/",
      "tags": [
        {
          "name": "diary",
          "slug": "diary",
          "path": "tags/diary/",
          "permalink": "https://kirainmoe.com/tags/diary/",
          "length": 3
        }
      ],
      "categories": [
        {
          "name": "日记",
          "slug": "日记",
          "path": "categories/日记/",
          "permalink": "https://kirainmoe.com/categories/日记/",
          "length": 1
        }
      ]
    },
    {
      "title": "Progressive Web App 初体验",
      "date": "2018-01-14T08:33:20.000Z",
      "modified": "2018-01-14T11:26:08.883Z",
      "content": "<p>最近访问 <a href=\"https:\\/\\/mobile.twitter.com\\/\" target=\"_blank\" rel=\"external\">Twitter Mobile<\\/a> 和 <a href=\"https:\\/\\/m.weibo.cn\\/beta\" target=\"_blank\" rel=\"external\">微博 HTML5 版<\\/a> 的时候，发现两者纷纷都兼容了 PWA(Progressive Web App) 特性，得益于 Service Worker，PWA 具有了一些以往传统 WebApp 做不到的，诸如离线消息推送等等的功能，如果在 WebApp 和原生应用性能和功能相差不大的情况下，已经可以直接把 Web 端当成简洁版的客户端使用了（尤其是 Twitter Mobile，移动 Web 端的体验和 Android 原生 App 的体验几乎 90% 一致）。毫无疑问 PWA 接下来将会带来更大的应用场景，于是为了跟上前端圈技术的泥石流，本辣鸡接触了一下这项新的技术。<\\/p>\n<a id=\"more\"><\\/a>\n<h1 id=\"关于-PWA\"><a href=\"#关于-PWA\" class=\"headerlink\" title=\"关于 PWA\"><\\/a>关于 PWA<\\/h1><p>不仅仅是微博，国内的饿了么等站也同样支持 PWA，个人看来 PWA 的应用场景和前景都是相当广泛的。甚至，从微信小程序当中你也能看到它和 PWA 之间有着概念的重合。至于 PWA 的诞生背景就不多做介绍。各位可以尝试一下 Twitter 的 PWA，体验真的很好。<\\/p>\n<blockquote>\n<p><a href=\"https:\\/\\/www.zhihu.com\\/question\\/46690207\" target=\"_blank\" rel=\"external\">如何看待 Progressive Web Apps 的发展前景？<\\/a><\\/p>\n<\\/blockquote>\n<p>传统 WebApp 在移动端上的体验不是很好一直为人所诟病，问题在于移动端浏览器在对页面的渲染和 DOM 的操作上有性能方面的差距，以及并不能做一些高级的事情，例如驻后台更新数据、推送通知等等。如果说 RN\\/Weex 是用前端的技术栈做移动端的原生应用，以此来作为移动端 App 的功能、性能与开发成本之间的权衡，那么 PWA 和前两者便有一些区别，在前两者向 NativeApp 妥协的时候，它另辟蹊径，坚守 WebApp，而把目光着重于优化和实现一些 WebApp 做不到的事情。某种意义上说有点类似于 Hybrid？但是壳什么的，浏览器已经帮你准备好了。你只需要在访问支持 PWA 的站点的时候按一下“添加到主屏幕”，它就如同一个 App 一样躺在你的桌面了。<\\/p>\n<p>讲了很多 PWA 的优点（总结一下就是：支持添加到主屏，可以完成通知推送等工作（甚至支持 GCM）；其他的还有诸如离线缓存等），PWA 也存在一些不足的地方。首先一个比较大的问题就是兼容性，作为 Google 首推的东西 Chrome 自然是支持的，新版本的 FF 目测也可以，但是对于别的浏览器来说就十分难受了：<\\/p>\n<p><img src=\"https:\\/\\/ws4.sinaimg.cn\\/large\\/9f1137b1gy1fng8t2ltorj20y60dn0tk.jpg\" alt=\"Can I Use 中关于 Service Worker 的兼容性报告\"><\\/p>\n<p>从 <a href=\"https:\\/\\/caniuse.com\\/#search=service%20worker\" target=\"_blank\" rel=\"external\">caniuse<\\/a> 的报告中可以看到兼容性有些感人。<\\/p>\n<h1 id=\"Service-Worker\"><a href=\"#Service-Worker\" class=\"headerlink\" title=\"Service Worker\"><\\/a>Service Worker<\\/h1><p>刚刚说到的一些 PWA 的特性，例如后台消息推送、离线缓存等等，都是由 Service Worker 来实现的。所以说一个 PWA 应用的核心就在于 Service Worker，完全不过分。<\\/p>\n<blockquote>\n<p>一个 Service Worker是一段运行在浏览器后台进程里的脚本，他独立于当前页面，提供了那些不需要与 web 页面交互的功能在网页背后悄悄执行的能力。在将来，基于它可以实现消息推送，静静更新以及地理围栏等服务，但是目前它首先要具备的功能是拦截和处理网络请求的功能，包括可编程的消息缓存管理能力。<\\/p>\n<\\/blockquote>\n<p>通俗地讲，Service Worker 就是挂在后台的一段脚本，你在前台该干嘛干嘛，它可以在后台搞一些事情，比如缓存你看的页面或者资源啊，接收到通知的时候推送给你啊，转发你的请求啊，这些都是目前比较多见的应用；当你关掉了页面之后，它还是会在后台待着继续做上面这些事情。<\\/p>\n<blockquote>\n<p><a href=\"https:\\/\\/developer.mozilla.org\\/zh-CN\\/docs\\/Web\\/API\\/Service_Worker_API\" target=\"_blank\" rel=\"external\">Service Worker API - MDN<\\/a><br>Service worker是一个注册在指定源和路径下的事件驱动worker。它采用JavaScript控制关联的页面或者网站，拦截并修改访问和资源请求，细粒度地缓存资源。你可以完全控制应用在特定情形（最常见的情形是网络不可用）下的表现。Service worker运行在worker上下文，因此它不能访问DOM。相对于驱动应用的主JavaScript线程，它运行在其他线程中，所以不会造成阻塞。它设计为完全异步，同步API（如XHR和localStorage）不能在service worker中使用。<\\/p>\n<\\/blockquote>\n<p>可以看到，Service Worker 不具备对 DOM 的访问权限，工作完全都在后台。同时因为 Service Worker 运行在后台的特性，它的操作都是异步的，因此 Promise 在这里非常好用。无法使用 XHR 这样的同步 API 还怎么和服务器通信呢，我们有 <a href=\"https:\\/\\/developer.mozilla.org\\/en-US\\/docs\\/Web\\/API\\/Fetch_API\\/Using_Fetch\" target=\"_blank\" rel=\"external\">fetch<\\/a> 呀。在 Service Worker 中 fetch 也扮演了一个很重要的角色。<\\/p>\n<p>Service Worker 的工作机制是这样的：用户访问一个具有 Service Worker 的页面，浏览器就会下载这个 Service Worker 并尝试安装、激活。一旦激活，Service Worker 就会到后台开始工作。接下来用户访问这个页面或者每隔一个时段浏览器都会下载这个 Service Worker，如果监测到 Service Worker 有更新，就会重新安装并激活新的 Service Worker，同时 revoke 掉旧的 Service Worker，这就是 SW 的生命周期。<\\/p>\n<p>因为 Service Worker 有着最近的权限接触数据，因此 Service Worker 只能被安装在 HTTPS 加密的页面中，虽然无形当中提高了 PWA 的门槛，不过也是为了安全做考虑。GitHub Pages 等服务默认支持 HTTPS，所以各位如果想尝试 Service Worker 又被需要 HTTPS 所烦恼的话，可以考虑一下。<\\/p>\n<h1 id=\"In-Action\"><a href=\"#In-Action\" class=\"headerlink\" title=\"In Action\"><\\/a>In Action<\\/h1><p>多说一句，一些用 React\\/Vue 这类框架做的 SPA 原本就有很完整的体验, 如果加上 ServiceWorker，让它成为一个 PWA，岂不美哉 <s>开发移动端的经费都省了<\\/s>。事实上刚才说到的 Twitter(基于 React) 和新版微博(基于 Vue) 便是很好的实践的例子。而 create-react-app 创建的 React App 默认也会启用 ServiceWorker 特性，在 cra 创建的应用中，你可以看到和 ServiceWorker 安装激活有关的代码，同时 webpack 中也有相应的配置。<\\/p>\n<p>我的 Blog 默认采用 HTTPS 安全连接，前端也是用 webpack 构建的，用来尝试 PWA 一些基础的功能（例如离线缓存，生成单独的 App 图标）完全可以，所以我就以博客为<s>小白鼠<\\/s>试了一下，只做了十分基本的离线缓存。<\\/p>\n<h2 id=\"Step-1-编写并注入-ServiceWorker-到前端页面中\"><a href=\"#Step-1-编写并注入-ServiceWorker-到前端页面中\" class=\"headerlink\" title=\"Step 1 \\/ 编写并注入 ServiceWorker 到前端页面中\"><\\/a>Step 1 \\/ 编写并注入 ServiceWorker 到前端页面中<\\/h2><p>这块我们就直接抄走 create-react-app 生成的 App 的代码好啦。在 src 目录下有一个 registerServiceWorker.js，就是用来管理安装\\/激活\\/检查\\/注销 ServiceWorker 的，我们来看看它：<\\/p>\n<pre><code class=\"js\">\\/\\/ In production, we register a service worker to serve assets from local cache.\n\n\\/\\/ This lets the app load faster on subsequent visits in production, and gives\n\\/\\/ it offline capabilities. However, it also means that developers (and users)\n\\/\\/ will only see deployed updates on the &quot;N+1&quot; visit to a page, since previously\n\\/\\/ cached resources are updated in the background.\n\n\\/\\/ To learn more about the benefits of this model, read https:\\/\\/goo.gl\\/KwvDNy.\n\\/\\/ This link also includes instructions on opting out of this behavior.\n<\\/code><\\/pre>\n<p>这里告诉我们它用 registerWorker 的目的在于缓存一些资源，但是呢会导致如果生产环境的页面被开发者更新了之后，看到新效果之前可能有延迟。<\\/p>\n<pre><code class=\"js\">const isLocalhost = Boolean(\n  window.location.hostname === &#39;localhost&#39; ||\n    window.location.hostname === &#39;[::1]&#39; ||\n    window.location.hostname.match(\n      \\/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$\\/\n    )\n);\n\\/\\/ 执行注册 ServiceWorker 的操作，可以看出只有在生产环境下才做这件事\nexport default function register() {\n  if (process.env.NODE_ENV === &#39;production&#39; &amp;&amp; &#39;serviceWorker&#39; in navigator) {\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      return;\n    }\n    \\/\\/ 页面加载完成后，执行注册操作\n    window.addEventListener(&#39;load&#39;, () =&gt; {\n      const swUrl = `${process.env.PUBLIC_URL}\\/service-worker.js`;\n      if (!isLocalhost) {\n        registerValidSW(swUrl);\n      } else {\n        checkValidServiceWorker(swUrl);\n      }\n    });\n  }\n}\n<\\/code><\\/pre>\n<p>我们看看注册操作的主函数：<\\/p>\n<pre><code class=\"js\">function registerValidSW(swUrl) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration =&gt; {\n      registration.onupdatefound = () =&gt; {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () =&gt; {\n          if (installingWorker.state === &#39;installed&#39;) {\n            if (navigator.serviceWorker.controller) {\n              console.log(&#39;New content is available; please refresh.&#39;);\n            } else {\n              console.log(&#39;Content is cached for offline use.&#39;);\n            }\n          }\n        };\n      };\n    })\n    .catch(error =&gt; {\n      console.error(&#39;Error during service worker registration:&#39;, error);\n    });\n}\n<\\/code><\\/pre>\n<p>可以看到我们<strong>用 <code>navigator.serviceWorker.register(serviceWorkerJsUrl)<\\/code> 告诉浏览器应该注册从 serviceWorkerJsUrl 注册这个 ServiceWorker<\\/strong>, 然后指定当浏览器监测到 serviceWorker 更新之后该做的事情（事实上没有什么东西，就是 console.log 告诉用户内容是否有更新，以及当前页面的内容已经被缓存了）。<\\/p>\n<pre><code class=\"js\">function checkValidServiceWorker(swUrl) {\n  \\/\\/ Check if the service worker can be found. If it can&#39;t reload the page.\n  fetch(swUrl)\n    .then(response =&gt; {\n      \\/\\/ Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get(&#39;content-type&#39;).indexOf(&#39;javascript&#39;) === -1\n      ) {\n        \\/\\/ No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration =&gt; {\n          registration.unregister().then(() =&gt; {\n            window.location.reload();\n          });\n        });\n      } else {\n        \\/\\/ Service worker found. Proceed as normal.\n        registerValidSW(swUrl);\n      }\n    })\n    .catch(() =&gt; {\n      console.log(\n        &#39;No internet connection found. App is running in offline mode.&#39;\n      );\n    });\n}\n<\\/code><\\/pre>\n<p>这段代码是检查 Service Worker 的有效性。首先对 serviceWorkerJsUrl 发出 fetch 请求，如果 serviceWorker 不存在了（返回 404，或者类型不是 JS 文件），那么程序会认为已经不再需要 ServiceWorker 了，那么就调用 <code>registration.unregister()<\\/code> 执行注销操作并刷新页面。如果 fetch 不成功，程序会认为当前没有可用的网络，运行在离线模式 (offline mode) 中。<\\/p>\n<pre><code class=\"js\">export function unregister() {\n  if (&#39;serviceWorker&#39; in navigator) {\n    navigator.serviceWorker.ready.then(registration =&gt; {\n      registration.unregister();\n    });\n  }\n}\n<\\/code><\\/pre>\n<p>这一段是注销的函数，当你不再需要的时候也可以人工调用这个函数注销 ServiceWorker.<\\/p>\n<p>然后我们在自己项目的 src 里引用这个文件，注册 service worker. 例如，采用 ES6 的写法：<\\/p>\n<pre><code class=\"js\">import registerServiceWorker from &#39;.\\/registerServiceWorker&#39;;\nregisterServiceWorker();\n<\\/code><\\/pre>\n<p>这样就注册完成了，很简单。<\\/p>\n<h2 id=\"Step-2-编写-service-worker-js\"><a href=\"#Step-2-编写-service-worker-js\" class=\"headerlink\" title=\"Step 2 \\/ 编写 service-worker.js\"><\\/a>Step 2 \\/ 编写 service-worker.js<\\/h2><p>因为这里我们要做的只是缓存，所以我们把要缓存的东西以及相关的代码写入 service-worker.js 中就可以了，如果你要推送东西，同样可以参照一下 API 然后写在这里。这个 js 脚本便是即将在浏览器的后台执行的脚本了。当然，如果在很简单的需求下，我们不需要手写 service-worker.js，可以直接生成的。<\\/p>\n<p>webpack 有一个插件叫做 <code>sw-precache-webpack-plugin<\\/code>, 我们可以用它来生成 service-worker.js 以便用 SW 缓存我们的资源。首先我们安装这个插件：<code>yarn add sw-precache-webpack-plugin --dev<\\/code>.<\\/p>\n<p>然后修改 <code>webpack.config<\\/code>:<\\/p>\n<pre><code class=\"js\">const SWPrecacheWebpackPlugin = require(&#39;sw-precache-webpack-plugin&#39;);\n\nmodule.exports = {\n    \\/\\/ ...\n    plugins: [\n        new SWPrecacheWebpackPlugin({\n        dontCacheBustUrlsMatching: \\/\\.\\w{8}\\.\\/,\n        filename: &#39;service-worker.js&#39;,\n        logger(message) {\n            if (message.indexOf(&#39;Total precache size is&#39;) === 0) {\n            return;\n            }\n            if (message.indexOf(&#39;Skipping static resource&#39;) === 0) {\n            return;\n            }\n        },\n        minify: true,\n        navigateFallback: &#39;\\/index.html&#39;,\n        navigateFallbackWhitelist: [\\/^(?!\\\\/__).*\\/],\n        staticFileGlobsIgnorePatterns: [\\/\\.map$\\/, \\/asset-manifest\\.json$\\/]\n        }),\n    ],\n    \\/\\/ ...\n}\n<\\/code><\\/pre>\n<p>这段代码会在 webpack 打包进程中自动帮我们生成 service-worker.js, 通过看代码我们发现这个 js 告诉了浏览器我们可以离线哪些资源，并且注册了安装、激活、更新时应该做的事情，等等。<\\/p>\n<p>完成后打开浏览器，打开 DevTools 切到 Application 窗口，再点左边的 ServiceWorker，如果没有出错的话就可以看到 ServiceWorker 被安装并激活了。你也可以在这个窗格调试你的 ServiceWorker.<\\/p>\n<p><img src=\"https:\\/\\/ws3.sinaimg.cn\\/large\\/9f1137b1gy1fngags88u3j20hb0dp3z8.jpg\" alt=\"devtools service-worker\"><\\/p>\n<p>你可以转到 <code>chrome:\\/\\/inspect<\\/code> 查看当前所有站点注册的 ServiceWorker 的情况。<\\/p>\n<h2 id=\"Step-3-生成-asset-manifest-json\"><a href=\"#Step-3-生成-asset-manifest-json\" class=\"headerlink\" title=\"Step 3 \\/ 生成 asset-manifest.json\"><\\/a>Step 3 \\/ 生成 asset-manifest.json<\\/h2><p>这一步我们同样用插件：<code>webpack-manifest-plugin<\\/code>, 用法同样很简单：<\\/p>\n<pre><code class=\"js\">const ManifestPlugin = require(&#39;webpack-manifest-plugin&#39;);\n\\/\\/ ...\nplugins: [\n    new ManifestPlugin({\n      fileName: &#39;asset-manifest.json&#39;\n    }),\n]\n<\\/code><\\/pre>\n<p>打包完后根目录下便会有一个 asset-manifest.json 文件，这个文件告诉了浏览器有哪些静态文件。<\\/p>\n<h2 id=\"Step-4-写好-manifest-json\"><a href=\"#Step-4-写好-manifest-json\" class=\"headerlink\" title=\"Step 4 \\/ 写好 manifest.json\"><\\/a>Step 4 \\/ 写好 manifest.json<\\/h2><p>最后一步，如果要让我们的应用在手机端访问 Chrome 的时候，提示安装的横幅（就是添加到主屏幕的提示），我们还需要做一件事——为你的 WebApp 写一个 <code>manifest.json<\\/code>，这里不同于上一步的 <code>asset-manifest.json<\\/code>，<code>manifest.json<\\/code> 主要是告诉浏览器这个站点的一些信息，包括名称、图标、首页、主题色等等。加上这个文件之后才能算是一个完整的 PWA。例如：<\\/p>\n<pre><code class=\"js\">{\n  &quot;short_name&quot;: &quot;YumeのDiary&quot;,\n  &quot;name&quot;: &quot;吟梦酱的 Blog&quot;,\n  &quot;description&quot;: &quot;是吟梦酱的 Blog 的说~&quot;,\n  &quot;icons&quot;: [\n    {\n      &quot;src&quot;: &quot;favicon.png&quot;,\n      &quot;sizes&quot;: &quot;192x192&quot;,\n      &quot;type&quot;: &quot;image\\/png&quot;\n    }\n  ],\n  &quot;start_url&quot;: &quot;\\/&quot;,\n  &quot;display&quot;: &quot;standalone&quot;,\n  &quot;theme_color&quot;: &quot;#FF98A8&quot;,\n  &quot;background_color&quot;: &quot;#ffffff&quot;\n}\n<\\/code><\\/pre>\n<p>这是我的 manifest 文件。这些配置项都很简单易懂，看的懂英文的人都知道是什么意思了。例如，<code>short_name<\\/code> 是被添加到手机桌面时显示的标签， <code>name<\\/code> 就是 App 的名称，<code>display<\\/code> 设置为 <code>standalone<\\/code> 表示不打开浏览器界面而单独打开此 App（就是传说中的套壳2333），<code>background_color<\\/code> 是从桌面启动 PWA 时第一屏的背景色……<\\/p>\n<p>然后在 HTML 中链接 manifest.json:<\\/p>\n<pre><code class=\"html\">&lt;head&gt;\n  &lt;link rel=&quot;manifest&quot; href=&quot;\\/manifest.json&quot;&gt;\n&lt;\\/head&gt;\n<\\/code><\\/pre>\n<p>把 manifest.json 放在根目录，完成之后你可以打开 DevTool -&gt; Application -&gt; Manifest 查看情况，也可以测试一下是否可以正常添加。<\\/p>\n<blockquote>\n<p><a href=\"https:\\/\\/developers.google.com\\/web\\/updates\\/2014\\/11\\/Support-for-installable-web-apps-with-webapp-manifest-in-chrome-38-for-Android\" target=\"_blank\" rel=\"external\">Installable Web Apps with the Web App Manifest in Chrome for Android<\\/a><\\/p>\n<\\/blockquote>\n<h1 id=\"Finally\"><a href=\"#Finally\" class=\"headerlink\" title=\"Finally\"><\\/a>Finally<\\/h1><p>做完了这一切，我们可以试试是否正常。如果正常的话，使用移动版 Chrome(&gt;=42) 打开你的页面，你可以看到“添加到主屏幕”的提示：<\\/p>\n<p><img src=\"https:\\/\\/ws3.sinaimg.cn\\/large\\/9f1137b1gy1fngas27pusj20k00zkn1z.jpg\" alt=\"add-to-homescreen: kirainmoe.com pwa\"><\\/p>\n<p>如果看到了提示，说明成功了。如果没有看到的话，可能有以下原因：<\\/p>\n<ol>\n<li>ServiceWorker 没有被正常加载。使用桌面端的 Chrome 看看是否成功加载了 ServiceWorker、console 是否报错等等。<\\/li>\n<li>当前页面不是 HTTPS 协议。只有 HTTPS 协议才能激活 ServiceWorker 并提示安装 PWA。<\\/li>\n<li>Chrome 无法正确识别 manifest.json. 有很多原因导致，可以在上文讲到的 DevTool -&gt; Application -&gt; Manifest 中尝试添加，看看控制台是否报错和报错内容。比如说：你的图标有问题（需要 mime-type 为 image\\/png，并且尺寸一定要 100% 符合，且尺寸要大于 144x144）……等等。<\\/li>\n<\\/ol>\n<p>解决了上面这些问题之后再试一次，应该就没有问题了。<\\/p>\n<p>新技能 get√ 感觉逼格又提升了一些（wu <code>_(:з」∠)_<\\/code><\\/p>\n",
      "excerpt": "<p>最近访问 <a href=\"https:\\/\\/mobile.twitter.com\\/\">Twitter Mobile<\\/a> 和 <a href=\"https:\\/\\/m.weibo.cn\\/beta\">微博 HTML5 版<\\/a> 的时候，发现两者纷纷都兼容了 PWA(Progressive Web App) 特性，得益于 Service Worker，PWA 具有了一些以往传统 WebApp 做不到的，诸如离线消息推送等等的功能，如果在 WebApp 和原生应用性能和功能相差不大的情况下，已经可以直接把 Web 端当成简洁版的客户端使用了（尤其是 Twitter Mobile，移动 Web 端的体验和 Android 原生 App 的体验几乎 90% 一致）。毫无疑问 PWA 接下来将会带来更大的应用场景，于是为了跟上前端圈技术的泥石流，本辣鸡接触了一下这项新的技术。<\\/p>",
      "slug": "first-taste-of-progressive-web-app",
      "published": true,
      "layout": "post",
      "path": "blog/post/first-taste-of-progressive-web-app/",
      "permalink": "https://kirainmoe.com/blog/post/first-taste-of-progressive-web-app/",
      "tags": [
        {
          "name": "frontend",
          "slug": "frontend",
          "path": "tags/frontend/",
          "permalink": "https://kirainmoe.com/tags/frontend/",
          "length": 4
        },
        {
          "name": "progressive-web-app",
          "slug": "progressive-web-app",
          "path": "tags/progressive-web-app/",
          "permalink": "https://kirainmoe.com/tags/progressive-web-app/",
          "length": 1
        }
      ],
      "categories": [
        {
          "name": "前端",
          "slug": "前端",
          "path": "categories/前端/",
          "permalink": "https://kirainmoe.com/categories/前端/",
          "length": 4
        }
      ],
      "illust": "https://ws3.sinaimg.cn/large/9f1137b1gy1fngazn3jklj20j4083t92.jpg"
    },
    {
      "title": "环境变量导致的 webpack 打包时不压缩 CSS 文件",
      "date": "2018-01-07T07:23:36.000Z",
      "modified": "2018-01-07T07:46:37.091Z",
      "content": "<p>项目上线的时候一般要把 JS 和 CSS 压缩一下，用 webpack 的 uglifyJSPlugin 和 css-loader 的 minimize 选项可以分别压缩 JS 和 CSS. 但是偶然发现一个项目里的 CSS 并没有被压缩。最后发现是一个环境变量在不同的系统下不统一的锅。<br><a id=\"more\"><\\/a><br>通过为 css-loader 指定参数，可以在打包的时候压缩 CSS 样式文件。例如：<\\/p>\n<pre><code class=\"js\">{\n  test: \\/(\\.styl)$\\/,\n  loaders: [\n    &#39;style-loader&#39;,\n    {\n      loader: &#39;css-loader&#39;,\n      options: {\n        minimize: process.env.NODE_ENV === &#39;production&#39;\n      }\n    }\n    &#39;postcss-loader&#39;,\n    &#39;stylus-loader&#39;\n  ]\n}\n<\\/code><\\/pre>\n<p>因为个人习惯，我一般不把 <code>minimize<\\/code> 属性直接设置为 true，而是判断当前是否将要打包成生产环境用的文件，如果是才压缩 CSS. 然而就在这个地方出了锅，发现弄出来的 CSS 根本没压缩。一开始以为是 ExtractTextPlugin 的问题，后来发现如果直接把 minimize 的值设置为 true 的时候就会压缩，那么问题就在于 <code>process.env.NODE_ENV === &#39;production&#39;<\\/code> 表达式返回了不正确的值。<\\/p>\n<p>导致这个原因的问题在于没有设置 <code>NODE_ENV<\\/code> 环境变量= =这个变量需要在运行 webpack 的时候设置，之前一直以为使用 <code>webpack.DefinePlugin<\\/code> 定义 <code>process.env.NODE_ENV<\\/code> 就可以的：<\\/p>\n<pre><code class=\"js\">  new webpack.DefinePlugin({\n    &#39;process.env.NODE_ENV&#39;: JSON.stringify(&#39;production&#39;)\n  })\n<\\/code><\\/pre>\n<p>猜测 <code>webpack.DefinePlugin<\\/code> 插件定义的变量只对项目的代码有效（就是对要打包的目标生效），但是对打包工具 webpack 自身似乎是无效的，所以即便在项目中 <code>process.env.NODE_ENV<\\/code> 能取到正常的值，但是对于其他情况下 <code>process.env.NODE_ENV<\\/code> 就没有定义了。<\\/p>\n<p>解决方法就是手动在终端中定义 <code>process.env.NODE_ENV<\\/code> 变量，但是这样太麻烦了，而且还有跨系统兼容性的问题。可以使用 <a href=\"https:\\/\\/github.com\\/kentcdodds\\/cross-env\" target=\"_blank\" rel=\"external\">cross-env<\\/a> 来定义环境变量，然后再通过其启动 webpack.<\\/p>\n<pre><code class=\"bash\">yarn add --dev cross-env\n<\\/code><\\/pre>\n<p>然后修改 <code>package.json<\\/code> 中的 <code>script<\\/code> 字段，在执行打包命令的时候先调用 cross-env 设置环境变量，然后再唤起 webpack. 例如：<\\/p>\n<pre><code class=\"js\">&quot;scripts&quot;: {\n  &quot;dist&quot;: &quot;cross-env NODE_ENV=production webpack --config config\\/webpack.config.js --env=production&quot;,\n  &quot;serve&quot;: &quot;cross-env NODE_ENV=dev webpack-dev-server --progress --config config\\/webpack.config.js --env=dev&quot;,\n  &quot;serve:dist&quot;: &quot;cross-env NODE_ENV=dist wepack-dev-server --progress --config config\\/webpack.config.js --env=production&quot;,\n  &quot;watch&quot;: &quot;cross-env NODE_ENV=dev webpack --progress --watch --config config\\/webpack.config.js --env=dev&quot;\n},\n<\\/code><\\/pre>\n<p>这样子再运行打包生产环境文件的命令的时候，webpack 就能获取到正确的 <code>process.env.NODE_ENV<\\/code> 环境变量，就能正常压缩 CSS 了。<\\/p>\n",
      "excerpt": "<p>项目上线的时候一般要把 JS 和 CSS 压缩一下，用 webpack 的 uglifyJSPlugin 和 css-loader 的 minimize 选项可以分别压缩 JS 和 CSS. 但是偶然发现一个项目里的 CSS 并没有被压缩。最后发现是一个环境变量在不同的系统下不统一的锅。<br>",
      "slug": "solution-of-webpack-does-not-compress-css",
      "published": true,
      "layout": "post",
      "path": "blog/post/solution-of-webpack-does-not-compress-css/",
      "permalink": "https://kirainmoe.com/blog/post/solution-of-webpack-does-not-compress-css/",
      "tags": [
        {
          "name": "frontend",
          "slug": "frontend",
          "path": "tags/frontend/",
          "permalink": "https://kirainmoe.com/tags/frontend/",
          "length": 4
        },
        {
          "name": "webpack",
          "slug": "webpack",
          "path": "tags/webpack/",
          "permalink": "https://kirainmoe.com/tags/webpack/",
          "length": 3
        }
      ],
      "categories": [
        {
          "name": "前端",
          "slug": "前端",
          "path": "categories/前端/",
          "permalink": "https://kirainmoe.com/categories/前端/",
          "length": 4
        }
      ]
    },
    {
      "title": "使用 Typescript 写 React 遇到的一些坑",
      "date": "2017-12-19T14:12:18.000Z",
      "modified": "2018-01-07T05:18:37.656Z",
      "content": "<p>自从学了 Typescript 之后，写 React 项目什么的就一直没离开过 TS 了。虽然 Typescript 大法好，不过鉴于 Typescript 严格的类型机制（事实上从某种意义上说一点都不严），导致在使用 Typescript 开发 React 的时候遇到了一些小小的问题（对 TS 好感度–）……这里就简单的记录一下。<\\/p>\n<a id=\"more\"><\\/a>\n<h2 id=\"使用-ES7-装饰符-decorator-时提示返回类型未定义\"><a href=\"#使用-ES7-装饰符-decorator-时提示返回类型未定义\" class=\"headerlink\" title=\"使用 ES7 装饰符 (decorator) 时提示返回类型未定义\"><\\/a>使用 ES7 装饰符 (decorator) 时提示返回类型未定义<\\/h2><p>这个问题发生在使用 <a href=\"https:\\/\\/github.com\\/concretesolutions\\/redux-zero\" target=\"_blank\" rel=\"external\">redux-zero<\\/a> （大概是个懒人版的 Redux）的时候。<\\/p>\n<p>一般来说，connect 一个组件大概要这样写，不管是用 react-redux 还是 redux-zero：<\\/p>\n<pre><code class=\"javascript\">import { connect } from &#39;redux-zero\\/react&#39;;\n\n\\/* ... *\\/\n\nclass MyComponent extends React.Compoent {\n    render() {\n        return (\\/* ... *\\/);\n    }\n}\n\nexport default connect(mapStateToProps, actions)(MyComponent);\n<\\/code><\\/pre>\n<p>有时候我们可以偷懒用上 ES7 的 decorator 特性写得简洁一些：<\\/p>\n<pre><code class=\"javascript\">@connect(mapStateToProps, actions)\nexport default class MyCompoent extends React.Component {\n    \\/\\/ ...\n}\n<\\/code><\\/pre>\n<p>这两种写法效果是一样的。然而在 Typescript 中，以上代码会报这样的错误：<\\/p>\n<pre><code>[ts] Unable to resolve signature of class decorator when called as an expression.\n<\\/code><\\/pre><p>点一下 <code>connect<\\/code> 方法的定义，可以看到在 <code>connect.d.ts<\\/code> 的 17 行有这样的一句：<\\/p>\n<pre><code class=\"javascript\">export default function connect(mapToProps: any, actions?: {}): (Child: any) =&gt; (props: any) =&gt; JSX.Element;\n<\\/code><\\/pre>\n<p>看着似乎没什么问题，但是：<\\/p>\n<pre><code class=\"javascript\">\\/\\/ test 1\nconst test = (component: any) =&gt; {\n    console.log(component);\n}\n@test\nclass MyComponent extends React.Component {\n    \\/\\/ ...\n}\n\\/\\/ passed\n<\\/code><\\/pre>\n<p>把定义 <code>test<\\/code> 的方法换一下：<\\/p>\n<pre><code class=\"javascript\">\\/\\/ test 2\nfunction test(component: any) {\n    console.log(component);\n}\n@test\nclass MyComponent extends React.Component {\n    \\/\\/ ...\n}\n\\/\\/ compile failed\n<\\/code><\\/pre>\n<p>看起来 Typescript 并不允许把用 function 定义的函数作为装饰符来使用呢。但是我们总不能去改依赖的代码吧，这个时候怎么办呢w<\\/p>\n<p>如果一些项目有 DefinitelyTyped 的 typing 文件的话，可以尝试安装 <code>@types\\/xxxxx<\\/code>, 例如 <code>@types\\/react-redux<\\/code>。<\\/p>\n<p>如果没有的话，答案就是自己再包上一层，以 <code>redux-zero<\\/code> 的 <code>connect()<\\/code> 为例：<\\/p>\n<pre><code class=\"javascript\">\\/\\/ utils\\/connect.ts\nimport { connect as connectComponent } from &#39;redux-zero\\/react&#39;;\n\nexport const connect = (mapStateToProps: any, actions: any) =&gt; {\n  return (target: any) =&gt; (\n    connectComponent(mapStateToProps, actions)(target) as any\n  );\n};\n\n\\/\\/ component\nimport { connect } from &#39;utils\\/connect&#39;;\n\\/* ... *\\/\n@connect(mapStateToProps, actions)\nexport defalt class MyComponent extends React.Component {\n    \\/\\/ ...\n}\n<\\/code><\\/pre>\n<p>这样就可以啦。<\\/p>\n<h2 id=\"自定义-JSX-元素在-JSX-IntrinsicElements-不存在\"><a href=\"#自定义-JSX-元素在-JSX-IntrinsicElements-不存在\" class=\"headerlink\" title=\"自定义 JSX 元素在 JSX.IntrinsicElements 不存在\"><\\/a>自定义 JSX 元素在 JSX.IntrinsicElements 不存在<\\/h2><p>我并不知道怎么描述这个问题比较合适，场景是需要批量渲染一个对象中所有的组件：<\\/p>\n<pre><code class=\"javascript\">const components = {\n    comp1: Compnent1,\n    comp2: Component2,\n    \\/\\/ ...\n},\n    keys = Object.keys(components);\n\nconst res: Array&lt;any&gt; = [];\nkeys.forEach(key =&gt; {\n    const tmp: any = components[key];\n    res.push(&lt;tmp key={key} \\/&gt;);\n});\n<\\/code><\\/pre>\n<p>上面的代码会返回这样的错误：<\\/p>\n<pre><code>[ts] Property &#39;tmp&#39; does not exist on type &#39;JSX.IntrinsicElements&#39;.\n<\\/code><\\/pre><p>原因是 Typescript 要求 JSX 组件变量名的第一个字母为大写，如果不是的话 TS 便认为它不是个合法的 JSX 元素。所以把 <code>tmp<\\/code> 改成 <code>Tmp<\\/code> 就可以惹。<\\/p>\n",
      "excerpt": "<p>自从学了 Typescript 之后，写 React 项目什么的就一直没离开过 TS 了。虽然 Typescript 大法好，不过鉴于 Typescript 严格的类型机制（事实上从某种意义上说一点都不严），导致在使用 Typescript 开发 React 的时候遇到了一些小小的问题（对 TS 好感度–）……这里就简单的记录一下。<\\/p>",
      "slug": "some-problems-of-typescript-with-react",
      "published": true,
      "layout": "post",
      "path": "blog/post/some-problems-of-typescript-with-react/",
      "permalink": "https://kirainmoe.com/blog/post/some-problems-of-typescript-with-react/",
      "tags": [
        {
          "name": "react",
          "slug": "react",
          "path": "tags/react/",
          "permalink": "https://kirainmoe.com/tags/react/",
          "length": 3
        },
        {
          "name": "frontend",
          "slug": "frontend",
          "path": "tags/frontend/",
          "permalink": "https://kirainmoe.com/tags/frontend/",
          "length": 4
        },
        {
          "name": "typescript",
          "slug": "typescript",
          "path": "tags/typescript/",
          "permalink": "https://kirainmoe.com/tags/typescript/",
          "length": 1
        },
        {
          "name": "javascript",
          "slug": "javascript",
          "path": "tags/javascript/",
          "permalink": "https://kirainmoe.com/tags/javascript/",
          "length": 1
        }
      ],
      "categories": [
        {
          "name": "前端",
          "slug": "前端",
          "path": "categories/前端/",
          "permalink": "https://kirainmoe.com/categories/前端/",
          "length": 4
        }
      ],
      "illust": "https://www.typescriptlang.org/assets/images/foreground_bluprint.svg"
    },
    {
      "title": "使用 React 制作全站单页主题的实践",
      "date": "2017-12-17T12:23:36.000Z",
      "modified": "2018-01-07T05:26:51.942Z",
      "content": "<p>算起来已经有很长一段时间没有折腾过主题了。之前一直都没有什么大变化的原因是，我一直在想一种能否把整个站都做成真正意义上的单页 App（就是不依靠 PJAX 实现）。也想过很多实现的方法，只是一直没有把这些方法真正写成实物验证一下可行性。前一段时间在把 Canvas 的主题用 webpack 重构之后，突发奇想到了一种可行度很高的策略。你现在看到的这个主题，大概就是这个脑洞的产物了。<\\/p>\n<a id=\"more\"><\\/a>\n<p>下文开始瞎扯，如果有什么讲得不对的地方欢迎提出来。<\\/p>\n<h1 id=\"单页化主题有什么不同呢\"><a href=\"#单页化主题有什么不同呢\" class=\"headerlink\" title=\"单页化主题有什么不同呢\"><\\/a>单页化主题有什么不同呢<\\/h1><p>有关于是将站点单页化还是多页化，以及单页化是否可以给用户更好的体验等问题，一直以来都有很多的观点。但是从现今对各大网站的分析看，毫无疑问单页化的趋势更占上风，个人认为单页化的用户体验也更好一些。<\\/p>\n<p>用 PJAX 等技术实现单页化的主题确实已经有很多人做过了，但是对于做出那种基于前端组件化和路由分发的 SPA，并没有见到多少相关的尝试（可能是我见识短浅 emmm）。<\\/p>\n<p>相比起使用 PJAX 实现的单页化，SPA 实现有下面这些特点：<\\/p>\n<ul>\n<li>更灵活。SPA 对后端的要求更小（当然前提是你不做 SSR），服务端只需要给出渲染一个页面所需要的数据，其他的事情都可以交给前端来做。<\\/li>\n<li>更科学。使用 SPA 实现单页化，就可以运用上一些诸如单项数据流的<s>哲学<\\/s>。<\\/li>\n<li>更清晰。SPA 的项目结构可以很清楚，诸如组件化一类的实现将会很便捷。<\\/li>\n<li>更 reactive. 借助一些诸如 React 一类的框架，使用 SPA 实现单页化可以在前端完成一些复杂的视图变化。<\\/li>\n<li><s>更装逼。<\\/s>相比于使用 PJAX 实现单页，SPA 实现更考验一个前端的实现能力和架构能力。<\\/li>\n<li>…..<\\/li>\n<\\/ul>\n<p>还有一些我暂时想不到的特点。然而事物都有两面性，如果选择将整个博客 SPA 化，那么就会有以下麻烦的地方：<\\/p>\n<ul>\n<li>实现繁琐，不说搭建开发环境的麻烦，开发的时候也有一些很重复而繁琐的事情要做。相比制作 PJAX 主题来说，码量会更多一些。<\\/li>\n<li>和后端对接数据的时候稍显复杂。<\\/li>\n<li>打包出的 JS 文件会很大，如果不做组件异步加载或者适当的 code spilt，那么由于前端一个页面就要加载所有需要的组件，bundle 的体积自然比用 PJAX 做大好多好多倍。<\\/li>\n<li>…..<\\/li>\n<\\/ul>\n<p>以及你可能会踩很多的坑。不过既然我们说了是个实践，那么我们还是要尝试一下这个想法的。<\\/p>\n<h1 id=\"技术栈的选择\"><a href=\"#技术栈的选择\" class=\"headerlink\" title=\"技术栈的选择\"><\\/a>技术栈的选择<\\/h1><p>在做一个 SPA 意义上的主题之前，首先应该是对技术栈的选择，而技术栈的选择直接关系到开发的成本、舒适程度和最后产物的质量。<\\/p>\n<h2 id=\"前端框架\"><a href=\"#前端框架\" class=\"headerlink\" title=\"前端框架\"><\\/a>前端框架<\\/h2><p>关于框架的选择，很多 SPA 的最佳实践无非是在比较流行的 Angular, React 和 Vue 当中做出选择。<\\/p>\n<p>关于三个框架如何选择，这里只想说你认为好就行了。网上有很多关于对比这三个框架的文章，可以参考一下然后做出权衡。前端框架的选择主要考虑的是功能实现是否方便、对后期架构的影响、开发的成本，以及体积的大小等等，再有就是上手的难度和社区支持一类的也很重要。ng 的功能十分强大，项目的架构很完美；但是体积和性能相较后两者比较就相对比较不出色了，而且上手的难度会高一些；React 在性能和体积方面权衡得很适当，而且有很出色的生态系统；Vue 国内很多用户，选择 Vue 作为主题的前端框架也不错；这三者都能很好地胜任 SPA 的制作。<\\/p>\n<p>我最熟悉的是 React，所以我选择的自然是它了。鉴于主题的页面逻辑一般不会很复杂，所以我这里用了体积更小的 preact + preact-compat 来代替官方 react，性价比相对会更高。<\\/p>\n<h2 id=\"路由分发\"><a href=\"#路由分发\" class=\"headerlink\" title=\"路由分发\"><\\/a>路由分发<\\/h2><p>大部分 SPA 的路由分发都是在前端完成的，通过不同的 URI 渲染不同的组件到页面上。这就要求我们在后面的制作过程中将不同功能的组件（例如 header, footer, 文章部分，菜单等等）各自分开，这就是组件化了。对于 React 用户而言，路由的最佳选择无疑是 react-router 了。还记得之前 react-router 4 发布的时候 API 翻天覆地的变换和一堆的 bug（日常任务：黑 react-router (1\\/1)），现在明显已经好了很多了，至少在这一次的使用中没有踩到坑。所以就决定是它了。<\\/p>\n<h2 id=\"状态管理\"><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"><\\/a>状态管理<\\/h2><p>对于 SPA 来说，页面的状态大概会很复杂，所以我们需要一个好的状态管理方案。这里我用的是单一状态树 + 单向数据流的解决方案。<\\/p>\n<p>对于 React 而言，可以选择比较流行的 redux 和 mobx，两者相对来说 mobx 会更方便一些，但是依旧是权衡性能和体积，我们这里还是选择 redux. 幸运的是，redux 有一个简化的解决方案 redux-zero，使用它可以大大减少我们掉 redux 的坑的几率（<\\/p>\n<h2 id=\"打包工具\"><a href=\"#打包工具\" class=\"headerlink\" title=\"打包工具\"><\\/a>打包工具<\\/h2><p>毫无疑问地选择 webpack，个人认为 webpack 是当前最适合用来做单页 App 也是功能和配置都最强大的一款打包工具。自然配置会有些复杂，不过耐心一点就可以了。<\\/p>\n<h2 id=\"样式预处理器\"><a href=\"#样式预处理器\" class=\"headerlink\" title=\"样式预处理器\"><\\/a>样式预处理器<\\/h2><p>这个看个人喜好，用一个样式预处理器会减少一些开发的繁琐。SASS\\/SCSS\\/LESS\\/Stylus 什么的，任君选择。<\\/p>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"><\\/a>其它<\\/h2><p>除了上面之外，我还用了 Typescript 来写 React 代码，Typescript 真的很爽。当然如果你不熟悉 TS ，你也可以只用 babel 什么的就好了。<\\/p>\n<h1 id=\"具体思想\"><a href=\"#具体思想\" class=\"headerlink\" title=\"具体思想\"><\\/a>具体思想<\\/h1><ol>\n<li><p>首先由后端将所需要的数据（标题，描述，文章列表，当前页面等等）用 JSON 的格式输出到前端的一个隐藏的标签中（可以使用<code>&lt;script type=&quot;text\\/json&quot; id=&quot;json-holder&quot;&gt;&lt;\\/script&gt;<\\/code>这样的标签），这样方便我们接下来取用。<\\/p>\n<\\/li>\n<li><p>设计一个状态树，包含上述由后端发来的数据的字段，以及一些特殊组件的状态。这个状态树应该满足：修改上述数据之后可以触发整个页面视图的重新渲染。这样我们切换页面或者做一些操作的时候，只要修改这个状态树，那么整个页面就会改变。<\\/p>\n<\\/li>\n<li><p>根据通过不同的 URI ，由路由展示不同的组件。例如用户访问 <code>\\/<\\/code> 的时候，渲染首页的最近文章组件；用户访问 <code>\\/blog\\/post\\/xxxxxx<\\/code> 的时候渲染文章页组件……<\\/p>\n<\\/li>\n<li><p>将路由、组件和状态树连接起来，确保状态树改变的同时路由展示的组件会更新。<\\/p>\n<\\/li>\n<li><p>载入页面的时候，整个 SPA 加载完毕，这时候读取后端发来的嵌入在当前页面的数据，解析为新状态并替换当前状态树（第一次加载页面的时候，这个状态树应该是空的），这样就会触发视图的重新渲染。<\\/p>\n<\\/li>\n<li><p>最后一步，也是这个做法很核心的一步，就是监听页面的切换，用户切换页面的时候，使用 XHR 或者 fetch（推荐一个对 fetch 的封装：<a href=\"https:\\/\\/github.com\\/kokororin\\/honoka\" target=\"_blank\" rel=\"external\">这里<\\/a>） 等方式先抓取新页面，然后用 selector 取出嵌在新页面里的 JSON 数据，解析后替换当前状态树。<\\/p>\n<\\/li>\n<li><p>最后可以对上面的流程做一些适当的优化。这时候后端传出来的 <code>route<\\/code> 等参数就可以派上用场了。<\\/p>\n<\\/li>\n<\\/ol>\n<p>大概像这样:<\\/p>\n<pre><code class=\"javascript\">&lt;Provider store={store}&gt;\n    &lt;BrowserRouter basename={&#39;\\/&#39;}&gt;\n      &lt;div data-reactroot&gt;\n        &lt;Banner \\/&gt;\n        &lt;Menu \\/&gt;\n        &lt;SiteInfo \\/&gt;\n\n        &lt;Route exact path={&#39;\\/&#39;} component={AppIndex} \\/&gt;   \\/\\/ index\n        &lt;Route path={&#39;\\/page\\/:page&#39;} component={Pagination} \\/&gt;   \\/\\/ pagination\n        &lt;Route path={&#39;\\/blog\\/post\\/:slug&#39;} component={Post} \\/&gt;  \\/\\/ blog post\n        &lt;Route path={&#39;\\/pages\\/:slug&#39;} component={Page} \\/&gt;  \\/\\/ single pages\n\n        &lt;Footer \\/&gt;\n      &lt;\\/div&gt;\n    &lt;\\/BrowserRouter&gt;\n&lt;\\/Provider&gt;\n<\\/code><\\/pre>\n<h1 id=\"项目架构\"><a href=\"#项目架构\" class=\"headerlink\" title=\"项目架构\"><\\/a>项目架构<\\/h1><p>以 Hexo 主题为例，我们的 SPA 主题大概是下面这样一个架构：<\\/p>\n<pre><code>theme\\/\n  layouts\\/      # 主题各个页面布局文件，其实我们要做的无非是借助后端在各个页面展示不同的数据和载入文件\n  config\\/       # webpack 的配置\n    webpack.config.js\n  dist\\/         # 打包的 SPA\n  src\\/          # 整个 SPA 的源代码\n    actions\\/    # Redux 的 actions\n    components\\/ # 各种组件\n    stores\\/     # Redux 的 store\n    styles\\/     # 样式\n    images\\/     # 图片什么的\n    index.tsx   # 项目入口\n  package.json\n  tsconfig.json\n  tslint.json\n  ...\n<\\/code><\\/pre><p>（别问我为什么没有 reducers，我用 redux-zero 我自豪（x ）<\\/p>\n<p>下面是我在项目中用的一份 webpack 配置，可以参考:<\\/p>\n<pre><code class=\"js\">const webpack = require(&#39;webpack&#39;),\n  path = require(&#39;path&#39;),\n  ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;);\n\nconst srcPath = path.join(__dirname, &#39;\\/..\\/src&#39;);\n\nmodule.exports = {\n  output: {\n    path: path.join(__dirname, &#39;\\/..\\/source\\/dist&#39;),\n    filename: &#39;[name].js&#39;,\n    publicPath: &#39;\\/dist\\/&#39;\n  },\n  resolve: {\n    extensions: [&#39;.js&#39;, &#39;.jsx&#39;, &#39;.ts&#39;, &#39;.tsx&#39;],\n    alias: {\n      &#39;@&#39;: srcPath,\n      &#39;react&#39;: &#39;preact-compat&#39;,\n      &#39;react-dom&#39;: &#39;preact-compat&#39;\n    }\n  },\n  module: {\n    rules: [\n      {\n        test: \\/\\.(js|jsx)$\\/,\n        enforce: &#39;pre&#39;,\n        include: srcPath,\n        exclude: &#39;\\/node_modules\\/&#39;,\n        loader: &#39;eslint-loader&#39;\n      },  \\/\\/ eslint\n\n      {\n        test: \\/\\.(ts|tsx)$\\/,\n        enforce: &#39;pre&#39;,\n        include: srcPath,\n        exclude: &#39;\\/node_modules\\/&#39;,\n        loader: &#39;tslint-loader&#39;,\n      },  \\/\\/ tslint\n      {\n        test: \\/\\.(ts|tsx)$\\/,\n        include: srcPath,\n        exclude: &#39;\\/node_modules\\/&#39;,\n        loader: &#39;awesome-typescript-loader&#39;,\n      },  \\/\\/ typescript\n      {\n        test: \\/\\.(js|jsx)$\\/,\n        include: srcPath,\n        exclude: &#39;\\/node_modules\\/&#39;,\n        loader: &#39;babel-loader&#39;\n      },  \\/\\/ js babel\n      {\n        test: \\/(\\.styl)$\\/,\n        exclude: &#39;\\/node_modules\\/&#39;,\n        use: ExtractTextPlugin.extract({\n          fallback: [{\n            loader: &#39;style-loader&#39;,\n          }],\n          use: [{\n              loader: &#39;css-loader&#39;,\n              options: {\n                importLoaders: 2,\n                minimize: process.env.NODE_ENV === &#39;production&#39;,\n                sourceMap: true\n              }\n            },\n            {\n              loader: &#39;postcss-loader&#39;,\n              options: {\n                sourceMap: true\n              }\n            },\n            &#39;stylus-loader&#39;\n          ]\n        })\n      },  \\/\\/ stylus\n      {\n        test: \\/\\.(png|jpg|gif|woff|woff2|ttf|eot)$\\/,\n        loader: &#39;url-loader&#39;,\n        options: {\n          limit: 8192\n        }\n      },\n\n      {\n        test: \\/\\.(mp4|ogg|svg)$\\/,\n        loader: &#39;file-loader&#39;\n      }\n  }, \\/\\/ module\n    cache: true,\n    devtool: &#39;eval-source-map&#39;,\n    plugins: [\n        new webpack.NoEmitOnErrorsPlugin(),\n        new webpack.optimize.CommonsChunkPlugin(&#39;common&#39;),\n        new webpack.DefinePlugin({\n        &#39;process.env.NODE_ENV&#39;: &#39;&quot;dev&quot;&#39;,\n        &#39;process.env.REACT_DISTRO&#39;: &#39;&quot;preact&quot;&#39;\n        }),\n        new webpack.HotModuleReplacementPlugin(),\n        new ExtractTextPlugin(&#39;himawari.css&#39;)\n    ]\n};\n<\\/code><\\/pre>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"><\\/a>问题<\\/h1><p>目前发现的问题就是，写在文章中的 JS 标签不会执行，这个是有解决方案的，一个一个取出来重新创建一个 script 标签然后 appendChild 到 body 就行了。<\\/p>\n<p><s>以及……preact + redux 的主题好像和 react + mobx 的 MUSE 冲突了2333 暂时还没有找到方案。<\\/s> 问题在于上一步执行文章内的 JS 的时候多处理了一次，导致组件被 render 了两次……emmm……<\\/p>\n<p>（待补充）<\\/p>\n",
      "excerpt": "<p>算起来已经有很长一段时间没有折腾过主题了。之前一直都没有什么大变化的原因是，我一直在想一种能否把整个站都做成真正意义上的单页 App（就是不依靠 PJAX 实现）。也想过很多实现的方法，只是一直没有把这些方法真正写成实物验证一下可行性。前一段时间在把 Canvas 的主题用 webpack 重构之后，突发奇想到了一种可行度很高的策略。你现在看到的这个主题，大概就是这个脑洞的产物了。<\\/p>",
      "slug": "experiment-of-building-spa-theme-using-react",
      "published": true,
      "layout": "post",
      "path": "blog/post/experiment-of-building-spa-theme-using-react/",
      "permalink": "https://kirainmoe.com/blog/post/experiment-of-building-spa-theme-using-react/",
      "tags": [
        {
          "name": "react",
          "slug": "react",
          "path": "tags/react/",
          "permalink": "https://kirainmoe.com/tags/react/",
          "length": 3
        },
        {
          "name": "front-end",
          "slug": "front-end",
          "path": "tags/front-end/",
          "permalink": "https://kirainmoe.com/tags/front-end/",
          "length": 1
        },
        {
          "name": "theme",
          "slug": "theme",
          "path": "tags/theme/",
          "permalink": "https://kirainmoe.com/tags/theme/",
          "length": 1
        }
      ],
      "categories": [
        {
          "name": "前端",
          "slug": "前端",
          "path": "categories/前端/",
          "permalink": "https://kirainmoe.com/categories/前端/",
          "length": 4
        }
      ]
    },
    {
      "title": "“不悔梦归处，只恨太匆匆”",
      "date": "2017-11-13T13:41:17.000Z",
      "modified": "2018-01-14T01:55:16.939Z",
      "content": "<p>呐。听说按照 OI 界的传统，每位 OIer 退役的时候，都要写一篇退役感言。<br>于是，当我们从这一场梦中醒来的时候，日子又将恢复成从前的样子。<br>不悔梦归处，只恨太匆匆。<br><a id=\"more\"><\\/a><\\/p>\n<h1 id=\"0x00\"><a href=\"#0x00\" class=\"headerlink\" title=\"0x00\"><\\/a>0x00<\\/h1><p>从刚入高中就知道有竞赛这种事情，但是到了大概高一下学期的样子，才报名了学校组织的 OI 培训。按 NOIP 的年份来说，那一个赛季应该是 2015-2016 年，那一年我们学校参加的人数少得可怜，加上我，2018 届的总共就只有 6 个人来听课，那一年 18 届报名初赛的人数只有 5 个人。最后入围的只有 3 个人，这其中 18 届的只有我。<\\/p>\n<p>也不知道是怎样的一种阴差阳错，当年那会儿真的什么都不会，暴力都打不全，什么都不懂，就连一道题没有想法都不懂得打暴力骗个几十分的。不过，或许很多的 OIer，最开始应该都有这样的经历吧。<\\/p>\n<p>我并不像很多人一样从初中就开始算法相关的训练，甚至直到高一将要结束才开始这一段征程。因为入坑太晚，加上当时并没有意识到重要性，所以那一年最后的成绩并不是很好，只混了个省二滚粗。那一年我高二。有很多 OIer 在这条路上都止步于高二这一年。当初的我也曾经纠结过是否还要继续，那个时候家人是反对的。也因为课内繁忙和高二年下学期的生物竞赛，曾经放下了 OI 很长一段时间，当时真的确信自己不会再和 OI 有任何的关系了。现在想想，那一段咸鱼的时间真的很让人追悔。<\\/p>\n<h1 id=\"0x01\"><a href=\"#0x01\" class=\"headerlink\" title=\"0x01\"><\\/a>0x01<\\/h1><p>直到今年的 7 月份我才开始了这一个赛季的准备，因为 7 月顶着落下两天文化课的风险去参加了省里组织的夏令营——到夏令营快结束的那几天，高三狗们已经开学了。八月，九月……一直都是处于一种肝着文化课，然后一有空就刷 HDU 的状态，虽然并没有抽出多少时间，当初的 200 题 flag 也倒了，不过直到比赛前，统计一下 HDU+luogu+CF+… 以及线下的通过的题大概也有一百多的样子了，这样说起来也不算没努力过了吧。<\\/p>\n<p>从 9 月开始我们学校就开始了初赛的复习。今年的人数相比去年真的是翻了好多翻；初赛复习那一会儿，人多的能坐满整个机房。带领大家复习的重任交给了我校一位高二的选手 P 同学，在这里真的很感谢他给 19 届的选手们写 PPT、上课什么的（<s>虽然复习课我似乎一节都没时间去<\\/s>）。凭借着我市今年 350+ 的人数报名考试，以及省夏的团体总分和参加人数争取来的两个奖励名额，我们学校入围复赛的人数成功地成为了漳州市的最值，总共有 14 名选手入围复赛，其中和我一样是高三狗的还有两个。<\\/p>\n<p>听到这个成绩的时候我们大家都很感动，P 同学说他终于实现了把所有的选手都拉扯进复赛的梦想，当时我也觉得很开心。<\\/p>\n<p>我们一度觉得，我校 OI 的巅峰就要来了。<\\/p>\n<h1 id=\"0x02\"><a href=\"#0x02\" class=\"headerlink\" title=\"0x02\"><\\/a>0x02<\\/h1><p>10 月到 11 月这一段准备的日子，很忙碌，很累，但是也很充实。<\\/p>\n<p>其实每天都盼望着夜晚的到来，因为每天晚上刷完文化课的作业之后，就是撸题的时间。下到入门水题上到省选题，几乎我都有碰过（能不能做出来是另一回事了）。经历过绞尽脑汁看了题解也不知从何开始的无助，也经历过看到题目稍加思考一遍过的开心。这样的情绪变化可能会让人觉得很幼稚吧。有时候真的做得很累的时候，会停下来在 LINE 里和可爱的小姐姐说很多话，道完晚安之后又开始向没有通过的题目发起尝试。到现在一切都结束之后，回想起来，那真的是一段很美好的日子，仿佛重拾起了当年参加生物竞赛熬夜<s>背书<\\/s>的感觉。<\\/p>\n<p>19 届的选手们很多都选择了停文化课来专攻竞赛，有的停了一个月的课；一些 18 届的选手也放弃了部分的文化课在机房里写题目，甚至每天我回家的时候路过机房的那栋楼，都能看到三楼有一间房在黑暗中亮起了一缕阴暗的灯，就像夜空里的一颗星一般。那里有一群人在为自己的梦想努力着，敲打着键盘，直到晚自习结束的钟声响起才离开，甚至被锁在了楼里好几次……<\\/p>\n<h1 id=\"0x03\"><a href=\"#0x03\" class=\"headerlink\" title=\"0x03\"><\\/a>0x03<\\/h1><p>比赛的前一周。<\\/p>\n<p>这一段时间里我们又做了很多的事情。首先值得一提的就是我们出的模拟赛——四个人出了四道有毒的题目，本来打算让校内的选手练练手，最后出成了一场 luogu 上的公开比赛。出题真的要做好多的事情，还得背上自己造出来的锅= =不过我也算是出题坑过别人的人了呢（雾 那一场比赛办的很成功，虽然没有人 AK，但是参加的人数总共有 800 多人，也算是很有成就感了。<\\/p>\n<p>正好在这一周，课内的事情开始变得繁重了起来。其他的选手这一周里也参加了一下 luogu 的（打击）信心赛和 LibreOJ 的模拟。距离最后的日子很近了。<\\/p>\n<p>为了不让其他选手对试题产生恐惧感，我和 P 同学、L 同学决定再搞一场真正的信心赛，同时来一次全真模拟。那天是出发前一天的晚上，我第一次在小机房过了夜。虽然觉得自己出的题真的很简单，还考虑了很多，但是似乎所谓的信心赛还是搞砸了，因为最后有一位选手做着我出的那题做着做着哭了起来…………起来…………来…………<\\/p>\n<p>那时候觉得很愧疚，感觉好心办了坏事那样子。那天晚上找了一些人谈了一下心态的问题，但愿自己说的话他们可以听进去吧，不要有太大的压力。<\\/p>\n<p>夜深了，收拾完行装，明天就是出发的日子了。<\\/p>\n<h1 id=\"0x04\"><a href=\"#0x04\" class=\"headerlink\" title=\"0x04\"><\\/a>0x04<\\/h1><p>天亮了。外面天气很好。11 月 10 日，今天是出发的日子嘛？<\\/p>\n<p>中午十二点半的动车，留给我们的时间很宽松。所以早上我并没有直奔机房集合，而是先去解决了数理化三节文化课，下课铃一响迫不及待地拖着行李在众人奇异的目光中跑出了教学楼……来到机房，大家都已经等在那里了。<\\/p>\n<p>动车上的两个小时很快就过了。下了车的我们扛着一堆行李到十八中试机报到。顺着高德地图的指引，我们成功地绕着十八中绕了一整圈走到了一个被封死的后门= =……试机的时候闲得无聊打起了板子，用各种奇怪的方法写 a+b 问题。十八中的机子也是联想全家福，键盘跟学校机房那个一模一样，敲起来有种亲切感。<\\/p>\n<p>宾馆的环境不是很好，里面跟迷宫一样，卫生也不怎么好。那一天晚上洗澡的时候甚至没有热水，愣是顶着冷水洗了个澡……现在想起来没有感冒真是幸运极了。<\\/p>\n<p>看了一晚上的 Dinic 和打了板子之后就睡觉了，但是似乎有点紧张到 12 点多还没睡着。<\\/p>\n<h1 id=\"0x05\"><a href=\"#0x05\" class=\"headerlink\" title=\"0x05\"><\\/a>0x05<\\/h1><p>Day 1. 早上闹钟还没响就醒来了。毫无疑问昨晚并没有休息好。并且，考完 Day 1 之后是心态崩着出来的。<\\/p>\n<p>T1 当时一看觉得是个找规律，数据范围也验证了我的猜想。但是我的想法完全照着错误的方向走了，我对着可行方案的数列推了半天——我觉得规律大概是这个数列的周期性？然而两个小时都没有推出来。在这一题耗了这么长时间，这绝对是我 Day 1 最后悔的一件事情，以至于后面两题都没有认真做。出了考场同学说直接就是输出 a*b-a-b 的结论题，那会真的觉得自己好蠢，这么简单的问题都看不出来……<\\/p>\n<p>T2 是个大模拟，第一眼看还以为要我手动实现一个类似编译器的东西吓哭了，就放掉了，然后回去挣扎 T1……后来 T1 实在是出不来才发现，这就是个模拟……模拟……如果没有把时间都花在 T1 上我觉得 T2 能拿个挺可观的分数……<\\/p>\n<p>T3 的话真心没有什么思路，跑了个 SPFA + DFS 就歇了，还不会判零环。emmm……所以就很早地放弃了，出来之后听人说是最短路+拓扑序 DP，嘛算了，反正当时告诉我了也不一定调的出来。<\\/p>\n<p>等了半个小时出了程序回收结果。我们正要走的时候我突然发现，等等好像哪里不对，我的考号那一行长度似乎跟别人不太一样。仔细一看，我被漏收了一道题……emmm……我已经记不清当时是一种什么样的速度跑回 5 楼找监考了，然而他死咬定是我自己文件名和文件夹有问题，说什么收了两题另一题没收到这一定不是软件的问题，是自己的问题，然而我看了一下并没有看出是哪里有错……理论了半天并没有结果，他也不肯直接用 U 盘拷过去，一直争执到中午快一点的时候还是没有结果……期间我校有一位大兄弟强势地怼起了那个监考不负责任……嘛，很感谢他帮我发声，但是似乎情绪有点激动……<\\/p>\n<p>那时候按照他们的说法我觉得似乎已经无望了。我看看那张回收列表上有一位选手也没有被收到我被漏收的那一题，IP 地址只跟我差 1，我猜大概是跟我一样的问题并且也是 Linux 选手。后来我联系到他的时候果然验证了我的猜测，只是联系上他的时候似乎已经过了申诉的时间，我并不知道他最后能不能成功，最后我是成功了——因为那个主考一直说是我文件名有错，我们的带队老师问了福建的主办方之后，他们建议：既然是考生自己的问题，那就让他们试着建一个同名文件夹和同名文件，如果建不出来就说明是软件收取的锅。很幸运，这一波十分有力地证明了我的清白，主考最后也直接用 U 盘帮我拷走了程序……<\\/p>\n<p>总之……谢谢那些为了我的事情而挨饿到中午一点多的老师同学们……<\\/p>\n<p>那天中午吃了一顿好的（哪里不对的样子）。下午是出去找其他市的选手面基。晚上自己出去散了散步，福州那个地方晚上还挺热闹的。八点多的时候回去酒店里觉得很累，想躺了一会儿但是并没有睡着。收拾了一下行李，十一点多才上床睡觉。<\\/p>\n<p>但愿明天会友好一些吧。今天的题总结出来就是：<\\/p>\n<blockquote>\n<p>正解写不出，暴力写不完。不会小学题，<s>省三<\\/s> 不存在的 就退役。<\\/p>\n<\\/blockquote>\n<h1 id=\"0x06\"><a href=\"#0x06\" class=\"headerlink\" title=\"0x06\"><\\/a>0x06<\\/h1><p>Day 2. 早上起来觉得昨天的睡眠还行，昨天买了一堆面包没吃完，今天直接当了早餐2333<\\/p>\n<p>进了考场，希望不要发生昨天那样的事情。所幸的是没有。<\\/p>\n<p>T1 第一眼看有点慌，毕竟什么空间坐标系，说到空间的东西我就被前几周我校一个毒瘤出题人出的破空间计算题吓怕了。冷静下来看了一下觉得十分可做啊，先在草稿纸上写了一下自己的思路，然后 30 分钟很顺畅地敲完了代码，稍微调了一下就过了 example……然而出考场之后别人说会炸 long long……emmm……<\\/p>\n<p>T2 一看到名字宝藏，脑子灵光一闪——我好像在 HDU 见过一道也是以宝藏为主题的题目，那道题是个状压 DP 什么的………拉下去看了看数据范围，n &lt;= 12, 卧槽可把我乐坏了……于是稍微思考了一下可行解，把接下来的两个小时献给了这道题，然而最后大概转移错了还是怎么样连样例都没调出来QAQ……有点可惜。<\\/p>\n<p>突然想到 D1 那天晚上和 P 同学的对话：<\\/p>\n<blockquote>\n<p>P：“你觉得今年会不会考状压？”<br>我：“我觉得这概率挺小的吧……毕竟去年考了一题了……”<\\/p>\n<\\/blockquote>\n<p>下次我自己都不信我自己的毒奶了……<\\/p>\n<p>T3 看了一眼觉得不可做，直接扔了，也不知道有没有打错。<\\/p>\n<p>D2 给我的感觉还行（，至少跟去年差不多，也没有 D1T1 那么**的结论题……万万没想到会跪在 D1T1 上……<\\/p>\n<p>并没有出现昨天被漏收的现象，但是同校的一个选手打错了一个字母被少收了一题，这个无法申诉，有点可惜。<\\/p>\n<p>回程是下午四点多的动车，中午十二点多出来先分散着去吃了饭，当电灯泡陪一对 CP 第四次地逛了一遍三坊七巷……（别问我为什么是第四次，省夏的时候来过两次了），然后就坐地铁赶到火车站了，到漳州是七点不到的样子，回到家感觉浑身无力累的要死……<\\/p>\n<h1 id=\"0x07\"><a href=\"#0x07\" class=\"headerlink\" title=\"0x07\"><\\/a>0x07<\\/h1><p>回来了。<\\/p>\n<p>把行李拿出来的时候看到了紫书，想了想，把他捧放回了书架上。大概不怎么回去碰到它了吧，毕竟我已经是一名退役老狗了。那一刻觉得，心里空落落的，好像有什么东西丢了一样。<\\/p>\n<p>发了几条感叹的微博。开电脑的时候看到在动车上随便写的一些都念不通顺的退役感受，想了想还是删掉了。前几次竞赛都留下什么文字的回忆，这一回我要认真地记录一次。这篇迟到的退役感言直到回来的第二天晚上才出来。<\\/p>\n<p>早上去机房丢东西，发现一些熟悉的身影依然在那里。中午觉得很累也很难受，下午就没有再过去学校。听说下午有位选手因为付出了很多但是成绩很差泪崩了。也不知道如何安慰了，毕竟自己都凉凉了还能怎么安慰别人。但是我想说，有时候付出和收获不一定是正比，路还很长，课内努力是可以补回来的，而且你们还有一年的时间努力，还有一次机会，一次失败算不了什么。<\\/p>\n<p>而我，就不一样了。OI 已经跟我不再有关系了。<\\/p>\n<h1 id=\"0x08\"><a href=\"#0x08\" class=\"headerlink\" title=\"0x08\"><\\/a>0x08<\\/h1><p>两年的 OI 生涯给我带来了什么？<\\/p>\n<p>对于别人而言可能是奖项，是机会，<s>甚至是女票<\\/s>。而对于我，大概是一些知识、思考，以及最重要也最宝贵的——记忆和友谊这两样东西。<\\/p>\n<p>我想，将来的哪一天，当我回想起这段日子，回想起曾经的努力，回想起大家一起聚在机房写代码的那段时光，回想起这段友谊，回想到这篇文章，可能会有不一样的感觉。<\\/p>\n<p><span title=\" みんなで叶える物语。\">“大家一起实现梦想的故事。”<\\/span><\\/p>\n<p>是的，这一段不可磨灭记忆是大家共同创造的。不论是愉快的欢声，还是遗憾的泪水。但是，这就是我们的选择，这就是漳一赛艇队的 16 个人一起创造的故事。<\\/p>\n<p>“不忘初心”是 Day1 压缩包的解压密码，现在看起来确实是很暖心的一句话。天下没有不散的宴席，当我们最后因为各种各样的原因而各奔东西的时候，请不要忘记初心。我们努力过，失败过……但无论何时，都要记住自己最初入 OI 时心怀着的那个梦想。<\\/p>\n<p>谢谢那些鼓励过我的人，父母，亲人，朋友，同学，老师，还有一位特殊的人。<br>谢谢那些陪伴我走过这一段日子的学长和学弟学妹们。<\\/p>\n<p>…………<\\/p>\n<p>于是，当我们从这一场梦中醒来的时候，日子又将恢复成从前的样子。<\\/p>\n<h3 id=\"不悔梦归处，只恨太匆匆。\"><a href=\"#不悔梦归处，只恨太匆匆。\" class=\"headerlink\" title=\"不悔梦归处，只恨太匆匆。\"><\\/a>不悔梦归处，只恨太匆匆。<\\/h3><p><div id=\"muse-app\"><\\/div><\\/p>\n<script type=\"text\\/javascript\">\nvar playList = [{\n    title: '僕たちはひとつの光',\n    artist: 'μ\\'s',\n    cover:\n      'http:\\/\\/p3.music.126.net\\/_gfatO4AhgiBKDwOgrHEQg==\\/7706477001119945.jpg',\n    src: 'http:\\/\\/other.web.rg01.sycdn.kuwo.cn\\/resource\\/n2\\/27\\/71\\/3547184289.mp3',\n    lyric:\n      '[00:27.540]Ah! ほのかな予感から始まり\\n[00:32.970]Ah! 希望が星空駈けて\\n[00:38.450]花を咲かせるにっこり笑顔は\\n[00:43.920]ずっと同じさ 友情の笑顔\\n[00:49.160]\\n[00:49.510]忘れない いつまでも忘れない\\n[00:54.940]こんなにも心がひとつになる\\n[01:00.410]世界を見つけた喜び(ともに)歌おう\\n[01:09.940]最後まで(僕たちはひとつ)\\n[01:16.660]\\n[01:17.040]小鳥の翼がついに大きくなって\\n[01:25.010]旅立ちの日だよ\\n[01:28.130]遠くへと広がる海の色暖かく\\n[01:36.050]夢の中で描いた絵のようなんだ\\n[01:40.300]切なくて時をまきもどしてみるかい?\\n[01:52.490]No no no いまが最高!\\n[01:58.620]\\n[02:20.460]みんなと出会えたこと嬉しくて\\n[02:27.090]離れたくないよ本当だよ\\n[02:31.550]涙はいらない このまま踊ろう\\n[02:36.980]手を振ってもっと振って\\n[02:42.890]\\n[02:45.370]光を追いかけてきた僕たちだから\\n[02:53.190]さよならは言わない\\n[02:56.320]また会おう 呼んでくれるかい?\\n[03:00.300]僕たちのこと\\n[03:04.320]素敵だった未来に繋がった夢\\n[03:08.560]夢の未来 君と僕のLIVE&LIFE\\n[03:15.430]\\n[03:37.800]小鳥の翼がついに大きくなって\\n[03:45.640]旅立ちの日だよ\\n[03:48.760]遠くへと広がる海の色暖かく\\n[03:56.730]夢の中で描いた絵のようなんだ\\n[04:00.990]切なくて時をまきもどしてみるかい?\\n[04:13.240]No no no いまが最高!\\n[04:18.670]だってだって、いまが最高!\\n[04:30.500]\\n[04:31.520]Ah! ほのかな予感から始まり\\n[04:37.410]Ah! 光を追いかけてきたんだよ…\\n[04:48.410]',\n    translation:\n      'Ah! 从微小的预感开始\\nAh! 希冀在星空中驰骋\\n笑开花儿的真切笑容是\\n亘久不变 友情的笑容\\n\\n无法忘却 永远铭记\\n心灵能如此合而为一\\n让我们（一同）歌唱发现世界的喜悦\\n直到最后（我们已成为一体）\\n\\n小鸟终也羽翼丰满\\n到了展翅翱翔的日子\\n一望无垠的大海 颜色是如此温暖\\n如同在梦中描绘的画\\n若感到惆怅要让时光倒流吗？\\nNo no no 此刻就是最好的！\\n\\n与大家相遇是如此幸福\\n不舍别离 真的\\n不必流泪 就此起舞吧\\n挥舞起手 用力挥舞吧\\n\\n因为我们已经追上了那束光芒\\n所以不需要道别\\n再会之时 能否轻唤\\n我们的名字？\\n通往美好未来的梦想\\n梦想的未来 属于你与我的LIVE&LIFE\\n\\n小鸟终也羽翼丰满\\n到了展翅翱翔的日子\\n一望无垠的大海 颜色是如此温暖\\n如同在梦中描绘的画\\n若感到惆怅要让时光倒流吗？\\nNo no no 此刻就是最好的！\\n因为因为，此刻就是最好的！\\n\\nAh! 从微小的预感开始\\nAh! 追逐到了那束光芒……'\n  }];\n\nMUSE.render(playList, document.getElementById('muse-app'));\n<\\/script>\n\n<h1 id=\"終わり\"><a href=\"#終わり\" class=\"headerlink\" title=\"(終わり)\"><\\/a>(終わり)<\\/h1>",
      "excerpt": "<p>呐。听说按照 OI 界的传统，每位 OIer 退役的时候，都要写一篇退役感言。<br>于是，当我们从这一场梦中醒来的时候，日子又将恢复成从前的样子。<br>不悔梦归处，只恨太匆匆。<br>",
      "slug": "noip-retired-feeling",
      "published": true,
      "layout": "post",
      "path": "blog/post/noip-retired-feeling/",
      "permalink": "https://kirainmoe.com/blog/post/noip-retired-feeling/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "diary",
          "slug": "diary",
          "path": "tags/diary/",
          "permalink": "https://kirainmoe.com/tags/diary/",
          "length": 3
        }
      ],
      "categories": []
    },
    {
      "title": "在 Linux 下配置 lemon 评测系统",
      "date": "2017-11-10T11:45:59.000Z",
      "modified": "2018-01-07T05:26:54.797Z",
      "content": "<p>Linux 下那种能用来批量评测的软件看起来很少的样子，找了很久只找到了一个 CCF 官方的 arbiter 和跨平台的 lemon. arbiter 在 Arch Linux 上死活装不成（主要是老旧的 qt3），于是就只能把目光投向 lemon 了。虽然 lemon 用起来比较危险（因为 lemon 没有沙箱机制），不过本着能用就行的原则，就尝试着配置了一下它。这里只讲讲它在 Arch Linux 下的配置和使用。<\\/p>\n<a id=\"more\"><\\/a>\n<h1 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"><\\/a>编译<\\/h1><p>lemon 基于 qt4 开发（<s>怪不得可以跨平台<\\/s>），所以我们先安装 qt4 的环境。当然你需要有一个 DE\\/WM 来运行。<\\/p>\n<pre><code class=\"bash\"># pacman -S qt4\n<\\/code><\\/pre>\n<p>然后我们搞到 lemon 的源代码。GitHub 上可以找到，一个是原版，一个是做了一些修改的：<\\/p>\n<blockquote>\n<p>原版 project-lemon: <a href=\"https:\\/\\/github.com\\/zhipeng-jia\\/project-lemon\" target=\"_blank\" rel=\"external\">https:\\/\\/github.com\\/zhipeng-jia\\/project-lemon<\\/a><br>修改版 project-lemon: <a href=\"https:\\/\\/github.com\\/Sojiv\\/Project_lemon\" target=\"_blank\" rel=\"external\">https:\\/\\/github.com\\/Sojiv\\/Project_lemon<\\/a><\\/p>\n<\\/blockquote>\n<p>其中原版的话需要修改文件，否则会编译出错，具体是修改<code>qtsingleapplication\\/qtlocalpeer.cpp:96:54<\\/code>文件，把以下代码：<\\/p>\n<pre><code class=\"cpp\">socketName += QLatin1Char(&#39;-&#39;) + QString::number(::getuid(), 16);\n<\\/code><\\/pre>\n<p>修改为：<\\/p>\n<pre><code class=\"cpp\">socketName += QLatin1Char(&#39;-&#39;) + QString::number(QtLP_Private::getuid(), 16);\n<\\/code><\\/pre>\n<p>接着 qmake 一下，然后就可以编译了：<\\/p>\n<pre><code class=\"bash\"># qmake-qt4 lemon.pro\n# make\n<\\/code><\\/pre>\n<p>编译完之后，可以在目录下找到一个可执行文件 <code>lemon<\\/code>，这就是编译好的程序了。所以我们可以把这个程序搞到<code>\\/usr\\/bin\\/<\\/code>里去，这样我们下次运行直接在终端里敲<code>lemon<\\/code>就可以了。<\\/p>\n<h1 id=\"配置数据\"><a href=\"#配置数据\" class=\"headerlink\" title=\"配置数据\"><\\/a>配置数据<\\/h1><p>首先新建一个测试，然后把数据复制到测试文件夹下的 <code>data<\\/code> 目录里。例如我要配置一道名为 <code>events<\\/code> 的试题，则我把以下格式的数据文件复制到 <code>data\\/events<\\/code> 目录下：<\\/p>\n<pre><code>events1.in   events1.ans   events2.in   events2.ans   events3.in   events3.ans\n...\n<\\/code><\\/pre><p>然后我们首先新建试题，填好试题信息、时空限制、比较方式等等，然后右键该试题，选择添加多个测试点，然后接下来会让我们键入能匹配所有输入输出数据文件名的一个正则表达式。以上面那个为例，我们写出来的应该是下面这样的：<\\/p>\n<pre><code>input file: events\\/events&lt;1&gt;.in\noutput file: events\\/events&lt;1&gt;.ans\n\n&lt;1&gt; .*\n<\\/code><\\/pre><p>这里需要一点正则表达式的知识，如果你不会的话，那就按照上面的模板来就可以了。<\\/p>\n<h1 id=\"评测时无法运行程序\"><a href=\"#评测时无法运行程序\" class=\"headerlink\" title=\"评测时无法运行程序\"><\\/a>评测时无法运行程序<\\/h1><p>配置完数据把 std 复制到 source 文件夹里。然后尝试评测，提示<code>Can not start program (无法运行程序)<\\/code>。这个问题我们需要修改编译参数，如果不修改编译参数，lemon 默认是这样编译一个 C++ 程序的：<\\/p>\n<pre><code class=\"bash\">g++ -o %s %s.cpp\n<\\/code><\\/pre>\n<p>我们在编译参数里加上一个<code>-lm<\\/code>，这样编译出来的程序就可以运行了。如果是 Windows 上就加上一个<code>-m32<\\/code>参数。<\\/p>\n<h1 id=\"栈溢出等问题\"><a href=\"#栈溢出等问题\" class=\"headerlink\" title=\"栈溢出等问题\"><\\/a>栈溢出等问题<\\/h1><p>一开始没注意这个，开了 -O2 才发现原来不开 -O2 能 AC 的程序居然 RE 了。一查发现是栈溢出，原来 Linux 下默认栈是 8MB= =这个当然不够用啦，所以我们可以修改评测时栈空间的限制。参考 NOIP2016 D1T2 附件提供的 Linux 下开栈的做法，退出 lemon 并打开终端，运行以下命令：<\\/p>\n<pre><code class=\"bash\">$ ulimit -s 233333\n<\\/code><\\/pre>\n<p>这里嘛就是把我们的栈调用空间开大，大概开到 200MB 多（后面那一串数字单位是 KB）。然后重新在当前终端里运行 lemon，就不会爆栈了。需要注意的是 ulimit 只对当前终端窗口有效，如果你退出了终端或者开了另一个终端窗口，就需要重新设置。<\\/p>\n<p>暂时就遇到了这些问题喵。 &gt; &lt;<\\/p>\n",
      "excerpt": "<p>Linux 下那种能用来批量评测的软件看起来很少的样子，找了很久只找到了一个 CCF 官方的 arbiter 和跨平台的 lemon. arbiter 在 Arch Linux 上死活装不成（主要是老旧的 qt3），于是就只能把目光投向 lemon 了。虽然 lemon 用起来比较危险（因为 lemon 没有沙箱机制），不过本着能用就行的原则，就尝试着配置了一下它。这里只讲讲它在 Arch Linux 下的配置和使用。<\\/p>",
      "slug": "configure-lemon-judger-for-linux",
      "published": true,
      "layout": "post",
      "path": "blog/post/configure-lemon-judger-for-linux/",
      "permalink": "https://kirainmoe.com/blog/post/configure-lemon-judger-for-linux/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "lemon",
          "slug": "lemon",
          "path": "tags/lemon/",
          "permalink": "https://kirainmoe.com/tags/lemon/",
          "length": 1
        },
        {
          "name": "linux",
          "slug": "linux",
          "path": "tags/linux/",
          "permalink": "https://kirainmoe.com/tags/linux/",
          "length": 1
        }
      ],
      "categories": []
    },
    {
      "title": "愤怒的小鸟 (Review / NOIP2016 D2T3)",
      "date": "2017-11-03T12:36:17.000Z",
      "modified": "2018-01-07T05:26:49.253Z",
      "content": "<p>嘛。去年考场上遇到这题的时候一脸懵逼……现在回过头来看就好多了，但是有一些细节还是要做清楚。 (\\/ω＼)<\\/p>\n<a id=\"more\"><\\/a>\n<p>题目：<a href=\"https:\\/\\/www.luogu.org\\/problemnew\\/show\\/2831\" target=\"_blank\" rel=\"external\">https:\\/\\/www.luogu.org\\/problemnew\\/show\\/2831<\\/a><\\/p>\n<p>题目就是呢，要构造最少条的抛物线，消灭掉所有的小猪~然后求最少的抛物线数量~观察题目我们可以发现——特殊指令 m 是没有什么卵用的= =<\\/p>\n<p>然后接下来我们分析题目：求构造的最少抛物线数量 → 构造抛物线直到把所有的猪都打掉 → 每个猪打一次就没了，而且抛物线的轨迹不会改变 → 对于一条抛物线，如果能打掉尽可能多的猪那么再好不过 → n &lt;= 18 → ……<\\/p>\n<p>好的，看到数据范围大家应该有一些想法了。大部分人会想到搜索 + 剪枝，也有写记忆化搜索的……然而这两种都不太好写，但是能解是肯定的，这里就不多说这个了。<\\/p>\n<p>n 才 18，还有另一种做法呀~那就是状态压缩 DP！( ＞ω＜) 表示对于能理解状态压缩的玩家们，把这题写成状态压缩比写成搜索题好写多了~而且效率也很高的说。如果不能理解状压的话想写就比较麻烦辣。<\\/p>\n<p>那么我们要做什么呢？先设计个 DP 状态和方程呗，显然我们应该<strong>用<code>dp[i]<\\/code>来表示击败的猪的二进制状态为 i 的时候，需要构造的抛物线的最小数目。<\\/strong>二进制状态为 i 是什么概念呢，这里简单地说一下，比如说总共有 3 只猪，这时候你把第一只（标号为 0）和第二只（标号为 1）的猪打掉了，那么 i 就是<code>011<\\/code>咯（打掉第几只猪，状态 i 的二进制下第几位就是 1），同理如果你把三只猪都打死了，那么 i 就是<code>111<\\/code>.<\\/p>\n<p>所以，根据状态压缩 DP 的原理，我们先枚举合法的每一个状态，也就是 <code>i = 1<\\/code> 到 <code>(1 &lt;&lt; n) - 1<\\/code>。对于每一个状态，随便举出其中包含的一个点 k，那么 <code>dp[i]<\\/code> 最坏的情况应该是：在没打掉第 k 只猪之前的最小值 + 1，我们把这个值作为初值赋给 <code>dp[i]<\\/code>: <code>dp[i] = dp[i &amp; ~(1 &lt;&lt; k)] + 1<\\/code>, 或者表示成<code>dp[i] = dp[i - (1 &lt;&lt; k)] + 1<\\/code>.<\\/p>\n<p>然后我们再枚举出当前状态包含的另一个点 t (t != k), 取<code>dp[i]<\\/code>（上文已经更新过了）和<code>dp[j] + 1<\\/code>的最小值即可。因为我们知道，两点构成一条抛物线，所以我们可以找两个，这两个点一定可以勾出一条抛物线，然后从当前状态 i 中去掉<strong>这条抛物线经过的所有的小猪<\\/strong>，这样就得到了状态 j （╯‵□′）╯︵┴─┴ ：<code>dp[i] = min(dp[i], dp[i - (i &amp; fstate[i][j])] + 1)<\\/code>, 这里 <code>fstate[i][j]<\\/code> 的意思请往下看。<\\/p>\n<p>那么还有一个问题，就是我们怎么知道 k 和 t 构成的那条抛物线经过了哪些猪呢？这时候我们可以枚举任意两个点算出经过这两个点的形如<code>y=ax^2+bx, a &lt; 0<\\/code>的抛物线，再计算这条抛物线对其他点的影响，把它们整理成一个二进制状态；简言之，两点（当然，还有原点 0, 0）可以确定一条抛物线，我们用<code>fstate[i][j]<\\/code>表示能干掉第 i 和第 j 只小猪的这条抛物线，最终能打掉的猪的状态，这样上面的 j 就可以推出来了。<code>fstate<\\/code>数组的计算就是，选取两个点计算 a 和 b，然后枚举其他的点，如果<code>aXk^2 + bXk = Yk<\\/code>成立的话，那么就把这个点 k 合并到<code>fstate[i][j]<\\/code>里去：<code>fstate[i][j] |= (1 &lt;&lt; k)<\\/code>.<\\/p>\n<p>好了。至此这道题已经做得差不多了，还有一个很关键的地方可能就是——抛物线怎么算 (￣▽￣)~这里主要要 care 一下精度的问题: <code>const double eps = 1e-7;<\\/code>.<\\/p>\n<p>然后我们对于两个已知点 A(x1, y1), B(x2, y2)，我们可以得到两个等式：<\\/p>\n<pre><code>y1 = a * x1^2 + b * x1\ny2 = a * x2^2 + b * x2\n<\\/code><\\/pre><p>移项变形一下，我们可以得到：<\\/p>\n<pre><code>b = (y1 - a * x1^2) \\/ x1\nb = (y2 - a * x2^2) \\/ x2\n<\\/code><\\/pre><p>消去参数 b，然后得到关于 a 的一个等式，整理之后我们可以得到：<\\/p>\n<pre><code>a = (x2 * y1 - x1 * y2) \\/ (x1 * x2 * (x1 - x2))\n<\\/code><\\/pre><p>其中 x1, x2, x1-x2 均不为 0. 得到 a 之后把 a 带回上面一个含 b 的式子就可以了(o ° ω ° O ) 。<\\/p>\n<p>然后这道题就做完啦。<\\/p>\n<pre><code class=\"cpp\">#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;cmath&gt;\n#include &lt;algorithm&gt;\n#define db double\nusing namespace std;\nconst int MAXN = 18;\nconst int INF = 1e9 + 7;\nconst db eps = 1e-7;\nstruct Point {\n    db x, y;\n}; \nPoint p[MAXN + 5];\nint dp[1 &lt;&lt; MAXN];\nint fstate[MAXN][MAXN];\nint n, m, t;\nint main()\n{\n    scanf(&quot;%d&quot;, &amp;t);\n    while (t--)\n    {\n        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n        for (int i = 0; i &lt; n; i++)\n        {\n            scanf(&quot;%lf%lf&quot;, &amp;p[i].x, &amp;p[i].y);\n        }\n\n        memset(fstate, 0, sizeof fstate);\n\n        for (int i = 0; i &lt; n; i++)\n        {\n            for (int j = 0; j &lt; n; j++)\n            {\n                if (i == j) {\n                    continue;\n                }\n\n                db x1 = p[i].x, x2 = p[j].x, y1 = p[i].y, y2 = p[j].y;\n                if (x1 &lt; eps || x2 &lt; eps || abs(x1 - x2) &lt; eps) {\n                    continue;\n                }\n                db a = (x2 * y1 - x1 * y2) \\/ (x1 * x2 * (x1 - x2));\n                if (a &gt; -eps) {\n                    continue;\n                }\n\n                db b = y1 \\/ x1 - a * x1;\n                int final = (1 &lt;&lt; i) | (1 &lt;&lt; j);\n                for (int k = 0; k &lt; n; k++)\n                {\n                    db xk = p[k].x, yk = p[k].y;\n                    if (abs(a * xk * xk + b * xk - yk) &lt; eps) {\n                        final |= (1 &lt;&lt; k);\n                    }\n                }\n                fstate[i][j] = final;\n            }\n        }\n\n        fill(dp, dp + (1 &lt;&lt; n), INF);\n        dp[0] = 0;\n        for (int i = 1; i &lt; (1 &lt;&lt; n); i++)\n        {\n            int cur = 0;\n            for (int j = 0; j &lt; n; j++)\n            {\n                if (i &amp; (1 &lt;&lt; j)) {\n                    cur = j;\n                    break;\n                }\n            }\n\n            \\/\\/ dp[i] = dp[i - (1 &lt;&lt; cur)] + 1;\n            dp[i] = dp[i &amp; ~(1 &lt;&lt; cur)] + 1;\n\n            for (int j = 0; j &lt; n; j++)\n            {\n               if (i &amp; (1 &lt;&lt; j) &amp;&amp; j != cur) {\n                    dp[i] = min(dp[i], dp[i &amp; ~(i &amp; fstate[cur][j])] + 1);\n                    \\/\\/ dp[i] = min(dp[i], dp[i - (i &amp; fstate[cur][j])] + 1);\n               }\n            }\n        }\n\n        printf(&quot;%d\\n&quot;, dp[(1 &lt;&lt; n) - 1]);\n    }\n    return 0;\n}\n<\\/code><\\/pre>\n",
      "excerpt": "<p>嘛。去年考场上遇到这题的时候一脸懵逼……现在回过头来看就好多了，但是有一些细节还是要做清楚。 (\\/ω＼)<\\/p>",
      "slug": "angry-birds-state-compressing",
      "published": true,
      "layout": "post",
      "path": "blog/post/angry-birds-state-compressing/",
      "permalink": "https://kirainmoe.com/blog/post/angry-birds-state-compressing/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "algorithm",
          "slug": "algorithm",
          "path": "tags/algorithm/",
          "permalink": "https://kirainmoe.com/tags/algorithm/",
          "length": 8
        },
        {
          "name": "dynamic programming",
          "slug": "dynamic-programming",
          "path": "tags/dynamic-programming/",
          "permalink": "https://kirainmoe.com/tags/dynamic-programming/",
          "length": 1
        }
      ],
      "categories": []
    }
  ],
  "menu": {
    "Home": "/",
    "Guestbook": "/pages/guestbook/",
    "Friends": "/pages/friends/",
    "About": "https://about.me/kirainmoe"
  },
  "socials": {
    "twitter": "https://twitter.com/yume_kankawa",
    "github": "https://github.com/kirainmoe",
    "weibo": "https://weibo.com/returnnnn",
    "medium": "https://medium.com/@kotori",
    "lastfm": "https://www.last.fm/user/kirainmoe"
  },
  "avatar": "https://secure.gravatar.com/avatar/c47187d311099868de825697fa419654?s=200&r=G",
  "menuIcon": {
    "Home": "home",
    "Guestbook": "book",
    "Friends": "users",
    "Archives": "tags",
    "About": "id-card-o"
  },
  "disqus": "yume-diary",
  "prev": 0,
  "next": 2
}</script>
  <!-- hook node of React -->
  <div id="himawari-app"></div>

  
    <!-- scripts list from theme config.yml -->
    
      <script src="https://unpkg.com/muse-player/dist/assets/muse-player.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/prism.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-clike.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-php.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-css.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-c.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-cpp.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-javascript.min.js"></script>
    
      <script src="/common.js"></script>
    
      <script src="/main.js"></script>
    
  

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-111347233-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-111347233-1');
  </script>

</body>
</html>
