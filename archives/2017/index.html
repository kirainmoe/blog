<!-- Himawari no Yakusoku -->

<!DOCTYPE html>
<html lang="Zh-cn">
<head>
  <meta charset="UTF-8">
  <meta name="theme-color" content="#FF98A8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Archives: 2017 [ YumeのDiary ]</title>
  <meta name="description" content="6 年間、共に歩んでくれたあなたへ。">
  <link rel="manifest" href="/manifest.json">
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    
      <link rel="stylesheet" href="/himawari.css">
    
  
</head>
<body>
  
  <!-- infos -->
  <script type="text/json" id="himawari-json">{
  "title": "YumeのDiary",
  "siteTitle": "YumeのDiary",
  "description": "6 年間、共に歩んでくれたあなたへ。",
  "author": "Yume Kankawa",
  "route": "year",
  "format": "blog/:layout/:title/",
  "posts": [
    {
      "title": "使用 Typescript 写 React 遇到的一些坑",
      "date": "2017-12-19T14:12:18.000Z",
      "modified": "2018-01-07T05:18:37.656Z",
      "content": "<p>自从学了 Typescript 之后，写 React 项目什么的就一直没离开过 TS 了。虽然 Typescript 大法好，不过鉴于 Typescript 严格的类型机制（事实上从某种意义上说一点都不严），导致在使用 Typescript 开发 React 的时候遇到了一些小小的问题（对 TS 好感度–）……这里就简单的记录一下。<\\/p>\n<a id=\"more\"><\\/a>\n<h2 id=\"使用-ES7-装饰符-decorator-时提示返回类型未定义\"><a href=\"#使用-ES7-装饰符-decorator-时提示返回类型未定义\" class=\"headerlink\" title=\"使用 ES7 装饰符 (decorator) 时提示返回类型未定义\"><\\/a>使用 ES7 装饰符 (decorator) 时提示返回类型未定义<\\/h2><p>这个问题发生在使用 <a href=\"https:\\/\\/github.com\\/concretesolutions\\/redux-zero\" target=\"_blank\" rel=\"external\">redux-zero<\\/a> （大概是个懒人版的 Redux）的时候。<\\/p>\n<p>一般来说，connect 一个组件大概要这样写，不管是用 react-redux 还是 redux-zero：<\\/p>\n<pre><code class=\"javascript\">import { connect } from &#39;redux-zero\\/react&#39;;\n\n\\/* ... *\\/\n\nclass MyComponent extends React.Compoent {\n    render() {\n        return (\\/* ... *\\/);\n    }\n}\n\nexport default connect(mapStateToProps, actions)(MyComponent);\n<\\/code><\\/pre>\n<p>有时候我们可以偷懒用上 ES7 的 decorator 特性写得简洁一些：<\\/p>\n<pre><code class=\"javascript\">@connect(mapStateToProps, actions)\nexport default class MyCompoent extends React.Component {\n    \\/\\/ ...\n}\n<\\/code><\\/pre>\n<p>这两种写法效果是一样的。然而在 Typescript 中，以上代码会报这样的错误：<\\/p>\n<pre><code>[ts] Unable to resolve signature of class decorator when called as an expression.\n<\\/code><\\/pre><p>点一下 <code>connect<\\/code> 方法的定义，可以看到在 <code>connect.d.ts<\\/code> 的 17 行有这样的一句：<\\/p>\n<pre><code class=\"javascript\">export default function connect(mapToProps: any, actions?: {}): (Child: any) =&gt; (props: any) =&gt; JSX.Element;\n<\\/code><\\/pre>\n<p>看着似乎没什么问题，但是：<\\/p>\n<pre><code class=\"javascript\">\\/\\/ test 1\nconst test = (component: any) =&gt; {\n    console.log(component);\n}\n@test\nclass MyComponent extends React.Component {\n    \\/\\/ ...\n}\n\\/\\/ passed\n<\\/code><\\/pre>\n<p>把定义 <code>test<\\/code> 的方法换一下：<\\/p>\n<pre><code class=\"javascript\">\\/\\/ test 2\nfunction test(component: any) {\n    console.log(component);\n}\n@test\nclass MyComponent extends React.Component {\n    \\/\\/ ...\n}\n\\/\\/ compile failed\n<\\/code><\\/pre>\n<p>看起来 Typescript 并不允许把用 function 定义的函数作为装饰符来使用呢。但是我们总不能去改依赖的代码吧，这个时候怎么办呢w<\\/p>\n<p>如果一些项目有 DefinitelyTyped 的 typing 文件的话，可以尝试安装 <code>@types\\/xxxxx<\\/code>, 例如 <code>@types\\/react-redux<\\/code>。<\\/p>\n<p>如果没有的话，答案就是自己再包上一层，以 <code>redux-zero<\\/code> 的 <code>connect()<\\/code> 为例：<\\/p>\n<pre><code class=\"javascript\">\\/\\/ utils\\/connect.ts\nimport { connect as connectComponent } from &#39;redux-zero\\/react&#39;;\n\nexport const connect = (mapStateToProps: any, actions: any) =&gt; {\n  return (target: any) =&gt; (\n    connectComponent(mapStateToProps, actions)(target) as any\n  );\n};\n\n\\/\\/ component\nimport { connect } from &#39;utils\\/connect&#39;;\n\\/* ... *\\/\n@connect(mapStateToProps, actions)\nexport defalt class MyComponent extends React.Component {\n    \\/\\/ ...\n}\n<\\/code><\\/pre>\n<p>这样就可以啦。<\\/p>\n<h2 id=\"自定义-JSX-元素在-JSX-IntrinsicElements-不存在\"><a href=\"#自定义-JSX-元素在-JSX-IntrinsicElements-不存在\" class=\"headerlink\" title=\"自定义 JSX 元素在 JSX.IntrinsicElements 不存在\"><\\/a>自定义 JSX 元素在 JSX.IntrinsicElements 不存在<\\/h2><p>我并不知道怎么描述这个问题比较合适，场景是需要批量渲染一个对象中所有的组件：<\\/p>\n<pre><code class=\"javascript\">const components = {\n    comp1: Compnent1,\n    comp2: Component2,\n    \\/\\/ ...\n},\n    keys = Object.keys(components);\n\nconst res: Array&lt;any&gt; = [];\nkeys.forEach(key =&gt; {\n    const tmp: any = components[key];\n    res.push(&lt;tmp key={key} \\/&gt;);\n});\n<\\/code><\\/pre>\n<p>上面的代码会返回这样的错误：<\\/p>\n<pre><code>[ts] Property &#39;tmp&#39; does not exist on type &#39;JSX.IntrinsicElements&#39;.\n<\\/code><\\/pre><p>原因是 Typescript 要求 JSX 组件变量名的第一个字母为大写，如果不是的话 TS 便认为它不是个合法的 JSX 元素。所以把 <code>tmp<\\/code> 改成 <code>Tmp<\\/code> 就可以惹。<\\/p>\n",
      "excerpt": "<p>自从学了 Typescript 之后，写 React 项目什么的就一直没离开过 TS 了。虽然 Typescript 大法好，不过鉴于 Typescript 严格的类型机制（事实上从某种意义上说一点都不严），导致在使用 Typescript 开发 React 的时候遇到了一些小小的问题（对 TS 好感度–）……这里就简单的记录一下。<\\/p>",
      "slug": "some-problems-of-typescript-with-react",
      "published": true,
      "layout": "post",
      "path": "blog/post/some-problems-of-typescript-with-react/",
      "permalink": "https://kirainmoe.com/blog/post/some-problems-of-typescript-with-react/",
      "tags": [
        {
          "name": "react",
          "slug": "react",
          "path": "tags/react/",
          "permalink": "https://kirainmoe.com/tags/react/",
          "length": 3
        },
        {
          "name": "frontend",
          "slug": "frontend",
          "path": "tags/frontend/",
          "permalink": "https://kirainmoe.com/tags/frontend/",
          "length": 4
        },
        {
          "name": "typescript",
          "slug": "typescript",
          "path": "tags/typescript/",
          "permalink": "https://kirainmoe.com/tags/typescript/",
          "length": 1
        },
        {
          "name": "javascript",
          "slug": "javascript",
          "path": "tags/javascript/",
          "permalink": "https://kirainmoe.com/tags/javascript/",
          "length": 1
        }
      ],
      "categories": [
        {
          "name": "前端",
          "slug": "前端",
          "path": "categories/前端/",
          "permalink": "https://kirainmoe.com/categories/前端/",
          "length": 4
        }
      ],
      "illust": "https://www.typescriptlang.org/assets/images/foreground_bluprint.svg"
    },
    {
      "title": "使用 React 制作全站单页主题的实践",
      "date": "2017-12-17T12:23:36.000Z",
      "modified": "2018-01-07T05:26:51.942Z",
      "content": "<p>算起来已经有很长一段时间没有折腾过主题了。之前一直都没有什么大变化的原因是，我一直在想一种能否把整个站都做成真正意义上的单页 App（就是不依靠 PJAX 实现）。也想过很多实现的方法，只是一直没有把这些方法真正写成实物验证一下可行性。前一段时间在把 Canvas 的主题用 webpack 重构之后，突发奇想到了一种可行度很高的策略。你现在看到的这个主题，大概就是这个脑洞的产物了。<\\/p>\n<a id=\"more\"><\\/a>\n<p>下文开始瞎扯，如果有什么讲得不对的地方欢迎提出来。<\\/p>\n<h1 id=\"单页化主题有什么不同呢\"><a href=\"#单页化主题有什么不同呢\" class=\"headerlink\" title=\"单页化主题有什么不同呢\"><\\/a>单页化主题有什么不同呢<\\/h1><p>有关于是将站点单页化还是多页化，以及单页化是否可以给用户更好的体验等问题，一直以来都有很多的观点。但是从现今对各大网站的分析看，毫无疑问单页化的趋势更占上风，个人认为单页化的用户体验也更好一些。<\\/p>\n<p>用 PJAX 等技术实现单页化的主题确实已经有很多人做过了，但是对于做出那种基于前端组件化和路由分发的 SPA，并没有见到多少相关的尝试（可能是我见识短浅 emmm）。<\\/p>\n<p>相比起使用 PJAX 实现的单页化，SPA 实现有下面这些特点：<\\/p>\n<ul>\n<li>更灵活。SPA 对后端的要求更小（当然前提是你不做 SSR），服务端只需要给出渲染一个页面所需要的数据，其他的事情都可以交给前端来做。<\\/li>\n<li>更科学。使用 SPA 实现单页化，就可以运用上一些诸如单项数据流的<s>哲学<\\/s>。<\\/li>\n<li>更清晰。SPA 的项目结构可以很清楚，诸如组件化一类的实现将会很便捷。<\\/li>\n<li>更 reactive. 借助一些诸如 React 一类的框架，使用 SPA 实现单页化可以在前端完成一些复杂的视图变化。<\\/li>\n<li><s>更装逼。<\\/s>相比于使用 PJAX 实现单页，SPA 实现更考验一个前端的实现能力和架构能力。<\\/li>\n<li>…..<\\/li>\n<\\/ul>\n<p>还有一些我暂时想不到的特点。然而事物都有两面性，如果选择将整个博客 SPA 化，那么就会有以下麻烦的地方：<\\/p>\n<ul>\n<li>实现繁琐，不说搭建开发环境的麻烦，开发的时候也有一些很重复而繁琐的事情要做。相比制作 PJAX 主题来说，码量会更多一些。<\\/li>\n<li>和后端对接数据的时候稍显复杂。<\\/li>\n<li>打包出的 JS 文件会很大，如果不做组件异步加载或者适当的 code spilt，那么由于前端一个页面就要加载所有需要的组件，bundle 的体积自然比用 PJAX 做大好多好多倍。<\\/li>\n<li>…..<\\/li>\n<\\/ul>\n<p>以及你可能会踩很多的坑。不过既然我们说了是个实践，那么我们还是要尝试一下这个想法的。<\\/p>\n<h1 id=\"技术栈的选择\"><a href=\"#技术栈的选择\" class=\"headerlink\" title=\"技术栈的选择\"><\\/a>技术栈的选择<\\/h1><p>在做一个 SPA 意义上的主题之前，首先应该是对技术栈的选择，而技术栈的选择直接关系到开发的成本、舒适程度和最后产物的质量。<\\/p>\n<h2 id=\"前端框架\"><a href=\"#前端框架\" class=\"headerlink\" title=\"前端框架\"><\\/a>前端框架<\\/h2><p>关于框架的选择，很多 SPA 的最佳实践无非是在比较流行的 Angular, React 和 Vue 当中做出选择。<\\/p>\n<p>关于三个框架如何选择，这里只想说你认为好就行了。网上有很多关于对比这三个框架的文章，可以参考一下然后做出权衡。前端框架的选择主要考虑的是功能实现是否方便、对后期架构的影响、开发的成本，以及体积的大小等等，再有就是上手的难度和社区支持一类的也很重要。ng 的功能十分强大，项目的架构很完美；但是体积和性能相较后两者比较就相对比较不出色了，而且上手的难度会高一些；React 在性能和体积方面权衡得很适当，而且有很出色的生态系统；Vue 国内很多用户，选择 Vue 作为主题的前端框架也不错；这三者都能很好地胜任 SPA 的制作。<\\/p>\n<p>我最熟悉的是 React，所以我选择的自然是它了。鉴于主题的页面逻辑一般不会很复杂，所以我这里用了体积更小的 preact + preact-compat 来代替官方 react，性价比相对会更高。<\\/p>\n<h2 id=\"路由分发\"><a href=\"#路由分发\" class=\"headerlink\" title=\"路由分发\"><\\/a>路由分发<\\/h2><p>大部分 SPA 的路由分发都是在前端完成的，通过不同的 URI 渲染不同的组件到页面上。这就要求我们在后面的制作过程中将不同功能的组件（例如 header, footer, 文章部分，菜单等等）各自分开，这就是组件化了。对于 React 用户而言，路由的最佳选择无疑是 react-router 了。还记得之前 react-router 4 发布的时候 API 翻天覆地的变换和一堆的 bug（日常任务：黑 react-router (1\\/1)），现在明显已经好了很多了，至少在这一次的使用中没有踩到坑。所以就决定是它了。<\\/p>\n<h2 id=\"状态管理\"><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"><\\/a>状态管理<\\/h2><p>对于 SPA 来说，页面的状态大概会很复杂，所以我们需要一个好的状态管理方案。这里我用的是单一状态树 + 单向数据流的解决方案。<\\/p>\n<p>对于 React 而言，可以选择比较流行的 redux 和 mobx，两者相对来说 mobx 会更方便一些，但是依旧是权衡性能和体积，我们这里还是选择 redux. 幸运的是，redux 有一个简化的解决方案 redux-zero，使用它可以大大减少我们掉 redux 的坑的几率（<\\/p>\n<h2 id=\"打包工具\"><a href=\"#打包工具\" class=\"headerlink\" title=\"打包工具\"><\\/a>打包工具<\\/h2><p>毫无疑问地选择 webpack，个人认为 webpack 是当前最适合用来做单页 App 也是功能和配置都最强大的一款打包工具。自然配置会有些复杂，不过耐心一点就可以了。<\\/p>\n<h2 id=\"样式预处理器\"><a href=\"#样式预处理器\" class=\"headerlink\" title=\"样式预处理器\"><\\/a>样式预处理器<\\/h2><p>这个看个人喜好，用一个样式预处理器会减少一些开发的繁琐。SASS\\/SCSS\\/LESS\\/Stylus 什么的，任君选择。<\\/p>\n<h2 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"><\\/a>其它<\\/h2><p>除了上面之外，我还用了 Typescript 来写 React 代码，Typescript 真的很爽。当然如果你不熟悉 TS ，你也可以只用 babel 什么的就好了。<\\/p>\n<h1 id=\"具体思想\"><a href=\"#具体思想\" class=\"headerlink\" title=\"具体思想\"><\\/a>具体思想<\\/h1><ol>\n<li><p>首先由后端将所需要的数据（标题，描述，文章列表，当前页面等等）用 JSON 的格式输出到前端的一个隐藏的标签中（可以使用<code>&lt;script type=&quot;text\\/json&quot; id=&quot;json-holder&quot;&gt;&lt;\\/script&gt;<\\/code>这样的标签），这样方便我们接下来取用。<\\/p>\n<\\/li>\n<li><p>设计一个状态树，包含上述由后端发来的数据的字段，以及一些特殊组件的状态。这个状态树应该满足：修改上述数据之后可以触发整个页面视图的重新渲染。这样我们切换页面或者做一些操作的时候，只要修改这个状态树，那么整个页面就会改变。<\\/p>\n<\\/li>\n<li><p>根据通过不同的 URI ，由路由展示不同的组件。例如用户访问 <code>\\/<\\/code> 的时候，渲染首页的最近文章组件；用户访问 <code>\\/blog\\/post\\/xxxxxx<\\/code> 的时候渲染文章页组件……<\\/p>\n<\\/li>\n<li><p>将路由、组件和状态树连接起来，确保状态树改变的同时路由展示的组件会更新。<\\/p>\n<\\/li>\n<li><p>载入页面的时候，整个 SPA 加载完毕，这时候读取后端发来的嵌入在当前页面的数据，解析为新状态并替换当前状态树（第一次加载页面的时候，这个状态树应该是空的），这样就会触发视图的重新渲染。<\\/p>\n<\\/li>\n<li><p>最后一步，也是这个做法很核心的一步，就是监听页面的切换，用户切换页面的时候，使用 XHR 或者 fetch（推荐一个对 fetch 的封装：<a href=\"https:\\/\\/github.com\\/kokororin\\/honoka\" target=\"_blank\" rel=\"external\">这里<\\/a>） 等方式先抓取新页面，然后用 selector 取出嵌在新页面里的 JSON 数据，解析后替换当前状态树。<\\/p>\n<\\/li>\n<li><p>最后可以对上面的流程做一些适当的优化。这时候后端传出来的 <code>route<\\/code> 等参数就可以派上用场了。<\\/p>\n<\\/li>\n<\\/ol>\n<p>大概像这样:<\\/p>\n<pre><code class=\"javascript\">&lt;Provider store={store}&gt;\n    &lt;BrowserRouter basename={&#39;\\/&#39;}&gt;\n      &lt;div data-reactroot&gt;\n        &lt;Banner \\/&gt;\n        &lt;Menu \\/&gt;\n        &lt;SiteInfo \\/&gt;\n\n        &lt;Route exact path={&#39;\\/&#39;} component={AppIndex} \\/&gt;   \\/\\/ index\n        &lt;Route path={&#39;\\/page\\/:page&#39;} component={Pagination} \\/&gt;   \\/\\/ pagination\n        &lt;Route path={&#39;\\/blog\\/post\\/:slug&#39;} component={Post} \\/&gt;  \\/\\/ blog post\n        &lt;Route path={&#39;\\/pages\\/:slug&#39;} component={Page} \\/&gt;  \\/\\/ single pages\n\n        &lt;Footer \\/&gt;\n      &lt;\\/div&gt;\n    &lt;\\/BrowserRouter&gt;\n&lt;\\/Provider&gt;\n<\\/code><\\/pre>\n<h1 id=\"项目架构\"><a href=\"#项目架构\" class=\"headerlink\" title=\"项目架构\"><\\/a>项目架构<\\/h1><p>以 Hexo 主题为例，我们的 SPA 主题大概是下面这样一个架构：<\\/p>\n<pre><code>theme\\/\n  layouts\\/      # 主题各个页面布局文件，其实我们要做的无非是借助后端在各个页面展示不同的数据和载入文件\n  config\\/       # webpack 的配置\n    webpack.config.js\n  dist\\/         # 打包的 SPA\n  src\\/          # 整个 SPA 的源代码\n    actions\\/    # Redux 的 actions\n    components\\/ # 各种组件\n    stores\\/     # Redux 的 store\n    styles\\/     # 样式\n    images\\/     # 图片什么的\n    index.tsx   # 项目入口\n  package.json\n  tsconfig.json\n  tslint.json\n  ...\n<\\/code><\\/pre><p>（别问我为什么没有 reducers，我用 redux-zero 我自豪（x ）<\\/p>\n<p>下面是我在项目中用的一份 webpack 配置，可以参考:<\\/p>\n<pre><code class=\"js\">const webpack = require(&#39;webpack&#39;),\n  path = require(&#39;path&#39;),\n  ExtractTextPlugin = require(&#39;extract-text-webpack-plugin&#39;);\n\nconst srcPath = path.join(__dirname, &#39;\\/..\\/src&#39;);\n\nmodule.exports = {\n  output: {\n    path: path.join(__dirname, &#39;\\/..\\/source\\/dist&#39;),\n    filename: &#39;[name].js&#39;,\n    publicPath: &#39;\\/dist\\/&#39;\n  },\n  resolve: {\n    extensions: [&#39;.js&#39;, &#39;.jsx&#39;, &#39;.ts&#39;, &#39;.tsx&#39;],\n    alias: {\n      &#39;@&#39;: srcPath,\n      &#39;react&#39;: &#39;preact-compat&#39;,\n      &#39;react-dom&#39;: &#39;preact-compat&#39;\n    }\n  },\n  module: {\n    rules: [\n      {\n        test: \\/\\.(js|jsx)$\\/,\n        enforce: &#39;pre&#39;,\n        include: srcPath,\n        exclude: &#39;\\/node_modules\\/&#39;,\n        loader: &#39;eslint-loader&#39;\n      },  \\/\\/ eslint\n\n      {\n        test: \\/\\.(ts|tsx)$\\/,\n        enforce: &#39;pre&#39;,\n        include: srcPath,\n        exclude: &#39;\\/node_modules\\/&#39;,\n        loader: &#39;tslint-loader&#39;,\n      },  \\/\\/ tslint\n      {\n        test: \\/\\.(ts|tsx)$\\/,\n        include: srcPath,\n        exclude: &#39;\\/node_modules\\/&#39;,\n        loader: &#39;awesome-typescript-loader&#39;,\n      },  \\/\\/ typescript\n      {\n        test: \\/\\.(js|jsx)$\\/,\n        include: srcPath,\n        exclude: &#39;\\/node_modules\\/&#39;,\n        loader: &#39;babel-loader&#39;\n      },  \\/\\/ js babel\n      {\n        test: \\/(\\.styl)$\\/,\n        exclude: &#39;\\/node_modules\\/&#39;,\n        use: ExtractTextPlugin.extract({\n          fallback: [{\n            loader: &#39;style-loader&#39;,\n          }],\n          use: [{\n              loader: &#39;css-loader&#39;,\n              options: {\n                importLoaders: 2,\n                minimize: process.env.NODE_ENV === &#39;production&#39;,\n                sourceMap: true\n              }\n            },\n            {\n              loader: &#39;postcss-loader&#39;,\n              options: {\n                sourceMap: true\n              }\n            },\n            &#39;stylus-loader&#39;\n          ]\n        })\n      },  \\/\\/ stylus\n      {\n        test: \\/\\.(png|jpg|gif|woff|woff2|ttf|eot)$\\/,\n        loader: &#39;url-loader&#39;,\n        options: {\n          limit: 8192\n        }\n      },\n\n      {\n        test: \\/\\.(mp4|ogg|svg)$\\/,\n        loader: &#39;file-loader&#39;\n      }\n  }, \\/\\/ module\n    cache: true,\n    devtool: &#39;eval-source-map&#39;,\n    plugins: [\n        new webpack.NoEmitOnErrorsPlugin(),\n        new webpack.optimize.CommonsChunkPlugin(&#39;common&#39;),\n        new webpack.DefinePlugin({\n        &#39;process.env.NODE_ENV&#39;: &#39;&quot;dev&quot;&#39;,\n        &#39;process.env.REACT_DISTRO&#39;: &#39;&quot;preact&quot;&#39;\n        }),\n        new webpack.HotModuleReplacementPlugin(),\n        new ExtractTextPlugin(&#39;himawari.css&#39;)\n    ]\n};\n<\\/code><\\/pre>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"><\\/a>问题<\\/h1><p>目前发现的问题就是，写在文章中的 JS 标签不会执行，这个是有解决方案的，一个一个取出来重新创建一个 script 标签然后 appendChild 到 body 就行了。<\\/p>\n<p><s>以及……preact + redux 的主题好像和 react + mobx 的 MUSE 冲突了2333 暂时还没有找到方案。<\\/s> 问题在于上一步执行文章内的 JS 的时候多处理了一次，导致组件被 render 了两次……emmm……<\\/p>\n<p>（待补充）<\\/p>\n",
      "excerpt": "<p>算起来已经有很长一段时间没有折腾过主题了。之前一直都没有什么大变化的原因是，我一直在想一种能否把整个站都做成真正意义上的单页 App（就是不依靠 PJAX 实现）。也想过很多实现的方法，只是一直没有把这些方法真正写成实物验证一下可行性。前一段时间在把 Canvas 的主题用 webpack 重构之后，突发奇想到了一种可行度很高的策略。你现在看到的这个主题，大概就是这个脑洞的产物了。<\\/p>",
      "slug": "experiment-of-building-spa-theme-using-react",
      "published": true,
      "layout": "post",
      "path": "blog/post/experiment-of-building-spa-theme-using-react/",
      "permalink": "https://kirainmoe.com/blog/post/experiment-of-building-spa-theme-using-react/",
      "tags": [
        {
          "name": "react",
          "slug": "react",
          "path": "tags/react/",
          "permalink": "https://kirainmoe.com/tags/react/",
          "length": 3
        },
        {
          "name": "front-end",
          "slug": "front-end",
          "path": "tags/front-end/",
          "permalink": "https://kirainmoe.com/tags/front-end/",
          "length": 1
        },
        {
          "name": "theme",
          "slug": "theme",
          "path": "tags/theme/",
          "permalink": "https://kirainmoe.com/tags/theme/",
          "length": 1
        }
      ],
      "categories": [
        {
          "name": "前端",
          "slug": "前端",
          "path": "categories/前端/",
          "permalink": "https://kirainmoe.com/categories/前端/",
          "length": 4
        }
      ]
    },
    {
      "title": "“不悔梦归处，只恨太匆匆”",
      "date": "2017-11-13T13:41:17.000Z",
      "modified": "2018-01-14T01:55:16.939Z",
      "content": "<p>呐。听说按照 OI 界的传统，每位 OIer 退役的时候，都要写一篇退役感言。<br>于是，当我们从这一场梦中醒来的时候，日子又将恢复成从前的样子。<br>不悔梦归处，只恨太匆匆。<br><a id=\"more\"><\\/a><\\/p>\n<h1 id=\"0x00\"><a href=\"#0x00\" class=\"headerlink\" title=\"0x00\"><\\/a>0x00<\\/h1><p>从刚入高中就知道有竞赛这种事情，但是到了大概高一下学期的样子，才报名了学校组织的 OI 培训。按 NOIP 的年份来说，那一个赛季应该是 2015-2016 年，那一年我们学校参加的人数少得可怜，加上我，2018 届的总共就只有 6 个人来听课，那一年 18 届报名初赛的人数只有 5 个人。最后入围的只有 3 个人，这其中 18 届的只有我。<\\/p>\n<p>也不知道是怎样的一种阴差阳错，当年那会儿真的什么都不会，暴力都打不全，什么都不懂，就连一道题没有想法都不懂得打暴力骗个几十分的。不过，或许很多的 OIer，最开始应该都有这样的经历吧。<\\/p>\n<p>我并不像很多人一样从初中就开始算法相关的训练，甚至直到高一将要结束才开始这一段征程。因为入坑太晚，加上当时并没有意识到重要性，所以那一年最后的成绩并不是很好，只混了个省二滚粗。那一年我高二。有很多 OIer 在这条路上都止步于高二这一年。当初的我也曾经纠结过是否还要继续，那个时候家人是反对的。也因为课内繁忙和高二年下学期的生物竞赛，曾经放下了 OI 很长一段时间，当时真的确信自己不会再和 OI 有任何的关系了。现在想想，那一段咸鱼的时间真的很让人追悔。<\\/p>\n<h1 id=\"0x01\"><a href=\"#0x01\" class=\"headerlink\" title=\"0x01\"><\\/a>0x01<\\/h1><p>直到今年的 7 月份我才开始了这一个赛季的准备，因为 7 月顶着落下两天文化课的风险去参加了省里组织的夏令营——到夏令营快结束的那几天，高三狗们已经开学了。八月，九月……一直都是处于一种肝着文化课，然后一有空就刷 HDU 的状态，虽然并没有抽出多少时间，当初的 200 题 flag 也倒了，不过直到比赛前，统计一下 HDU+luogu+CF+… 以及线下的通过的题大概也有一百多的样子了，这样说起来也不算没努力过了吧。<\\/p>\n<p>从 9 月开始我们学校就开始了初赛的复习。今年的人数相比去年真的是翻了好多翻；初赛复习那一会儿，人多的能坐满整个机房。带领大家复习的重任交给了我校一位高二的选手 P 同学，在这里真的很感谢他给 19 届的选手们写 PPT、上课什么的（<s>虽然复习课我似乎一节都没时间去<\\/s>）。凭借着我市今年 350+ 的人数报名考试，以及省夏的团体总分和参加人数争取来的两个奖励名额，我们学校入围复赛的人数成功地成为了漳州市的最值，总共有 14 名选手入围复赛，其中和我一样是高三狗的还有两个。<\\/p>\n<p>听到这个成绩的时候我们大家都很感动，P 同学说他终于实现了把所有的选手都拉扯进复赛的梦想，当时我也觉得很开心。<\\/p>\n<p>我们一度觉得，我校 OI 的巅峰就要来了。<\\/p>\n<h1 id=\"0x02\"><a href=\"#0x02\" class=\"headerlink\" title=\"0x02\"><\\/a>0x02<\\/h1><p>10 月到 11 月这一段准备的日子，很忙碌，很累，但是也很充实。<\\/p>\n<p>其实每天都盼望着夜晚的到来，因为每天晚上刷完文化课的作业之后，就是撸题的时间。下到入门水题上到省选题，几乎我都有碰过（能不能做出来是另一回事了）。经历过绞尽脑汁看了题解也不知从何开始的无助，也经历过看到题目稍加思考一遍过的开心。这样的情绪变化可能会让人觉得很幼稚吧。有时候真的做得很累的时候，会停下来在 LINE 里和可爱的小姐姐说很多话，道完晚安之后又开始向没有通过的题目发起尝试。到现在一切都结束之后，回想起来，那真的是一段很美好的日子，仿佛重拾起了当年参加生物竞赛熬夜<s>背书<\\/s>的感觉。<\\/p>\n<p>19 届的选手们很多都选择了停文化课来专攻竞赛，有的停了一个月的课；一些 18 届的选手也放弃了部分的文化课在机房里写题目，甚至每天我回家的时候路过机房的那栋楼，都能看到三楼有一间房在黑暗中亮起了一缕阴暗的灯，就像夜空里的一颗星一般。那里有一群人在为自己的梦想努力着，敲打着键盘，直到晚自习结束的钟声响起才离开，甚至被锁在了楼里好几次……<\\/p>\n<h1 id=\"0x03\"><a href=\"#0x03\" class=\"headerlink\" title=\"0x03\"><\\/a>0x03<\\/h1><p>比赛的前一周。<\\/p>\n<p>这一段时间里我们又做了很多的事情。首先值得一提的就是我们出的模拟赛——四个人出了四道有毒的题目，本来打算让校内的选手练练手，最后出成了一场 luogu 上的公开比赛。出题真的要做好多的事情，还得背上自己造出来的锅= =不过我也算是出题坑过别人的人了呢（雾 那一场比赛办的很成功，虽然没有人 AK，但是参加的人数总共有 800 多人，也算是很有成就感了。<\\/p>\n<p>正好在这一周，课内的事情开始变得繁重了起来。其他的选手这一周里也参加了一下 luogu 的（打击）信心赛和 LibreOJ 的模拟。距离最后的日子很近了。<\\/p>\n<p>为了不让其他选手对试题产生恐惧感，我和 P 同学、L 同学决定再搞一场真正的信心赛，同时来一次全真模拟。那天是出发前一天的晚上，我第一次在小机房过了夜。虽然觉得自己出的题真的很简单，还考虑了很多，但是似乎所谓的信心赛还是搞砸了，因为最后有一位选手做着我出的那题做着做着哭了起来…………起来…………来…………<\\/p>\n<p>那时候觉得很愧疚，感觉好心办了坏事那样子。那天晚上找了一些人谈了一下心态的问题，但愿自己说的话他们可以听进去吧，不要有太大的压力。<\\/p>\n<p>夜深了，收拾完行装，明天就是出发的日子了。<\\/p>\n<h1 id=\"0x04\"><a href=\"#0x04\" class=\"headerlink\" title=\"0x04\"><\\/a>0x04<\\/h1><p>天亮了。外面天气很好。11 月 10 日，今天是出发的日子嘛？<\\/p>\n<p>中午十二点半的动车，留给我们的时间很宽松。所以早上我并没有直奔机房集合，而是先去解决了数理化三节文化课，下课铃一响迫不及待地拖着行李在众人奇异的目光中跑出了教学楼……来到机房，大家都已经等在那里了。<\\/p>\n<p>动车上的两个小时很快就过了。下了车的我们扛着一堆行李到十八中试机报到。顺着高德地图的指引，我们成功地绕着十八中绕了一整圈走到了一个被封死的后门= =……试机的时候闲得无聊打起了板子，用各种奇怪的方法写 a+b 问题。十八中的机子也是联想全家福，键盘跟学校机房那个一模一样，敲起来有种亲切感。<\\/p>\n<p>宾馆的环境不是很好，里面跟迷宫一样，卫生也不怎么好。那一天晚上洗澡的时候甚至没有热水，愣是顶着冷水洗了个澡……现在想起来没有感冒真是幸运极了。<\\/p>\n<p>看了一晚上的 Dinic 和打了板子之后就睡觉了，但是似乎有点紧张到 12 点多还没睡着。<\\/p>\n<h1 id=\"0x05\"><a href=\"#0x05\" class=\"headerlink\" title=\"0x05\"><\\/a>0x05<\\/h1><p>Day 1. 早上闹钟还没响就醒来了。毫无疑问昨晚并没有休息好。并且，考完 Day 1 之后是心态崩着出来的。<\\/p>\n<p>T1 当时一看觉得是个找规律，数据范围也验证了我的猜想。但是我的想法完全照着错误的方向走了，我对着可行方案的数列推了半天——我觉得规律大概是这个数列的周期性？然而两个小时都没有推出来。在这一题耗了这么长时间，这绝对是我 Day 1 最后悔的一件事情，以至于后面两题都没有认真做。出了考场同学说直接就是输出 a*b-a-b 的结论题，那会真的觉得自己好蠢，这么简单的问题都看不出来……<\\/p>\n<p>T2 是个大模拟，第一眼看还以为要我手动实现一个类似编译器的东西吓哭了，就放掉了，然后回去挣扎 T1……后来 T1 实在是出不来才发现，这就是个模拟……模拟……如果没有把时间都花在 T1 上我觉得 T2 能拿个挺可观的分数……<\\/p>\n<p>T3 的话真心没有什么思路，跑了个 SPFA + DFS 就歇了，还不会判零环。emmm……所以就很早地放弃了，出来之后听人说是最短路+拓扑序 DP，嘛算了，反正当时告诉我了也不一定调的出来。<\\/p>\n<p>等了半个小时出了程序回收结果。我们正要走的时候我突然发现，等等好像哪里不对，我的考号那一行长度似乎跟别人不太一样。仔细一看，我被漏收了一道题……emmm……我已经记不清当时是一种什么样的速度跑回 5 楼找监考了，然而他死咬定是我自己文件名和文件夹有问题，说什么收了两题另一题没收到这一定不是软件的问题，是自己的问题，然而我看了一下并没有看出是哪里有错……理论了半天并没有结果，他也不肯直接用 U 盘拷过去，一直争执到中午快一点的时候还是没有结果……期间我校有一位大兄弟强势地怼起了那个监考不负责任……嘛，很感谢他帮我发声，但是似乎情绪有点激动……<\\/p>\n<p>那时候按照他们的说法我觉得似乎已经无望了。我看看那张回收列表上有一位选手也没有被收到我被漏收的那一题，IP 地址只跟我差 1，我猜大概是跟我一样的问题并且也是 Linux 选手。后来我联系到他的时候果然验证了我的猜测，只是联系上他的时候似乎已经过了申诉的时间，我并不知道他最后能不能成功，最后我是成功了——因为那个主考一直说是我文件名有错，我们的带队老师问了福建的主办方之后，他们建议：既然是考生自己的问题，那就让他们试着建一个同名文件夹和同名文件，如果建不出来就说明是软件收取的锅。很幸运，这一波十分有力地证明了我的清白，主考最后也直接用 U 盘帮我拷走了程序……<\\/p>\n<p>总之……谢谢那些为了我的事情而挨饿到中午一点多的老师同学们……<\\/p>\n<p>那天中午吃了一顿好的（哪里不对的样子）。下午是出去找其他市的选手面基。晚上自己出去散了散步，福州那个地方晚上还挺热闹的。八点多的时候回去酒店里觉得很累，想躺了一会儿但是并没有睡着。收拾了一下行李，十一点多才上床睡觉。<\\/p>\n<p>但愿明天会友好一些吧。今天的题总结出来就是：<\\/p>\n<blockquote>\n<p>正解写不出，暴力写不完。不会小学题，<s>省三<\\/s> 不存在的 就退役。<\\/p>\n<\\/blockquote>\n<h1 id=\"0x06\"><a href=\"#0x06\" class=\"headerlink\" title=\"0x06\"><\\/a>0x06<\\/h1><p>Day 2. 早上起来觉得昨天的睡眠还行，昨天买了一堆面包没吃完，今天直接当了早餐2333<\\/p>\n<p>进了考场，希望不要发生昨天那样的事情。所幸的是没有。<\\/p>\n<p>T1 第一眼看有点慌，毕竟什么空间坐标系，说到空间的东西我就被前几周我校一个毒瘤出题人出的破空间计算题吓怕了。冷静下来看了一下觉得十分可做啊，先在草稿纸上写了一下自己的思路，然后 30 分钟很顺畅地敲完了代码，稍微调了一下就过了 example……然而出考场之后别人说会炸 long long……emmm……<\\/p>\n<p>T2 一看到名字宝藏，脑子灵光一闪——我好像在 HDU 见过一道也是以宝藏为主题的题目，那道题是个状压 DP 什么的………拉下去看了看数据范围，n &lt;= 12, 卧槽可把我乐坏了……于是稍微思考了一下可行解，把接下来的两个小时献给了这道题，然而最后大概转移错了还是怎么样连样例都没调出来QAQ……有点可惜。<\\/p>\n<p>突然想到 D1 那天晚上和 P 同学的对话：<\\/p>\n<blockquote>\n<p>P：“你觉得今年会不会考状压？”<br>我：“我觉得这概率挺小的吧……毕竟去年考了一题了……”<\\/p>\n<\\/blockquote>\n<p>下次我自己都不信我自己的毒奶了……<\\/p>\n<p>T3 看了一眼觉得不可做，直接扔了，也不知道有没有打错。<\\/p>\n<p>D2 给我的感觉还行（，至少跟去年差不多，也没有 D1T1 那么**的结论题……万万没想到会跪在 D1T1 上……<\\/p>\n<p>并没有出现昨天被漏收的现象，但是同校的一个选手打错了一个字母被少收了一题，这个无法申诉，有点可惜。<\\/p>\n<p>回程是下午四点多的动车，中午十二点多出来先分散着去吃了饭，当电灯泡陪一对 CP 第四次地逛了一遍三坊七巷……（别问我为什么是第四次，省夏的时候来过两次了），然后就坐地铁赶到火车站了，到漳州是七点不到的样子，回到家感觉浑身无力累的要死……<\\/p>\n<h1 id=\"0x07\"><a href=\"#0x07\" class=\"headerlink\" title=\"0x07\"><\\/a>0x07<\\/h1><p>回来了。<\\/p>\n<p>把行李拿出来的时候看到了紫书，想了想，把他捧放回了书架上。大概不怎么回去碰到它了吧，毕竟我已经是一名退役老狗了。那一刻觉得，心里空落落的，好像有什么东西丢了一样。<\\/p>\n<p>发了几条感叹的微博。开电脑的时候看到在动车上随便写的一些都念不通顺的退役感受，想了想还是删掉了。前几次竞赛都留下什么文字的回忆，这一回我要认真地记录一次。这篇迟到的退役感言直到回来的第二天晚上才出来。<\\/p>\n<p>早上去机房丢东西，发现一些熟悉的身影依然在那里。中午觉得很累也很难受，下午就没有再过去学校。听说下午有位选手因为付出了很多但是成绩很差泪崩了。也不知道如何安慰了，毕竟自己都凉凉了还能怎么安慰别人。但是我想说，有时候付出和收获不一定是正比，路还很长，课内努力是可以补回来的，而且你们还有一年的时间努力，还有一次机会，一次失败算不了什么。<\\/p>\n<p>而我，就不一样了。OI 已经跟我不再有关系了。<\\/p>\n<h1 id=\"0x08\"><a href=\"#0x08\" class=\"headerlink\" title=\"0x08\"><\\/a>0x08<\\/h1><p>两年的 OI 生涯给我带来了什么？<\\/p>\n<p>对于别人而言可能是奖项，是机会，<s>甚至是女票<\\/s>。而对于我，大概是一些知识、思考，以及最重要也最宝贵的——记忆和友谊这两样东西。<\\/p>\n<p>我想，将来的哪一天，当我回想起这段日子，回想起曾经的努力，回想起大家一起聚在机房写代码的那段时光，回想起这段友谊，回想到这篇文章，可能会有不一样的感觉。<\\/p>\n<p><span title=\" みんなで叶える物语。\">“大家一起实现梦想的故事。”<\\/span><\\/p>\n<p>是的，这一段不可磨灭记忆是大家共同创造的。不论是愉快的欢声，还是遗憾的泪水。但是，这就是我们的选择，这就是漳一赛艇队的 16 个人一起创造的故事。<\\/p>\n<p>“不忘初心”是 Day1 压缩包的解压密码，现在看起来确实是很暖心的一句话。天下没有不散的宴席，当我们最后因为各种各样的原因而各奔东西的时候，请不要忘记初心。我们努力过，失败过……但无论何时，都要记住自己最初入 OI 时心怀着的那个梦想。<\\/p>\n<p>谢谢那些鼓励过我的人，父母，亲人，朋友，同学，老师，还有一位特殊的人。<br>谢谢那些陪伴我走过这一段日子的学长和学弟学妹们。<\\/p>\n<p>…………<\\/p>\n<p>于是，当我们从这一场梦中醒来的时候，日子又将恢复成从前的样子。<\\/p>\n<h3 id=\"不悔梦归处，只恨太匆匆。\"><a href=\"#不悔梦归处，只恨太匆匆。\" class=\"headerlink\" title=\"不悔梦归处，只恨太匆匆。\"><\\/a>不悔梦归处，只恨太匆匆。<\\/h3><p><div id=\"muse-app\"><\\/div><\\/p>\n<script type=\"text\\/javascript\">\nvar playList = [{\n    title: '僕たちはひとつの光',\n    artist: 'μ\\'s',\n    cover:\n      'http:\\/\\/p3.music.126.net\\/_gfatO4AhgiBKDwOgrHEQg==\\/7706477001119945.jpg',\n    src: 'http:\\/\\/other.web.rg01.sycdn.kuwo.cn\\/resource\\/n2\\/27\\/71\\/3547184289.mp3',\n    lyric:\n      '[00:27.540]Ah! ほのかな予感から始まり\\n[00:32.970]Ah! 希望が星空駈けて\\n[00:38.450]花を咲かせるにっこり笑顔は\\n[00:43.920]ずっと同じさ 友情の笑顔\\n[00:49.160]\\n[00:49.510]忘れない いつまでも忘れない\\n[00:54.940]こんなにも心がひとつになる\\n[01:00.410]世界を見つけた喜び(ともに)歌おう\\n[01:09.940]最後まで(僕たちはひとつ)\\n[01:16.660]\\n[01:17.040]小鳥の翼がついに大きくなって\\n[01:25.010]旅立ちの日だよ\\n[01:28.130]遠くへと広がる海の色暖かく\\n[01:36.050]夢の中で描いた絵のようなんだ\\n[01:40.300]切なくて時をまきもどしてみるかい?\\n[01:52.490]No no no いまが最高!\\n[01:58.620]\\n[02:20.460]みんなと出会えたこと嬉しくて\\n[02:27.090]離れたくないよ本当だよ\\n[02:31.550]涙はいらない このまま踊ろう\\n[02:36.980]手を振ってもっと振って\\n[02:42.890]\\n[02:45.370]光を追いかけてきた僕たちだから\\n[02:53.190]さよならは言わない\\n[02:56.320]また会おう 呼んでくれるかい?\\n[03:00.300]僕たちのこと\\n[03:04.320]素敵だった未来に繋がった夢\\n[03:08.560]夢の未来 君と僕のLIVE&LIFE\\n[03:15.430]\\n[03:37.800]小鳥の翼がついに大きくなって\\n[03:45.640]旅立ちの日だよ\\n[03:48.760]遠くへと広がる海の色暖かく\\n[03:56.730]夢の中で描いた絵のようなんだ\\n[04:00.990]切なくて時をまきもどしてみるかい?\\n[04:13.240]No no no いまが最高!\\n[04:18.670]だってだって、いまが最高!\\n[04:30.500]\\n[04:31.520]Ah! ほのかな予感から始まり\\n[04:37.410]Ah! 光を追いかけてきたんだよ…\\n[04:48.410]',\n    translation:\n      'Ah! 从微小的预感开始\\nAh! 希冀在星空中驰骋\\n笑开花儿的真切笑容是\\n亘久不变 友情的笑容\\n\\n无法忘却 永远铭记\\n心灵能如此合而为一\\n让我们（一同）歌唱发现世界的喜悦\\n直到最后（我们已成为一体）\\n\\n小鸟终也羽翼丰满\\n到了展翅翱翔的日子\\n一望无垠的大海 颜色是如此温暖\\n如同在梦中描绘的画\\n若感到惆怅要让时光倒流吗？\\nNo no no 此刻就是最好的！\\n\\n与大家相遇是如此幸福\\n不舍别离 真的\\n不必流泪 就此起舞吧\\n挥舞起手 用力挥舞吧\\n\\n因为我们已经追上了那束光芒\\n所以不需要道别\\n再会之时 能否轻唤\\n我们的名字？\\n通往美好未来的梦想\\n梦想的未来 属于你与我的LIVE&LIFE\\n\\n小鸟终也羽翼丰满\\n到了展翅翱翔的日子\\n一望无垠的大海 颜色是如此温暖\\n如同在梦中描绘的画\\n若感到惆怅要让时光倒流吗？\\nNo no no 此刻就是最好的！\\n因为因为，此刻就是最好的！\\n\\nAh! 从微小的预感开始\\nAh! 追逐到了那束光芒……'\n  }];\n\nMUSE.render(playList, document.getElementById('muse-app'));\n<\\/script>\n\n<h1 id=\"終わり\"><a href=\"#終わり\" class=\"headerlink\" title=\"(終わり)\"><\\/a>(終わり)<\\/h1>",
      "excerpt": "<p>呐。听说按照 OI 界的传统，每位 OIer 退役的时候，都要写一篇退役感言。<br>于是，当我们从这一场梦中醒来的时候，日子又将恢复成从前的样子。<br>不悔梦归处，只恨太匆匆。<br>",
      "slug": "noip-retired-feeling",
      "published": true,
      "layout": "post",
      "path": "blog/post/noip-retired-feeling/",
      "permalink": "https://kirainmoe.com/blog/post/noip-retired-feeling/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "diary",
          "slug": "diary",
          "path": "tags/diary/",
          "permalink": "https://kirainmoe.com/tags/diary/",
          "length": 3
        }
      ],
      "categories": []
    },
    {
      "title": "在 Linux 下配置 lemon 评测系统",
      "date": "2017-11-10T11:45:59.000Z",
      "modified": "2018-01-07T05:26:54.797Z",
      "content": "<p>Linux 下那种能用来批量评测的软件看起来很少的样子，找了很久只找到了一个 CCF 官方的 arbiter 和跨平台的 lemon. arbiter 在 Arch Linux 上死活装不成（主要是老旧的 qt3），于是就只能把目光投向 lemon 了。虽然 lemon 用起来比较危险（因为 lemon 没有沙箱机制），不过本着能用就行的原则，就尝试着配置了一下它。这里只讲讲它在 Arch Linux 下的配置和使用。<\\/p>\n<a id=\"more\"><\\/a>\n<h1 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"><\\/a>编译<\\/h1><p>lemon 基于 qt4 开发（<s>怪不得可以跨平台<\\/s>），所以我们先安装 qt4 的环境。当然你需要有一个 DE\\/WM 来运行。<\\/p>\n<pre><code class=\"bash\"># pacman -S qt4\n<\\/code><\\/pre>\n<p>然后我们搞到 lemon 的源代码。GitHub 上可以找到，一个是原版，一个是做了一些修改的：<\\/p>\n<blockquote>\n<p>原版 project-lemon: <a href=\"https:\\/\\/github.com\\/zhipeng-jia\\/project-lemon\" target=\"_blank\" rel=\"external\">https:\\/\\/github.com\\/zhipeng-jia\\/project-lemon<\\/a><br>修改版 project-lemon: <a href=\"https:\\/\\/github.com\\/Sojiv\\/Project_lemon\" target=\"_blank\" rel=\"external\">https:\\/\\/github.com\\/Sojiv\\/Project_lemon<\\/a><\\/p>\n<\\/blockquote>\n<p>其中原版的话需要修改文件，否则会编译出错，具体是修改<code>qtsingleapplication\\/qtlocalpeer.cpp:96:54<\\/code>文件，把以下代码：<\\/p>\n<pre><code class=\"cpp\">socketName += QLatin1Char(&#39;-&#39;) + QString::number(::getuid(), 16);\n<\\/code><\\/pre>\n<p>修改为：<\\/p>\n<pre><code class=\"cpp\">socketName += QLatin1Char(&#39;-&#39;) + QString::number(QtLP_Private::getuid(), 16);\n<\\/code><\\/pre>\n<p>接着 qmake 一下，然后就可以编译了：<\\/p>\n<pre><code class=\"bash\"># qmake-qt4 lemon.pro\n# make\n<\\/code><\\/pre>\n<p>编译完之后，可以在目录下找到一个可执行文件 <code>lemon<\\/code>，这就是编译好的程序了。所以我们可以把这个程序搞到<code>\\/usr\\/bin\\/<\\/code>里去，这样我们下次运行直接在终端里敲<code>lemon<\\/code>就可以了。<\\/p>\n<h1 id=\"配置数据\"><a href=\"#配置数据\" class=\"headerlink\" title=\"配置数据\"><\\/a>配置数据<\\/h1><p>首先新建一个测试，然后把数据复制到测试文件夹下的 <code>data<\\/code> 目录里。例如我要配置一道名为 <code>events<\\/code> 的试题，则我把以下格式的数据文件复制到 <code>data\\/events<\\/code> 目录下：<\\/p>\n<pre><code>events1.in   events1.ans   events2.in   events2.ans   events3.in   events3.ans\n...\n<\\/code><\\/pre><p>然后我们首先新建试题，填好试题信息、时空限制、比较方式等等，然后右键该试题，选择添加多个测试点，然后接下来会让我们键入能匹配所有输入输出数据文件名的一个正则表达式。以上面那个为例，我们写出来的应该是下面这样的：<\\/p>\n<pre><code>input file: events\\/events&lt;1&gt;.in\noutput file: events\\/events&lt;1&gt;.ans\n\n&lt;1&gt; .*\n<\\/code><\\/pre><p>这里需要一点正则表达式的知识，如果你不会的话，那就按照上面的模板来就可以了。<\\/p>\n<h1 id=\"评测时无法运行程序\"><a href=\"#评测时无法运行程序\" class=\"headerlink\" title=\"评测时无法运行程序\"><\\/a>评测时无法运行程序<\\/h1><p>配置完数据把 std 复制到 source 文件夹里。然后尝试评测，提示<code>Can not start program (无法运行程序)<\\/code>。这个问题我们需要修改编译参数，如果不修改编译参数，lemon 默认是这样编译一个 C++ 程序的：<\\/p>\n<pre><code class=\"bash\">g++ -o %s %s.cpp\n<\\/code><\\/pre>\n<p>我们在编译参数里加上一个<code>-lm<\\/code>，这样编译出来的程序就可以运行了。如果是 Windows 上就加上一个<code>-m32<\\/code>参数。<\\/p>\n<h1 id=\"栈溢出等问题\"><a href=\"#栈溢出等问题\" class=\"headerlink\" title=\"栈溢出等问题\"><\\/a>栈溢出等问题<\\/h1><p>一开始没注意这个，开了 -O2 才发现原来不开 -O2 能 AC 的程序居然 RE 了。一查发现是栈溢出，原来 Linux 下默认栈是 8MB= =这个当然不够用啦，所以我们可以修改评测时栈空间的限制。参考 NOIP2016 D1T2 附件提供的 Linux 下开栈的做法，退出 lemon 并打开终端，运行以下命令：<\\/p>\n<pre><code class=\"bash\">$ ulimit -s 233333\n<\\/code><\\/pre>\n<p>这里嘛就是把我们的栈调用空间开大，大概开到 200MB 多（后面那一串数字单位是 KB）。然后重新在当前终端里运行 lemon，就不会爆栈了。需要注意的是 ulimit 只对当前终端窗口有效，如果你退出了终端或者开了另一个终端窗口，就需要重新设置。<\\/p>\n<p>暂时就遇到了这些问题喵。 &gt; &lt;<\\/p>\n",
      "excerpt": "<p>Linux 下那种能用来批量评测的软件看起来很少的样子，找了很久只找到了一个 CCF 官方的 arbiter 和跨平台的 lemon. arbiter 在 Arch Linux 上死活装不成（主要是老旧的 qt3），于是就只能把目光投向 lemon 了。虽然 lemon 用起来比较危险（因为 lemon 没有沙箱机制），不过本着能用就行的原则，就尝试着配置了一下它。这里只讲讲它在 Arch Linux 下的配置和使用。<\\/p>",
      "slug": "configure-lemon-judger-for-linux",
      "published": true,
      "layout": "post",
      "path": "blog/post/configure-lemon-judger-for-linux/",
      "permalink": "https://kirainmoe.com/blog/post/configure-lemon-judger-for-linux/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "lemon",
          "slug": "lemon",
          "path": "tags/lemon/",
          "permalink": "https://kirainmoe.com/tags/lemon/",
          "length": 1
        },
        {
          "name": "linux",
          "slug": "linux",
          "path": "tags/linux/",
          "permalink": "https://kirainmoe.com/tags/linux/",
          "length": 1
        }
      ],
      "categories": []
    },
    {
      "title": "愤怒的小鸟 (Review / NOIP2016 D2T3)",
      "date": "2017-11-03T12:36:17.000Z",
      "modified": "2018-01-07T05:26:49.253Z",
      "content": "<p>嘛。去年考场上遇到这题的时候一脸懵逼……现在回过头来看就好多了，但是有一些细节还是要做清楚。 (\\/ω＼)<\\/p>\n<a id=\"more\"><\\/a>\n<p>题目：<a href=\"https:\\/\\/www.luogu.org\\/problemnew\\/show\\/2831\" target=\"_blank\" rel=\"external\">https:\\/\\/www.luogu.org\\/problemnew\\/show\\/2831<\\/a><\\/p>\n<p>题目就是呢，要构造最少条的抛物线，消灭掉所有的小猪~然后求最少的抛物线数量~观察题目我们可以发现——特殊指令 m 是没有什么卵用的= =<\\/p>\n<p>然后接下来我们分析题目：求构造的最少抛物线数量 → 构造抛物线直到把所有的猪都打掉 → 每个猪打一次就没了，而且抛物线的轨迹不会改变 → 对于一条抛物线，如果能打掉尽可能多的猪那么再好不过 → n &lt;= 18 → ……<\\/p>\n<p>好的，看到数据范围大家应该有一些想法了。大部分人会想到搜索 + 剪枝，也有写记忆化搜索的……然而这两种都不太好写，但是能解是肯定的，这里就不多说这个了。<\\/p>\n<p>n 才 18，还有另一种做法呀~那就是状态压缩 DP！( ＞ω＜) 表示对于能理解状态压缩的玩家们，把这题写成状态压缩比写成搜索题好写多了~而且效率也很高的说。如果不能理解状压的话想写就比较麻烦辣。<\\/p>\n<p>那么我们要做什么呢？先设计个 DP 状态和方程呗，显然我们应该<strong>用<code>dp[i]<\\/code>来表示击败的猪的二进制状态为 i 的时候，需要构造的抛物线的最小数目。<\\/strong>二进制状态为 i 是什么概念呢，这里简单地说一下，比如说总共有 3 只猪，这时候你把第一只（标号为 0）和第二只（标号为 1）的猪打掉了，那么 i 就是<code>011<\\/code>咯（打掉第几只猪，状态 i 的二进制下第几位就是 1），同理如果你把三只猪都打死了，那么 i 就是<code>111<\\/code>.<\\/p>\n<p>所以，根据状态压缩 DP 的原理，我们先枚举合法的每一个状态，也就是 <code>i = 1<\\/code> 到 <code>(1 &lt;&lt; n) - 1<\\/code>。对于每一个状态，随便举出其中包含的一个点 k，那么 <code>dp[i]<\\/code> 最坏的情况应该是：在没打掉第 k 只猪之前的最小值 + 1，我们把这个值作为初值赋给 <code>dp[i]<\\/code>: <code>dp[i] = dp[i &amp; ~(1 &lt;&lt; k)] + 1<\\/code>, 或者表示成<code>dp[i] = dp[i - (1 &lt;&lt; k)] + 1<\\/code>.<\\/p>\n<p>然后我们再枚举出当前状态包含的另一个点 t (t != k), 取<code>dp[i]<\\/code>（上文已经更新过了）和<code>dp[j] + 1<\\/code>的最小值即可。因为我们知道，两点构成一条抛物线，所以我们可以找两个，这两个点一定可以勾出一条抛物线，然后从当前状态 i 中去掉<strong>这条抛物线经过的所有的小猪<\\/strong>，这样就得到了状态 j （╯‵□′）╯︵┴─┴ ：<code>dp[i] = min(dp[i], dp[i - (i &amp; fstate[i][j])] + 1)<\\/code>, 这里 <code>fstate[i][j]<\\/code> 的意思请往下看。<\\/p>\n<p>那么还有一个问题，就是我们怎么知道 k 和 t 构成的那条抛物线经过了哪些猪呢？这时候我们可以枚举任意两个点算出经过这两个点的形如<code>y=ax^2+bx, a &lt; 0<\\/code>的抛物线，再计算这条抛物线对其他点的影响，把它们整理成一个二进制状态；简言之，两点（当然，还有原点 0, 0）可以确定一条抛物线，我们用<code>fstate[i][j]<\\/code>表示能干掉第 i 和第 j 只小猪的这条抛物线，最终能打掉的猪的状态，这样上面的 j 就可以推出来了。<code>fstate<\\/code>数组的计算就是，选取两个点计算 a 和 b，然后枚举其他的点，如果<code>aXk^2 + bXk = Yk<\\/code>成立的话，那么就把这个点 k 合并到<code>fstate[i][j]<\\/code>里去：<code>fstate[i][j] |= (1 &lt;&lt; k)<\\/code>.<\\/p>\n<p>好了。至此这道题已经做得差不多了，还有一个很关键的地方可能就是——抛物线怎么算 (￣▽￣)~这里主要要 care 一下精度的问题: <code>const double eps = 1e-7;<\\/code>.<\\/p>\n<p>然后我们对于两个已知点 A(x1, y1), B(x2, y2)，我们可以得到两个等式：<\\/p>\n<pre><code>y1 = a * x1^2 + b * x1\ny2 = a * x2^2 + b * x2\n<\\/code><\\/pre><p>移项变形一下，我们可以得到：<\\/p>\n<pre><code>b = (y1 - a * x1^2) \\/ x1\nb = (y2 - a * x2^2) \\/ x2\n<\\/code><\\/pre><p>消去参数 b，然后得到关于 a 的一个等式，整理之后我们可以得到：<\\/p>\n<pre><code>a = (x2 * y1 - x1 * y2) \\/ (x1 * x2 * (x1 - x2))\n<\\/code><\\/pre><p>其中 x1, x2, x1-x2 均不为 0. 得到 a 之后把 a 带回上面一个含 b 的式子就可以了(o ° ω ° O ) 。<\\/p>\n<p>然后这道题就做完啦。<\\/p>\n<pre><code class=\"cpp\">#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;cmath&gt;\n#include &lt;algorithm&gt;\n#define db double\nusing namespace std;\nconst int MAXN = 18;\nconst int INF = 1e9 + 7;\nconst db eps = 1e-7;\nstruct Point {\n    db x, y;\n}; \nPoint p[MAXN + 5];\nint dp[1 &lt;&lt; MAXN];\nint fstate[MAXN][MAXN];\nint n, m, t;\nint main()\n{\n    scanf(&quot;%d&quot;, &amp;t);\n    while (t--)\n    {\n        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);\n        for (int i = 0; i &lt; n; i++)\n        {\n            scanf(&quot;%lf%lf&quot;, &amp;p[i].x, &amp;p[i].y);\n        }\n\n        memset(fstate, 0, sizeof fstate);\n\n        for (int i = 0; i &lt; n; i++)\n        {\n            for (int j = 0; j &lt; n; j++)\n            {\n                if (i == j) {\n                    continue;\n                }\n\n                db x1 = p[i].x, x2 = p[j].x, y1 = p[i].y, y2 = p[j].y;\n                if (x1 &lt; eps || x2 &lt; eps || abs(x1 - x2) &lt; eps) {\n                    continue;\n                }\n                db a = (x2 * y1 - x1 * y2) \\/ (x1 * x2 * (x1 - x2));\n                if (a &gt; -eps) {\n                    continue;\n                }\n\n                db b = y1 \\/ x1 - a * x1;\n                int final = (1 &lt;&lt; i) | (1 &lt;&lt; j);\n                for (int k = 0; k &lt; n; k++)\n                {\n                    db xk = p[k].x, yk = p[k].y;\n                    if (abs(a * xk * xk + b * xk - yk) &lt; eps) {\n                        final |= (1 &lt;&lt; k);\n                    }\n                }\n                fstate[i][j] = final;\n            }\n        }\n\n        fill(dp, dp + (1 &lt;&lt; n), INF);\n        dp[0] = 0;\n        for (int i = 1; i &lt; (1 &lt;&lt; n); i++)\n        {\n            int cur = 0;\n            for (int j = 0; j &lt; n; j++)\n            {\n                if (i &amp; (1 &lt;&lt; j)) {\n                    cur = j;\n                    break;\n                }\n            }\n\n            \\/\\/ dp[i] = dp[i - (1 &lt;&lt; cur)] + 1;\n            dp[i] = dp[i &amp; ~(1 &lt;&lt; cur)] + 1;\n\n            for (int j = 0; j &lt; n; j++)\n            {\n               if (i &amp; (1 &lt;&lt; j) &amp;&amp; j != cur) {\n                    dp[i] = min(dp[i], dp[i &amp; ~(i &amp; fstate[cur][j])] + 1);\n                    \\/\\/ dp[i] = min(dp[i], dp[i - (i &amp; fstate[cur][j])] + 1);\n               }\n            }\n        }\n\n        printf(&quot;%d\\n&quot;, dp[(1 &lt;&lt; n) - 1]);\n    }\n    return 0;\n}\n<\\/code><\\/pre>\n",
      "excerpt": "<p>嘛。去年考场上遇到这题的时候一脸懵逼……现在回过头来看就好多了，但是有一些细节还是要做清楚。 (\\/ω＼)<\\/p>",
      "slug": "angry-birds-state-compressing",
      "published": true,
      "layout": "post",
      "path": "blog/post/angry-birds-state-compressing/",
      "permalink": "https://kirainmoe.com/blog/post/angry-birds-state-compressing/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "algorithm",
          "slug": "algorithm",
          "path": "tags/algorithm/",
          "permalink": "https://kirainmoe.com/tags/algorithm/",
          "length": 8
        },
        {
          "name": "dynamic programming",
          "slug": "dynamic-programming",
          "path": "tags/dynamic-programming/",
          "permalink": "https://kirainmoe.com/tags/dynamic-programming/",
          "length": 1
        }
      ],
      "categories": []
    },
    {
      "title": "记自己的第一次差点翻车的出题经历",
      "date": "2017-10-29T13:01:52.000Z",
      "modified": "2018-01-07T05:18:30.966Z",
      "content": "<p>复赛在即，我们学校里面的四个撒币不知道是谁突发奇想，说要出一套模拟题。于是我们四个人分别出了一道要多恶心有多恶心的题= =本来嘛是要在学校内部自己测的，不过人太少，不好玩，于是就连夜 py 到洛谷上搞了公开赛。从早上 8 点到中午 12 点，虽然出了很多的锅，不过还是要记录一下我的第一次出题经历（<\\/p>\n<a id=\"more\"><\\/a>\n<p><div id=\"muse-app\"><\\/div><\\/p>\n<script type=\"text\\/javascript\">\nvar playList = [\n  {\n    \"title\": \"未来の僕らは知ってるよ\",\n    \"artist\": \"Aqours\",\n    \"cover\": \"http:\\/\\/p1.music.126.net\\/03tA9ZYD51gTLxlEuY3_vw==\\/109951163049447102.jpg\",\n    \"src\": \"https:\\/\\/api.kotori.love\\/netease\\/514543403.mp3\",\n    \"lyric\": \"[00:00.00] 作曲 : 光増ハジメ\\n[00:00.17] 作词 : 畑亜贵\\n[00:00.51](千歌)本気を ぶつけあって\\n[00:06.15]手に入れよう (全员)未来を\\n[00:14.63]\\n[00:20.23]味方なんだ 空も この海も\\n[00:25.75]さあ頑張るんだと 輝いてるよ\\n[00:30.73]遠くへ 遠くへ 声が届くように\\n[00:36.34]もっと大きくユメを叫ぼうか\\n[00:41.22](2年生)(希望でいっぱいの)\\n[00:43.20](3年生)今日が明日を引き寄せるんだと\\n[00:47.33](1年生)ハートの磁石を握って走る\\n[00:51.81](全员)今は 楽しいんだ それが\\n[00:55.92]「ずっと一緒に行こう！」\\n[00:57.92]\\n[00:58.15]未来をどうしようかな\\n[01:01.02]みんな夢のカタチを探して\\n[01:06.53]泣いたり 笑ったり\\n[01:08.74]未来の僕たちは きっと答えを持ってる\\n[01:15.11]はずだから 本気で駆け抜けて\\n[01:23.33]\\n[01:30.19](梨子)歌いながら 雨に濡れながら\\n[01:36.11](曜)絶対晴れると信じてるんだよ\\n[01:40.96](花丸)元気な (露比)元気な\\n[01:43.40](花丸)声で (花露)呼んでみよう\\n[01:46.69](善子)きっと大きな\\n[01:48.70](夜羽)夢に会えるはずさ\\n[01:52.10](果南)進化したいから すぐできないこと\\n[01:56.30](黛雅)ひとつ ひとつ 乗り越えて\\n[02:01.74](鞠莉)雲の間に間に新しい青空が\\n[02:07.20]待ってるよ (全员)待ってるよ\\n[02:11.94]\\n[02:12.36](全员)期待で弾け飛ぼう\\n[02:15.60]こんな勢いのままで\\n[02:18.73]行きたいよ\\n[02:20.71]泣いても 笑っても\\n[02:22.95]期待が僕たちへたくさん合図くれるから\\n[02:29.40]逃がさないで チャンスを捕まえて\\n[02:36.68]\\n[02:45.10]I live I live lovelive days！！\\n[02:48.47]\\n[02:52.69]本気をぶつけたら\\n[02:57.26]叶うんじゃないかな ユメ\\n[03:04.00]\\n[03:05.51](千歌)未来をどうしようかな\\n[03:08.21]みんなユメのカタチを ah (ah～)\\n[03:13.77]探してるんだ みんなで\\n[03:15.61]\\n[03:15.97](全员)期待で弾け飛ぼう\\n[03:18.85]こんな勢いのままで 行きたいよ\\n[03:24.41]泣いても 笑っても\\n[03:26.64]未来の僕たちは きっと答えを持ってる\\n[03:33.18]はずだから 本気で駆け抜けて\\n[03:40.28]チャンスを捕まえて\\n[03:48.10]光る風になろう\\n[03:51.10]We got dream!\\n\",\n    \"translation\": \"[00:00.51]让我们触碰彼此真心\\n[00:06.15]将未来紧握手中\\n[00:14.63]\\n[00:20.23]碧海蓝天 与我们同在\\n[00:25.75]来吧 高喊加油 闪耀起来哟\\n[00:30.73]为了让声音传向更远更远\\n[00:36.34]更加放声呼喊梦想吧\\n[00:41.22]（希望已充盈四周）\\n[00:43.20]今日之行引导着明日之景\\n[00:47.33]紧握心型磁石向前奔跑\\n[00:51.81]如今这样就让人非常欢乐\\n[00:55.92] “一直携手同行吧”\\n[00:57.92]\\n[00:58.15]究竟要怎样对待未来呢\\n[01:01.02]大家一路捕捉梦想的形状\\n[01:06.53]时而落泪 时而欢笑\\n[01:08.74]未来的我们一定早已知晓答案\\n[01:15.11]所以更应全心全意勇往直前\\n[01:23.33]\\n[01:30.19]在风雨中坚持歌唱\\n[01:36.11]因为相信着一定会放晴\\n[01:40.96]试着用元气满满的\\n[01:43.40]声音来呼喊吧\\n[01:46.69]这样定能相遇\\n[01:48.70]壮阔的梦想\\n[01:52.10]因为想要蜕变 所以要将尚且力所不及的事情\\n[01:56.30]一件一件把它们战胜\\n[02:01.74]波涛云海间的崭新蓝天\\n[02:07.20]正等待着 等待着我们呢\\n[02:11.94]\\n[02:12.36]满怀期待尽情绽放\\n[02:15.60]希望就着这个劲头\\n[02:18.73]一直勇往直前\\n[02:20.71]即使一路有笑有泪\\n[02:22.95]期待会向我们发来许多指引的信号\\n[02:29.40]所以不要逃避了 快把握住每个机遇\\n[02:36.68]\\n[02:45.10]\\n[02:48.47]\\n[02:52.69]跟随自我本心而努力\\n[02:57.26]是不是就能让梦想实现呢\\n[03:04.00]\\n[03:05.51]究竟要怎样对待未来呢\\n[03:08.21]那些梦想的轮廓\\n[03:13.77]就让大家一起来寻找吧\\n[03:15.61]\\n[03:15.97]满怀期待尽情绽放\\n[03:18.85]希望照着这个劲头一直勇往直前\\n[03:24.41]即使一路有笑有泪\\n[03:26.64]未来的我们一定早已知晓答案\\n[03:33.18]所以更应全心全意勇往直前\\n[03:40.28]把握住每个机遇\\n[03:48.10]化作闪耀的风儿\\n[03:51.10]\"\n  }\n];\nwindow.MUSE.render(playList, document.getElementById('muse-app'));\n<\\/script>\n\n<h1 id=\"感受\"><a href=\"#感受\" class=\"headerlink\" title=\"感受\"><\\/a>感受<\\/h1><p>各位有兴趣看题目的话地址在这里：<br><a href=\"https:\\/\\/www.luogu.org\\/contest\\/show?tid=4291\" target=\"_blank\" rel=\"external\">https:\\/\\/www.luogu.org\\/contest\\/show?tid=4291<\\/a><br><a href=\"https:\\/\\/www.luogu.org\\/problemnew\\/show\\/U14667\" target=\"_blank\" rel=\"external\">https:\\/\\/www.luogu.org\\/problemnew\\/show\\/U14667<\\/a><\\/p>\n<p>安排给我的出题难度是压轴（也就是最难的那一题），不过被我活生生出成了水题= =……出了一道状压 DP 的模板题（大概），然后呢并没有人帮我验题（事实上他们三个人互相 A 不掉对方的题目总共前前后后调到比赛都开始了还在出锅）……<\\/p>\n<p>于是因此发生了一件很尴尬的事情，就是造数据的时候呢，因为 std 出了锅少写了一个等于号，然后造出了一堆错误的数据，把正解卡到了 30 分= =比赛完了之后写题解才发现，卧槽标程都出锅了，然后更新数据、重传数据，联系了 luogu 的管理员帮我们重测，然后还一个一个给可能写了正解的参赛者发私信道歉+让他们请求重新提交……<\\/p>\n<p>提交了 80 多个人有将近 90% 是输出 No Answer 骗分的233333早知道不设这个点了（<\\/p>\n<p>最后重新提交完有两个写出了正解的 julao，一个写了接近正解但是差一点的 dalao……嘛，看起来这题出得还是挺水的（不过话说回来，比同校人出的那些题良心多了2333<\\/p>\n<hr>\n<p>接下来是题目：<\\/p>\n<h1 id=\"肝活动-event-pas-c-cpp\"><a href=\"#肝活动-event-pas-c-cpp\" class=\"headerlink\" title=\"肝活动 (event.pas\\/.c\\/.cpp)\"><\\/a>肝活动 (event.pas\\/.c\\/.cpp)<\\/h1><p>时间限制：1s \\/ 空间限制：512MB \\/ 测试点数目：20<\\/p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"><\\/a>题目描述<\\/h2><p>Yume 最近在玩一个名为《LoveLive! School idol festival》的音乐游戏。他之所以喜欢上这个游戏，是因为这个游戏对非洲人十分友好，即便你脸黑到抽不出好卡，还可以通过在每个月举办的两次活动中达成一定的目标来获得奖励。<br>Yume 很喜欢这一期活动奖励卡的卡面，于是他决定要肝这一期的活动，拿到活动奖励。这一期的活动规则很特殊，玩家需要在活动规定的结束时间前，完成所有指定的歌曲<strong>（每首歌只能打一次）<\\/strong>，并获得一定的分数，就可以拿到活动奖励。如果在规定的时间前没有完成所有的歌曲，或者分数不够奖励的分数线，则不能领取活动奖励。每首歌有一个限定的奖励开放时间，玩家如果在这段时间内完成了这首歌，便可以获得一定的分数<strong>（获得的分数 = 开放时间 - 当前已用的总时间）<\\/strong>。如果超出了这段时间之后再完成这首歌，就不能获得分数了。<br>这样的规则对 Yume 这样的老玩家来说本应是轻而易举，但不巧的是 Yume 把活动的结束时间记成了活动的开始时间，以至于当他上线跃跃欲试的时候，惊恐地发现活动已经快要结束了。现在他想知道，在剩余的时间之内，他能否完成所有的歌、达成奖励的分数线拿到活动卡。为了节省时间，他把这个问题交给了你来解决。请你根据给定的数据，帮他计算出能否在剩余的时间内达成目标。如果能，请告诉他完成每首歌曲的顺序。<\\/p>\n<h2 id=\"输入数据\"><a href=\"#输入数据\" class=\"headerlink\" title=\"输入数据\"><\\/a>输入数据<\\/h2><p>从文件 event.in 读取输入数据。<br>输入的第一行是三个整数 n, m, t，分别表示规定完成的歌曲数目、获得奖励需要达到的最低分数和距离活动结束剩余的时间。<br>接下来有 n 行，第 i 行有一个字符串 Si 和两个整数 Ti 和 Mi，表示第 i 首歌的歌名为 Si，完成第 i 首歌所需要的时间为 Ti，第 i 首歌的奖励开放时间剩余 Mi。保证 Ti ≤ Mi. 其中数据已按 Si 的字典序给出。<\\/p>\n<h2 id=\"输出数据\"><a href=\"#输出数据\" class=\"headerlink\" title=\"输出数据\"><\\/a>输出数据<\\/h2><p>将答案输出到 event.out 中。<br>如果在活动结束前 Yume 可以完成指定的目标拿到奖励，则在第一行输出一个整数 C，表示在获得奖励的前提下，所能够获得的分数的最大值；接下来的 n 行中，按照完成歌曲的顺序输出第 i 首歌的歌名。如果有多种可能性，则输出字典序最小的情况。<br>如果在活动结束前 Yume 不能完成所有的歌曲，输出 No Answer .<\\/p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"><\\/a>输入样例<\\/h2><blockquote>\n<p>【样例1】<br>3 2 10<br>BokutachiwaHitotsunoHikari 3 8<br>Korekara 1 2<br>SnowHalation 2 5<\\/p>\n<p>【样例2】<br>2 1 2<br>AoizoraJumpingHeart 1 2<br>TimeLapse 2 4<\\/p>\n<\\/blockquote>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"><\\/a>输出样例<\\/h2><blockquote>\n<p>【样例1】<br>6<br>SnowHalation<br>BokutachiwaHitotsunoHikari<br>Korekara<\\/p>\n<p>【样例2】<br>No Answer<\\/p>\n<p>样例1说明：<br>首先打第三首歌，用时 2，获得分数为 (5-2)=3；<br>接着打第一首歌，用时 3，获得分数为 (8-2-3)=3；<br>最后打第二首歌，用时 1，由于打完第二首歌之后总用时为 6，但第二首歌的奖励获得时间为 2，因此不能获得分数。<br>总用时为 6 &lt; 10，分数为 6 &gt; 2，完成目标。<\\/p>\n<\\/blockquote>\n<h2 id=\"数据规模\"><a href=\"#数据规模\" class=\"headerlink\" title=\"数据规模\"><\\/a>数据规模<\\/h2><p>对于 0% 的数据，与测试数据完全相同。<br>对于 20% 的数据，满足 n ≤ 5。<br>对于 40% 的数据，满足 n ≤ 9。<br>对于 70% 的数据，满足 n ≤ 15。<br>对于 100% 的数据，满足 n ≤ 22，Si 的长度不超过 50. 保证 m, t 和 Ti, Mi 以及其相加的结果都在 int 的最大范围内。<br>另有 10% 的数据满足 Sigma(T1, T2, …, Tn) &lt; t.<\\/p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"><\\/a>题解<\\/h1><p>没错，这是一道状态压缩 DP（而且事实上是道水题吧，感觉对不起提高+\\/省选-的评级 Orz）。很多人没写出来大概是因为被这个比赛发起人瞎 YY 的评级吓到了……不太明白状态压缩 DP 原理的= =嘛，建议先去理解一下，出题人太懒，不想在题解里写状压 DP 的原理（逃<\\/p>\n<p>首先要读懂题目的意思，找出关键的信息，这个不多说。注意一下分数的计算方式和获得奖励的条件即可。<\\/p>\n<p>先考虑无解的情况，第一种情况是当 <code>Sigma(T1, T2, T3, ..., Tn) &lt; t<\\/code> 的时候，在剩余时间内无法完成所有的歌，很明显应该输出 <code>No Answer<\\/code>.<\\/p>\n<p>还有一种情况是即便在规定时间内打完了所有的歌，仍然达不到规定的分数 m 的时候，也是 <code>No Answer<\\/code>，这种情况我们只能找到最大值后才计算。可惜有一位离正解很近的 julao 忘记了这种情况被砍掉了 15 = =<\\/p>\n<p>再就是状态的设计。题目中规定要完成每首歌，并且每首歌都只能打一次，那么我们设 <code>dp[i]<\\/code> 表示<strong>当前已完成的歌曲编号的二进制状态为 i 的情况下，能取得的分数的最大值<\\/strong>。<\\/p>\n<p>那么转移方程就显然了：<code>dp[i] = max(dp[i], dp[i &amp; (~j)] + limit[j] - curTime[i])<\\/code>，其中 <code>j<\\/code> 是当前考虑的歌曲编号，那么 <code>i &amp; (~j)<\\/code> 就是打第 j 首歌之前的状态，<code>limit[j]<\\/code> 表示能获得奖励分数的规定时间，<code>curTime[i]<\\/code> 就是打完第 j 首歌之后的总用时。<\\/p>\n<p>我们可以看到完成的歌曲的二进制状态为 i 时所用的时间 <code>curTime[i]<\\/code> 与打歌的顺序无关，所以我们可以预处理计算出这个 <code>curTime<\\/code> 数组:<\\/p>\n<pre><code class=\"cpp\">for (int i = 0; i &lt; (1 &lt;&lt; 22); i++)\n{\n  for (int j = 0; j &lt; n; j++)\n  {\n    \\/\\/ 状态 i 已经包含了第 j 首歌\n    if (i &amp; j) {\n      continue;\n    }\n    curTime[i | j] = curTime[i] + cost[j];\n  }\n}\n<\\/code><\\/pre>\n<p>当然你也可以不做这一步，直接在 DP 的时候更新当前状态的时间也没有问题。<\\/p>\n<p>接下来我们就可以写出 DP 的主过程了。Wait, 在此之前，细心的各位想必已经注意到了题目中的一个需求，如果多种打歌顺序都可获得最大值的话，那么要输出字典序最小的方案。这个怎么解决呢？再细心看一下题目会发现每首歌在给出的时候已经强调按照字典序排好了，所以我们只需要把正序枚举 j from 1 to n 改成逆序枚举 j from n to 1，这样就可以保证在遇到字典序更小的最优解的时候替换掉当前解。<\\/p>\n<pre><code class=\"cpp\">    for (int i = 0; i &lt;= (1 &lt;&lt; n); i++)\n    {\n        for (int j = n; j &gt;= 0; j--)\n        {\n            int cur = 1 &lt;&lt; j;\n            if (i &amp; cur) {\n                int prev = i &amp; (~cur);\n                int getscore = rest[j] - curTime[prev] - cost[j];\n                if (getscore &lt; 0) {\n                    getscore = 0;     \\/\\/ 记得把不能得到分数的情况修改掉\n                }\n                \\/\\/ 注意这里的条件是 &lt;=，因为当得分相等的时候取字典序更小的更优\n                if (dp[i].score &lt;= dp[prev].score + getscore) {\n                    dp[i].score = dp[prev].score + getscore;\n                    dp[i].cur = j;\n                    dp[i].prev = prev;\n                }\n            }\n        }\n    }\n<\\/code><\\/pre>\n<p>最后我们顺着 <code>dp[(1 &lt;&lt; n) - 1]<\\/code> 的状态一路推回去输出方案。在此之前别忘了再判断一下 m 与 <code>dp[(1 &lt;&lt; n) - 1]<\\/code> 的大小关系。还有一个要注意的地方是输出顺序的问题，因为是从最后一个推回去的，但是应该从第一个输出到最后一个，所以这个时候做一个 DFS 或者丢进栈里就完美啦。<\\/p>\n<h1 id=\"附上蒟蒻的标程\"><a href=\"#附上蒟蒻的标程\" class=\"headerlink\" title=\"附上蒟蒻的标程\"><\\/a>附上蒟蒻的标程<\\/h1><pre><code class=\"cpp\">#include &lt;cstdio&gt; \n#include &lt;cstring&gt;\n#include &lt;stack&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nconst int MAXS = (1 &lt;&lt; 24);\nconst int MAXN = 25;\n\nstruct State {\n    int cur;\n    int prev;\n    int score;\n};\nState dp[MAXS + 20];\n\nint n, m, t;\nint sum;\nint cost[MAXN], rest[MAXN];\nint curTime[MAXS + 20];\nchar name[MAXN][110];\n\nint main()\n{\n    memset(curTime, 0, sizeof curTime);\n    memset(dp, 0, sizeof dp);\n\n    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t);\n    for (int i = 0; i &lt; n; i++)\n    {\n        scanf(&quot;%s%d%d&quot;, name[i], &amp;cost[i], &amp;rest[i]);\n        sum += cost[i];\n    }\n\n    if (t &lt; sum) {\n        printf(&quot;No Answer&quot;);\n        return 0;\n    }\n\n    for (int i = 0; i &lt; (1 &lt;&lt; n); i++)\n    {\n        for (int j = n; j &gt;= 0; j--)\n        {\n            if (i &amp; (1 &lt;&lt; j)) {\n                continue;\n            }\n            int next = i | (1 &lt;&lt; j);\n            curTime[next] = curTime[i] + cost[j];\n        }\n    }\n\n    for (int i = 0; i &lt;= (1 &lt;&lt; n); i++)\n    {\n        for (int j = n; j &gt;= 0; j--)\n        {\n            int cur = 1 &lt;&lt; j;\n            if (i &amp; cur) {\n                int prev = i &amp; (~cur);\n                int getscore = rest[j] - curTime[prev] - cost[j];\n                if (getscore &lt; 0) {\n                    getscore = 0;\n                }\n                if (dp[i].score &lt;= dp[prev].score + getscore) {\n                    dp[i].score = dp[prev].score + getscore;\n                    dp[i].cur = j;\n                    dp[i].prev = prev;\n                }\n            }\n        }\n    }\n\n    int state = (1 &lt;&lt; n) - 1;\n\n    if (dp[state].score &gt;= m) {\n        printf(&quot;%d\\n&quot;, dp[state].score);\n    } else {\n        printf(&quot;No Answer&quot;);\n        return 0;\n    }\n\n    stack&lt;int&gt; S;\n    while (state != 0)\n    {\n        S.push(dp[state].cur);\n        state = dp[state].prev;\n    }\n\n    while (!S.empty())\n    {\n        int id = S.top();\n        S.pop();\n        printf(&quot;%s&quot;, name[id]);\n        if (!S.empty()) {\n            printf(&quot;\\n&quot;);\n        }\n    }\n\n    return 0;\n}\n<\\/code><\\/pre>\n",
      "excerpt": "<p>复赛在即，我们学校里面的四个撒币不知道是谁突发奇想，说要出一套模拟题。于是我们四个人分别出了一道要多恶心有多恶心的题= =本来嘛是要在学校内部自己测的，不过人太少，不好玩，于是就连夜 py 到洛谷上搞了公开赛。从早上 8 点到中午 12 点，虽然出了很多的锅，不过还是要记录一下我的第一次出题经历（<\\/p>",
      "slug": "my-first-contest-problem",
      "published": true,
      "layout": "post",
      "path": "blog/post/my-first-contest-problem/",
      "permalink": "https://kirainmoe.com/blog/post/my-first-contest-problem/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "algorithm",
          "slug": "algorithm",
          "path": "tags/algorithm/",
          "permalink": "https://kirainmoe.com/tags/algorithm/",
          "length": 8
        }
      ],
      "categories": []
    },
    {
      "title": "浅谈 KMP 字符串匹配算法",
      "date": "2017-10-17T05:01:43.000Z",
      "modified": "2018-01-07T05:18:28.578Z",
      "content": "<p>因为上周末 MFE 群里有位成员提到了这个算法，所以那天晚上就稍微认识了一下这个算法，感觉 KMP 对于匹配字符串上的做法还是好神奇的，值得水篇文章整理一下。<\\/p>\n<a id=\"more\"><\\/a>\n<blockquote>\n<p>很久没有更文了w 最近真的是非常非常非常忙qwq，刚刚送走了第二次阶段考就迎来了 NOIP 的初赛，然后接下来的一整个月都要在忙碌的准备中度过，11 月回来又是期中考qwq 所以你们会发现我的解题报告停更了半个月，这篇文章权当是补偿吧（ <\\/p>\n<\\/blockquote>\n<h1 id=\"KMP-算法\"><a href=\"#KMP-算法\" class=\"headerlink\" title=\"KMP 算法\"><\\/a>KMP 算法<\\/h1><blockquote>\n<p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现，因此人们称它为克努特——莫里斯——普拉特操作（简称KMP算法）。KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个next()函数，函数本身包含了模式串的局部匹配信息。时间复杂度O(m+n)。<\\/p>\n<\\/blockquote>\n<p>以上摘自百科，这段话已经详尽地阐明了什么是 KMP 算法、它的应用场景和高效性的核心原因。下面就不再多做介绍了w。<\\/p>\n<h1 id=\"原始的字符串匹配方法\"><a href=\"#原始的字符串匹配方法\" class=\"headerlink\" title=\"原始的字符串匹配方法\"><\\/a>原始的字符串匹配方法<\\/h1><p>首先回忆一下，如果我们要匹配两个字符串，一般是怎么做的？我想大部分的人应该会想到这样的答案：<\\/p>\n<ul>\n<li>用两个下标指针 i, j 分别指向我们要匹配的目标字符串 (target) 和给我们的模式串 (pattern)。<\\/li>\n<li>从 i = 0 作为起点开始，如果 target[i] == pattern[j]，就一步一步向右移动 i, j 指针。<\\/li>\n<li>当 target[i] != pattern[j] 的时候，就让 i 的起点右移一位，让 j = 0.<\\/li>\n<li>重新开始尝试匹配，直到匹配成功（返回 target 与 pattern 匹配的起始为止）或者 i = target.length 时仍然没有结果为止（此时 target 与 pattern 不匹配，返回 -1）。<\\/li>\n<\\/ul>\n<p>当然，这样的方法确实是正确的说，但是我们还需要考虑<s>这个效率 efficiency<\\/s>。很明显这个方法的时间复杂度是 O(n*m) 的~ 要是数据量很大的话就可能会超时哟（<\\/p>\n<p>那么有没有什么好一点的方法来优化我们匹配两个字符串的方式呢？<\\/p>\n<h1 id=\"优化的思想\"><a href=\"#优化的思想\" class=\"headerlink\" title=\"优化的思想\"><\\/a>优化的思想<\\/h1><p>下文中，我们把目标串 target 记作 T, 模式串 pattern 记作 P. 首先，让我们考虑这样两个字符串：<\\/p>\n<pre><code>target (T): ABCABCABDAB\npattern(P): ABCABD\n<\\/code><\\/pre><p>我们用上面的方法匹配的时候，让 i = j = 0，然后当 T[i] == P[j] 的时候，我们不断让 i, j 右移，直到 i = j = 5 的时候，我们发现 T[i](C) != P[j](D) 了。<\\/p>\n<p>按照我们上面的思路，我们会把 i 和 j 回溯：<\\/p>\n<pre><code> ↓ i = 1\nABCABCABDAB\n ABCABD\n ↑ j = 0\n<\\/code><\\/pre><p>这时候第一个字符就不匹配了，所以 i 继续右移，直到 i = 3, j = 0 的时候往下匹配，最后 i = 8, j = 5 的时候匹配成功：<\\/p>\n<pre><code>   ↓ i = 3\nABCABCABDAB\n   ABCABD\n   ↑ j = 0\n\n......\n\n        ↓ i = 8\nABCABCABDAB\n   ABCABD\n        ↑ j = 5\n<\\/code><\\/pre><p>但是我们发现了一件有趣的事情，就是，如果这件事让我们人为来做的话，当 i, j 从 0 开始匹配到 5 失败的时候，我们不会让 i = 1, 2, … 这样一直试到匹配为止。<br>因为我们发现我们在 i = 5 的时候匹配失败，P[0] = A, 但是 i = 5 的前面只有 i = 3 的时候 T[i] = A，所以 i = 1, 2 的时候我们根本不需要去匹配。我们能这么想，是因为我们已经知道匹配过的 i = 0~5 的情况了——这也正是 KMP 算法的精髓所在，<strong>KMP 算法高效的原因之一正是由于它能够利用已经匹配到的有效信息。<\\/strong><\\/p>\n<p>所以呢，上面提到的三个人就想到了一个方案：i 指针可以不动呀，我们只要移动 j 指针就可以了。<\\/p>\n<pre><code>     ↓ i = 5\nABCABCABDAB\nABCABD\n     ↑ j = 5\n<\\/code><\\/pre><p>这个时候让 i 不动，只移动 j：<\\/p>\n<pre><code>     ↓ i = 5\nABCABCABDAB\n   ABCABD\n     ↑ j = 2\n<\\/code><\\/pre><p>哎，你会发现这样比一起移动 i 和 j 快多了，对吗？这就是 KMP 算法的思想：<\\/p>\n<blockquote>\n<p>利用已经部分匹配这个有效信息，保持 i 指针不回溯，通过修改 j 指针，让模式串尽量地移动到有效的位置。<\\/p>\n<\\/blockquote>\n<h1 id=\"KMP-算法的灵魂-——-j-指针移动的位置\"><a href=\"#KMP-算法的灵魂-——-j-指针移动的位置\" class=\"headerlink\" title=\"KMP 算法的灵魂 —— j 指针移动的位置\"><\\/a>KMP 算法的灵魂 —— j 指针移动的位置<\\/h1><p>但是有人会问，我们要怎么知道 j 指针移动到哪个地方才合适呢？因为 j 的下一个位置很关键，如果 j 的下一个位置太提前，那么这个想法无异于没有优化；如果太靠后，那么两个字符串就无法匹配了。所以 j 指针的下一个位置是很重要的。KMP 算法中，用一个叫 <strong>next 数组<\\/strong> 的东西来记录 j 指针的下一个位置。<\\/p>\n<p>next 数组也是 KMP 的难点所在。如果你觉得 next 数组的求解很难理解，这里有几篇文章可以辅助你理解；下面我也会理一下从这几篇文章里整理出来的比较容易理解的东西：<\\/p>\n<blockquote>\n<p><a href=\"http:\\/\\/www.cnblogs.com\\/yjiyjige\\/p\\/3263858.html\" target=\"_blank\" rel=\"external\">http:\\/\\/www.cnblogs.com\\/yjiyjige\\/p\\/3263858.html<\\/a><br><a href=\"http:\\/\\/blog.csdn.net\\/henuyx\\/article\\/details\\/44653799\" target=\"_blank\" rel=\"external\">http:\\/\\/blog.csdn.net\\/henuyx\\/article\\/details\\/44653799<\\/a><\\/p>\n<\\/blockquote>\n<p>我们用 k 表示当 T[i] 与 P[j] 不匹配的时候，j 要移动的下一个位置，则 next[j] = k. 现在你可以猜到，<strong>next[j] 存储的是：当 T[i] 与 P[j] 匹配失败时，j 将要移动的下一个位置。<\\/strong><\\/p>\n<p>我们还是举上面那个例子吧：<\\/p>\n<pre><code>ABCABD\n     ↑ j = 5，匹配失败\n\nABCABD\n  ↑ j = 2，把 j 移动到这个位置\n<\\/code><\\/pre><p>有没有发现什么？没错， P[0~1] 和 P[3~4] 是重合的！<\\/p>\n<p>再比如说：<\\/p>\n<pre><code>       ↓ i = 7\nABCDABCDNAIVE\nABCDABCB\n       ↑ j = 7\n<\\/code><\\/pre><p>这个时候又匹配失败了。虽然我们作为人类，很容易看出这两个字符串无论怎么移动都不能匹配。不过我们这个时候还是要<s>假装尝试一下<\\/s>，我们会这样移动 j 指针：<\\/p>\n<pre><code>移动前：\n       ↓ i = 7\nABCDABCDNAIVE\nABCDABCB\n       ↑ j = 7\n移动后：\n       ↓ i = 7\nABCDABCDNAIVE\n    ABCDABCB\n       ↑ j = 3\n<\\/code><\\/pre><p>哎，是不是还是刚才的那个规律呢，模式串的 P[0~2] 和 P[4~6] 是重合的，而恰恰又是 j 移动的位置 3 把它们隔开了。<\\/p>\n<p>现在我们可以总结出这样的性质了：<strong>当 T[i] 与 P[j] 匹配失败的时候，j 移动到下一个位置 k，k 即为使得 <code>P[0, k-1] = P[j-k, j-1] (或者说 P[k+1, j-1])<\\/code> 的那个值。<\\/strong><\\/p>\n<p>引用一下一篇文章的证明：<\\/p>\n<blockquote>\n<p>当T[i] != P[j]时<br>有T[i-j ~ i-1] == P[0 ~ j-1]<br>由P[0 ~ k-1] == P[j-k ~ j-1]<br>必然：T[i-k ~ i-1] == P[0 ~ k-1]<\\/p>\n<\\/blockquote>\n<p>进一步我们还可以发现，这个 k 的位置完全取决于模式串 P 自身的性质，与目标串 T 无关。所以我们就可以预处理计算出对于每一个 j 的 k 值了。就如我们刚才所说的我们把 k 存储在 next 数组当中，那么接下来我们就来计算 next 数组。<\\/p>\n<h1 id=\"next-数组的计算\"><a href=\"#next-数组的计算\" class=\"headerlink\" title=\"next 数组的计算\"><\\/a>next 数组的计算<\\/h1><p>先温习一下 next 数组的含义和作用：<\\/p>\n<blockquote>\n<p> next[j] 存储的是：当 T[i] 与 P[j] 匹配失败时，j 将要移动的下一个位置。<\\/p>\n<\\/blockquote>\n<p>接下来我们分类讨论一下：<\\/p>\n<ol>\n<li>当 j = 0 的时候，显然 j 已经不能再往前移动了，我们这个时候应该保持 j 不动，然后向右移动 i 指针继续匹配。所以我们让 next[0] = -1，告诉 KMP 主算法已经不能再移动 j 指针了。<\\/li>\n<li>当 j = 1 的时候，显然 j 只能移动到 0，所以 next[1] = 0.<\\/li>\n<li>那么其他情况呢？如果 P[j] = P[k] 的话，那么 next[j+1] = next[j] + 1.<\\/li>\n<li>最后一种情况就是 P[j] != P[k]，那么我们就让 k = next[k], 重复这个步骤直到符合上面三个条件之一为止。<\\/li>\n<\\/ol>\n<p>至于为什么这样做，这里主要介绍一下 3 和 4：<\\/p>\n<h3 id=\"为什么-P-j-P-k-的时候，next-j-1-next-j-1-呢？\"><a href=\"#为什么-P-j-P-k-的时候，next-j-1-next-j-1-呢？\" class=\"headerlink\" title=\"为什么 P[j] = P[k] 的时候，next[j+1] = next[j] + 1 呢？\"><\\/a>为什么 P[j] = P[k] 的时候，next[j+1] = next[j] + 1 呢？<\\/h3><p>考虑这样一个字符串：<\\/p>\n<pre><code>index 0 1 2 3 4 5 6 7 8\nstr   A B C D A B C D E\nnext -1 0 0 0 0 0 0 3 4\n<\\/code><\\/pre><p>通过计算我们可以发现 next[7] = 3, 因为 3 的左边和右边都是 ABC，这个时候我们发现 P[7] = P[3] = D.<\\/p>\n<p>所以，我们发现，当 j = j+1 = 8 之后，next[8] = 4 = next[7] + 1. 这个规律也是可以证明的。这个证明同样是引用：<\\/p>\n<blockquote>\n<p>因为在P[j]之前已经有P[0 ~ k-1] == p[j-k ~ j-1]。（next[j] == k）<br>这时候现有P[k] == P[j]，我们可以得到P[0 ~ k-1] + P[k] == p[j-k ~ j-1] + P[j]。<br>即：P[0 ~ k] == P[j-k ~ j]，即next[j+1] == k + 1 == next[j] + 1。<\\/p>\n<\\/blockquote>\n<h3 id=\"那-P-j-P-k-的时候呢？\"><a href=\"#那-P-j-P-k-的时候呢？\" class=\"headerlink\" title=\"那 P[j] != P[k] 的时候呢？\"><\\/a>那 P[j] != P[k] 的时候呢？<\\/h3><p>如果没有赋值的时候，next[j] 默认是等于 0 的，否则 k 就是上一次计算的 k 值。<br>这样，当 P[j] != P[k] 的时候，我们就一直让 k = next[k]，直到 k 符合上面的条件之一为止。<\\/p>\n<p>鉴于……这个东西我也讲不清楚qwq 所以我找到了一篇总结的挺好的文章：<a href=\"https:\\/\\/www.zhihu.com\\/question\\/21474082。\" target=\"_blank\" rel=\"external\">https:\\/\\/www.zhihu.com\\/question\\/21474082。<\\/a> 虽然内容不长，但是我就不贴过来了。<\\/p>\n<h2 id=\"那么，我们可以整理出计算-next-数组的整个过程了：\"><a href=\"#那么，我们可以整理出计算-next-数组的整个过程了：\" class=\"headerlink\" title=\"那么，我们可以整理出计算 next 数组的整个过程了：\"><\\/a>那么，我们可以整理出计算 next 数组的整个过程了：<\\/h2><pre><code>初始化 next[] = 0\nnext[0] ← -1\nj ← 0, k ← -1, len ← (pattern 长度 - 1)\nwhile j &lt; len do\n  if k = -1 || pattern[j] = pattern[k] then\n    j ← j+1, k ← k+1\n    next[j] = k\n  else\n    k ← next[k]\n<\\/code><\\/pre><p>下面是一个用 C++ 实现的方式：<\\/p>\n<pre><code class=\"cpp\">void calcNextArr()\n{\n  next[0] = -1;\n  int j = 0, k = -1, len = strlen(pattern) - 1;\n  while (j &lt; len)\n  {\n    if (k == -1 || pattern[j] == pattern[k]) {\n      next[++j] = ++k;\n      \\/\\/ 如果要做时间复杂度优化，就加上下面的代码\n      if (pattern[j] == pattern[k]) {\n        next[j] = next[k];\n      }\n    } else {\n      k = next[k];\n    }\n  }\n}\n<\\/code><\\/pre>\n<h2 id=\"优化-next-数组的求解\"><a href=\"#优化-next-数组的求解\" class=\"headerlink\" title=\"优化 next 数组的求解\"><\\/a>优化 next 数组的求解<\\/h2><p>注意到我们在实现上面的伪代码的时候多了两句：<\\/p>\n<pre><code class=\"cpp\">if (pattern[j] == pattern[k]) {\n  next[j] = next[k];\n}\n<\\/code><\\/pre>\n<p>为什么要加这一句呢？我们可以看出如果 P[j] = P[k] 的时候，让 next[j] = next[k]. 但是我们上文不是说到，如果 P[j] = P[k] 的时候，next[j+1] = next[j] + 1 嘛，为什么又回去了呐？考虑这样的一个模式串：<\\/p>\n<pre><code>ABCABDNAIVE\nABCABCABDAB\n     ↑ j = 5\n<\\/code><\\/pre><p>如上，当我们在 j = 5 的地方匹配失败的时候，按照我们上面的算法，next[j] = 2，所以 j 会回溯到 2 的地方，指向 C. 但是我们发现就算 j 回溯到 j = 2 的时候，P[j] 仍然等于 C，依旧不能和目标串匹配啊。所以我们还是要把 j 继续回溯，那么这时候 next[j] = 0. 相信大家想到了，只要我们让 j = 5 的时候直接跳回 0，就可以省去多跳一步的步骤了，这就是这段代码的作用。<\\/p>\n<h1 id=\"KMP-主算法\"><a href=\"#KMP-主算法\" class=\"headerlink\" title=\"KMP 主算法\"><\\/a>KMP 主算法<\\/h1><p>了解了 next[] 数组之后，你已经完全了解 KMP 不远了。 接下来是 KMP 算法的整个流程<br>：<\\/p>\n<pre><code>T ← 目标串，P ← 模式串\ni ← 0, j ← 0\nnext[] ← calcNext(P)                   \\/\\/ 对模式串 P 计算其 next 数组的值\nwhile i &lt; T.length &amp;&amp; j &lt; P.length do\n  \\/\\/ 如果 j 已经指向模式串的起点了，就把 i 下移一位，j 置零；或者 T[i] 和 P[j] 匹配了，那么就把 i, j 一起下移一位\n  if j == -1 || T[i] == P[j] then\n    i ← i+1, j ← j+1\n  \\/\\/ 如果不匹配，那就让 j 回溯到 next[j] 位置\n  else\n    j ← next[j]\nif j &gt;= P.length                  \\/\\/ 此时匹配成功\n  return i-j                      \\/\\/ i-j 即为 T 与 P 匹配时 T 串开始的位置\nelse\n  return -1                       \\/\\/ 否则返回不匹配，用 -1 表示\n<\\/code><\\/pre><p>仍旧是一份 C++ 实现的模板：<\\/p>\n<pre><code class=\"cpp\">int KMP()\n{\n  int i = 0, j = 0;\n  int tlen = strlen(target), plen = strlen(pattern);\n  while (i &lt; tlen &amp;&amp; j &lt; plen)\n  {\n    if (j == -1 || target[i] == pattern[j]) {\n      i++, j++;\n    } else {\n      j = next[j];\n    }\n  }\n\n  if (j == plen) {\n    return i - j;\n  } else {\n    return -1;\n  }\n}\n<\\/code><\\/pre>\n<h1 id=\"解决实际问题\"><a href=\"#解决实际问题\" class=\"headerlink\" title=\"解决实际问题\"><\\/a>解决实际问题<\\/h1><h2 id=\"HDU2087\"><a href=\"#HDU2087\" class=\"headerlink\" title=\"HDU2087\"><\\/a>HDU2087<\\/h2><p>地址在这里：<a href=\"http:\\/\\/acm.hdu.edu.cn\\/showproblem.php?pid=2087\" target=\"_blank\" rel=\"external\">http:\\/\\/acm.hdu.edu.cn\\/showproblem.php?pid=2087<\\/a><\\/p>\n<p>分析题目我们可以发现这就是一道简单的裸题字符串匹配，我们当然可以直接上 KMP 啦。下面是这题的 AC 代码：<\\/p>\n<pre><code class=\"cpp\">#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n\nconst int MAXN = 1e3 + 10;\nint n[MAXN];\nchar target[MAXN], pattern[MAXN];\n\nvoid init()\n{\n  memset(target, 0, sizeof target);\n  memset(pattern, 0, sizeof pattern);\n  memset(n, 0, sizeof n);\n}\n\nvoid calcNext()\n{\n  n[0] = -1;\n  int i = 0, k = -1, len = strlen(pattern) - 1;\n  while (i &lt; len)\n  {\n    if (k == -1 || pattern[i] == pattern[k]) {\n      n[++i] = ++k;\n      if (pattern[i] == pattern[k]) {\n        n[i] = n[k];\n      }\n    } else {\n      k = n[k];\n    }\n  }\n}\n\nint KMP()\n{\n  int ans = 0, i = 0, j = 0;\n  int tlen = strlen(target), plen = strlen(pattern);\n\n  while (i &lt; tlen)\n  {\n    if (j == -1 || target[i] == pattern[j]) {\n      i++, j++;\n    } else {\n      j = n[j];\n    }\n    if (j == plen) {\n      j = 0;\n      ans++;\n    }    \n  }\n  return ans;\n}\n\nint main()\n{\n  while (~scanf(&quot;%s&quot;, target))\n  {\n    if (target[0] == &#39;#&#39;)\n      break;\n    scanf(&quot;%s&quot;, pattern);\n    calcNext();\n    int ans = KMP();\n    printf(&quot;%d\\n&quot;, ans);\n    init();\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h2 id=\"luogu-3375\"><a href=\"#luogu-3375\" class=\"headerlink\" title=\"luogu 3375\"><\\/a>luogu 3375<\\/h2><p>这题也是个 KMP，可能有多个匹配，那么它要输出每个匹配的位置；以及这题的 next 数组不能优化，因为他还要输出= =我就是用了优化的 next 数组然后 WA 了好多次（<br>总之写起来大概像下面这样：<\\/p>\n<pre><code class=\"cpp\">#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int MAXN = 1000050;\nint next[MAXN], n[MAXN];\nint len1, len2;\nchar target[MAXN], pattern[MAXN];\n\nvoid calcNext()\n{\n    int j = 0, k = -1;\n    next[0] = -1, n[0] = -1;\n    while (j &lt; len2)\n    {\n        if (k == -1 || pattern[j] == pattern[k]) {\n            next[++j] = ++k;\n            n[j] = k;\n            if (pattern[j] == pattern[k]) {\n                n[j] = n[k];\n            }\n        } else {\n            k = next[k];\n        }\n    }\n}\n\nvoid kmp()\n{\n    int i = 0, j = 0;\n    while (i &lt; len1)\n    {\n        if (j == -1 || target[i] == pattern[j]) {\n            i++, j++;\n        } else {\n            j = n[j];\n        }\n\n        if (j == len2) {\n            printf(&quot;%d\\n&quot;, i - j + 1);\n            j = n[j];\n        }\n    }\n}\n\nint main()\n{\n    scanf(&quot;%s%s&quot;, target, pattern);\n    len1 = strlen(target);\n    len2 = strlen(pattern);\n    calcNext();\n    kmp();\n    for (int i = 1; i &lt;= len2; i++)\n    {\n        printf(&quot;%d &quot;, next[i]);\n    }    \n    printf(&quot;\\n&quot;);\n    return 0;\n}\n<\\/code><\\/pre>\n<p>至此，我们对 KMP 的算法就有了一个比较完整的了解了。<\\/p>\n",
      "excerpt": "<p>因为上周末 MFE 群里有位成员提到了这个算法，所以那天晚上就稍微认识了一下这个算法，感觉 KMP 对于匹配字符串上的做法还是好神奇的，值得水篇文章整理一下。<\\/p>",
      "slug": "kmp-algorithm-for-matching-string",
      "published": true,
      "layout": "post",
      "path": "blog/post/kmp-algorithm-for-matching-string/",
      "permalink": "https://kirainmoe.com/blog/post/kmp-algorithm-for-matching-string/",
      "tags": [
        {
          "name": "algorithm",
          "slug": "algorithm",
          "path": "tags/algorithm/",
          "permalink": "https://kirainmoe.com/tags/algorithm/",
          "length": 8
        },
        {
          "name": "kmp",
          "slug": "kmp",
          "path": "tags/kmp/",
          "permalink": "https://kirainmoe.com/tags/kmp/",
          "length": 1
        }
      ],
      "categories": []
    },
    {
      "title": "使用 LaTeX + Beamer 制作幻灯片 (Windows)",
      "date": "2017-09-17T08:32:47.000Z",
      "modified": "2018-01-07T05:18:30.179Z",
      "content": "<p>因为这周的演讲涉及到一些很难用嘴巴讲明白的东西，就打算做一个幻灯片在演讲的时候放映辅助理解。看着自己在 PowerPoint 下这里调调那里改改，挣扎了两天之后才憋出了 3 页的效率，于是果断打算另寻一种方法来做幻灯片。突然想到前几个月省夏的时候讲师的幻灯片都做得很漂亮（但是很明显不是 PPT 做的），于是去查找了一下相关的资料，就发现了下文中制作幻灯片的一个神器：LaTeX + Beamer.<\\/p>\n<a id=\"more\"><\\/a>\n<h1 id=\"为什么选用-LaTeX-Beamer\"><a href=\"#为什么选用-LaTeX-Beamer\" class=\"headerlink\" title=\"为什么选用 LaTeX + Beamer?\"><\\/a>为什么选用 LaTeX + Beamer?<\\/h1><blockquote>\n<p>LaTeX 是一种基于ΤΕΧ的排版系统，利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。<\\/p>\n<\\/blockquote>\n<p>Beamer 是基于 LaTeX 的一个制作幻灯片的框架。我之所以选用 Beamer 是因为有了两者的搭配，在制作幻灯片的时候你完全不用太过担心如何排版，如何布局，在不同的设备上显示的效果如何，就像用 Markdown 在写作那样，你只需要把你的内容按照格式打进去，它就会编译生成很漂亮、工整的幻灯片，你需要做的只是微调一下显示的效果，以及花更多的精力在雕琢你的内容而不是板式上。<\\/p>\n<p>配置 LaTeX + Beamer 环境比较复杂，因为自己在没有按照现有教程的情况下一步一步地尝试，就这一步折腾了两个小时。但是接下来真正制作幻灯片的时候是很省力省时的，至少是用 PowerPoint 效率的两倍以上，而且一次配置终身受益，也算是值得了。<\\/p>\n<h1 id=\"配置环境\"><a href=\"#配置环境\" class=\"headerlink\" title=\"配置环境\"><\\/a>配置环境<\\/h1><h2 id=\"1-安装-Tex-编译器-TeXLive\"><a href=\"#1-安装-Tex-编译器-TeXLive\" class=\"headerlink\" title=\"1. 安装 Tex 编译器 TeXLive\"><\\/a>1. 安装 Tex 编译器 TeXLive<\\/h2><p>我的工作环境系统是 Windows 10 1703 x64, 用的是 TeXLive 的发行版，编辑 tex 使用的是 Sublime Text 3 + LaTeXTools(不得不说 Sublime 对 LaTeX 的支持确实不错，不像某 VSCode). 需要注意的是我用相同的步骤在 32 位 Windows 10 下配置出现了一些问题，目前暂不知道由什么引起。<\\/p>\n<p>首先到 <a href=\"http:\\/\\/www.tug.org\\/texlive\\/acquire-netinstall.html\" target=\"_blank\" rel=\"external\">http:\\/\\/www.tug.org\\/texlive\\/acquire-netinstall.html<\\/a> 下载适用于 Windows 的最新的 TeXLive 安装程序。然后运行它。<\\/p>\n<p>接下来选择你要如何安装 TeXLive, 有简单安装（就是安装所有东西）和自定义安装，自定义安装里你可以选择一些你想装和不想装的东西，如果你选择完全安装，那装完会有接近 6 个 G 的样子。如果你选择自定义安装，接下来会让你选择安装的路径和需要的东西。勾选一些必要的东西和去掉一些你不需要的语言包就可以了。<\\/p>\n<p>然后是一个漫长的安装过程。TeXLive 的安装程序会自动下载刚刚你选择要安装的东西，默认的安装目录是 <code>C：\\texlive\\2017\\<\\/code> 下。安装完后你可以选择把安装目录下的 bin\\win32 文件夹 (例如<code>C:\\texlive\\2017\\bin\\win32<\\/code>) 加入到系统的环境变量中。<\\/p>\n<h2 id=\"2-安装-Sumatra-PDF\"><a href=\"#2-安装-Sumatra-PDF\" class=\"headerlink\" title=\"2. 安装 Sumatra PDF\"><\\/a>2. 安装 Sumatra PDF<\\/h2><p>这是一款轻便的 PDF 阅读器，用于接下来我们把 LaTeX 文件编译成 PDF 的时候阅览，以及在写作的时候通过 Sublime Text 的插件 LaTexTools 编译，然后实时查看更改（<s>传说中的热更新<\\/s>）。<\\/p>\n<p>这一步比较简单，可以在这里下载到 Sumatra PDF: <a href=\"https:\\/\\/www.sumatrapdfreader.org\\/free-pdf-reader.html\" target=\"_blank\" rel=\"external\">https:\\/\\/www.sumatrapdfreader.org\\/free-pdf-reader.html<\\/a><\\/p>\n<p>安装完成之后要把 Sumatra PDF 的安装路径加到环境变量里（你应该知道环境变量在哪儿设置的哦？此电脑\\/计算机\\/这台电脑\\/我的电脑 右键→属性→高级→环境变量，编辑 Path 值，在内容的后面加一个英文的分号然后把路径贴进去）。<\\/p>\n<h2 id=\"3-安装和配置-Sublime-Text\"><a href=\"#3-安装和配置-Sublime-Text\" class=\"headerlink\" title=\"3. 安装和配置 Sublime Text\"><\\/a>3. 安装和配置 Sublime Text<\\/h2><p>Sublime Text 3 很容易可以下载到并且安装，这里就不赘述了，各位码农们一定很熟悉这个编辑器了。安装完后我们打开它，先安装它的插件包管理器 Package Control, 键盘按 Ctrl + ~，打开控制台，粘贴：<\\/p>\n<pre><code class=\"python\">import urllib.request,os,hashlib; h = &#39;6f4c264a24d933ce70df5dedcf1dcaee&#39; + &#39;ebe013ee18cced0ef93d5f746d80ef60&#39;; pf = &#39;Package Control.sublime-package&#39;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#39;http:\\/\\/packagecontrol.io\\/&#39; + pf.replace(&#39; &#39;, &#39;%20&#39;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#39;Error validating download (got %s instead of %s), please try manual install&#39; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#39;wb&#39; ).write(by)\n<\\/code><\\/pre>\n<p>然后回车，等待它有反应之后就是安装好了。接着按 Ctrl + Shift + P, 选择 Package Control: Install Package, 搜索 LaTexTools 并且安装。<\\/p>\n<p>安装好后，我们在 Preference -&gt; Package Settings -&gt; LaTexTools -&gt; Settings - User，一路点是，然后我们接下来要修改它的配置文件。主要是修改两个地方就行：<\\/p>\n<p>第一个是修改 LaTeX 发行版和 Sumatra PDF 的位置，在文件大概 209 行的位置，找到：<\\/p>\n<pre><code class=\"json\">  &quot;windows&quot;: {\n    \\/\\/ 修改这里的值为 texlive 安装位置的 bin\\win32 文件夹的路径，然后在最后补上一个 ;$PATH 即可，如下\n    &quot;texpath&quot; : &quot;D:\\\\texlive\\\\2017\\\\bin\\\\win32;$PATH&quot;,\n    \\/\\/ TeX 发行版，修改成 texlive\n    &quot;distro&quot; : &quot;texlive&quot;,\n    \\/\\/ Sumatra PDF 的安装位置，要精确到 exe 文件的路径\n    &quot;sumatra&quot;: &quot;C:\\\\Program Files\\\\SumatraPDF\\\\SumatraPDF.exe&quot;,\n    \\/\\/ ...\n  },\n<\\/code><\\/pre>\n<p>第二个是修改编译 tex 文件的方法，在大概 379 行的位置找到：<\\/p>\n<pre><code class=\"json\">  \\/\\/ 把 traditional 改成 simple 或者 basic\n  &quot;builder&quot;: &quot;traditional&quot;,\n<\\/code><\\/pre>\n<p>这样我们就搭建好了环境。接下来就只需要创建一个 tex 文件，写好之后 Ctrl+B 编译就行了，记得在 Tools -&gt; Build system 里设置为 Auto.<\\/p>\n<h1 id=\"Beamer-基本用法\"><a href=\"#Beamer-基本用法\" class=\"headerlink\" title=\"Beamer 基本用法\"><\\/a>Beamer 基本用法<\\/h1><pre><code class=\"latex\">\\documentclass{beamer}\n\\usepackage[utf8]{inputenc}\n% 引入中文支持\n\\usepackage{CJKutf8}\n% 插入图片用的 package\n\\usepackage{graphicx}\n\\usepackage{ulem}\n% 主题和配色\n\\usetheme{Hannover}\n\\usecolortheme{spruce}\n\n\n% 幻灯片信息\n\\title{Slide Title}\n\\author{Slide Author}\n\\institute{Slide Subtitle}\n\\date{\\today}\n\n\\begin{document}\n  % 中文支持\n  \\begin{CJK}{UTF8}{gbsn}\n    % 插入标题页面\n    \\frame{titlepage}\n\n    % 一张幻灯片\n    \\begin{frame}\n      \\frametitle{幻灯片标题}\n      % 无序列表\n      \\begin{itemize}\n        % \\pause 用于单步放映\n        \\item Item 1\\pause\n        \\item Item 2\\pause\n        \\item Item 3\\pause\n      \\end{itemize}\n    \\end{frame}\n\n    % 模块\n    \\section{分类1}\n      \\subsection{标题1}\n      \\begin{frame}\n        \\frametitle{LaTeX + Beamer 基本用法}\n        % 居中\n        \\begin{Center}\n          Contents that will be displayed on center.\n        \\end{center}\n\n        % 插入一张图片\n        \\includegraphics[height=4cm]{img\\/1.png}\n\n        % 表格\n          \\begin{table}[h]\n          \\centering\n          \\begin{tabular}{|c|c|}\n            \\hline 基因型 &amp; 血型 \\\\\n            \\hline I$^{A}$I$^{A}$, I$^{A}$i &amp; A 型 \\\\\n            \\hline I$^{B}$I$^{B}$, I$^{B}$i &amp; B 型 \\\\\n            \\hline I$^{A}$I$^{B}$ &amp; AB 型 \\\\\n            \\hline ii &amp; O 型 \\\\\n            \\hline\n          \\end{tabular}\n          \\caption{基因型和血型的对应关系}\n          \\label{tab:Margin_settings}\n      \\end{frame}\n  \\end{CJK}\n\\end{document}\n<\\/code><\\/pre>\n<p>大概是这样的。其实用起来还是非常简单的。写完之后按上面的方法编译，然后你就可以找到 tex 文件目录下的 pdf 文件，这个就是编译出的幻灯片。至此我们就完成了 LaTeX + Beamer 环境在 Windows 下的配置。 Linux 和 macOS 下大同小异，就是安装发行版的过程和插件配置时的路径有区别，具体请自行搜索。<\\/p>\n",
      "excerpt": "<p>因为这周的演讲涉及到一些很难用嘴巴讲明白的东西，就打算做一个幻灯片在演讲的时候放映辅助理解。看着自己在 PowerPoint 下这里调调那里改改，挣扎了两天之后才憋出了 3 页的效率，于是果断打算另寻一种方法来做幻灯片。突然想到前几个月省夏的时候讲师的幻灯片都做得很漂亮（但是很明显不是 PPT 做的），于是去查找了一下相关的资料，就发现了下文中制作幻灯片的一个神器：LaTeX + Beamer.<\\/p>",
      "slug": "making-slider-with-latex-beamer-on-windows",
      "published": true,
      "layout": "post",
      "path": "blog/post/making-slider-with-latex-beamer-on-windows/",
      "permalink": "https://kirainmoe.com/blog/post/making-slider-with-latex-beamer-on-windows/",
      "tags": [
        {
          "name": "latex",
          "slug": "latex",
          "path": "tags/latex/",
          "permalink": "https://kirainmoe.com/tags/latex/",
          "length": 1
        },
        {
          "name": "beamer",
          "slug": "beamer",
          "path": "tags/beamer/",
          "permalink": "https://kirainmoe.com/tags/beamer/",
          "length": 1
        }
      ],
      "categories": []
    },
    {
      "title": "每周解题报告 (4th, 8/20~9/10)",
      "date": "2017-09-10T03:16:22.000Z",
      "modified": "2018-01-07T05:18:35.990Z",
      "content": "<p>经过了一周阶段考的折磨过后，这一周终于有时间更新解题报告了。上一周因为时间太少，加上填 MUSE 的坑，只做了一题，索性都屯到这一周来发了，但虽然这样这周的题量还是没有多到哪里去……<\\/p>\n<p>有些比较简单的题目我就两句话带过就好了。特地在 GitHub 上开了个仓库，这一篇包括之前那些解题报告中题目的所有完整代码（以及部分题的数据）以及接下来做的 HDU 的题都会汇总在<a href=\"https:\\/\\/github.com\\/kirainmoe\\/oh-my-hdu\" target=\"_blank\" rel=\"external\">这个地方<\\/a>。<\\/p>\n<a id=\"more\"><\\/a>\n<h1 id=\"13-200-HDU1069-Monkey-and-Banana\"><a href=\"#13-200-HDU1069-Monkey-and-Banana\" class=\"headerlink\" title=\"13\\/200, HDU1069, Monkey and Banana\"><\\/a>13\\/200, HDU1069, Monkey and Banana<\\/h1><h2 id=\"Solution\"><a href=\"#Solution\" class=\"headerlink\" title=\"Solution\"><\\/a>Solution<\\/h2><p>经典 DP，最开始的思路是……设一个四维的状态…反正数据范围这么小是吧 (x) 后来写了好久写不下去了。查了一发题解，随便点开一个，看到第一句话：先把 x 排序，然后把 y 排序……会了……<\\/p>\n<p>那么，首先输入一组 xyz，然后排序一下，选择其中两个当做 width 和 length，然后最后一个数当 height；把 x, y 分别按照从大到小的顺序排序一遍，然后对 z 求满足第 i 层的 x, y 小于第 i-1 层的 x, y 时的最大 z 之和就好了。<\\/p>\n<p>转移方程：<code>dp[i] = dp[j] + block[i].height, 其中 j = 0...i-1<\\/code><\\/p>\n<p><em>\\/\\/ PS. 嘛，顺序枚举 j 似乎会 WA，所以 j 要从 i-1 倒回去。 <\\/em><\\/p>\n<h2 id=\"Code\"><a href=\"#Code\" class=\"headerlink\" title=\"Code\"><\\/a>Code<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nusing namespace std;\nconst int MAXN = 35 * 6 + 10;\nstruct Block {\n  int x, y, z;\n};\nBlock b[MAXN];\nint T, kases = 0;\nint size = 0, ans = 0;\nint dp[MAXN];\n\nbool cmp(const Block a, const Block b)\n{\n  if (a.x &gt; b.x)\n    return true;\n  if (a.x == b.x &amp;&amp; a.y &gt; b.y)\n    return true;\n  return false;\n}\n\nint main()\n{\n  while (scanf(&quot;%d&quot;, &amp;T) != EOF &amp;&amp; T != 0)\n  {    \n    size = 0, ans = 0;\n    memset(b, 0, sizeof(b));\n    memset(dp, 0, sizeof(dp));\n\n    for (int i = 0; i &lt; T; i++)\n    {\n      int tx, ty, tz;\n      scanf(&quot;%d%d%d&quot;, &amp;tx, &amp;ty, &amp;tz);\n      int arr[3] = {tx, ty, tz};\n\n      sort(arr, arr + 3);\n\n      \\/\\/ permutation\n      b[size].x = arr[0], b[size].y = arr[1], b[size++].z = arr[2];\n      b[size].x = arr[0], b[size].y = arr[2], b[size++].z = arr[1];\n      b[size].x = arr[1], b[size].y = arr[2], b[size++].z = arr[0];\n\n      sort(b, b+size, cmp);\n    }\n\n    for (int i = 0; i &lt; size; i++)\n    {\n      dp[i] = b[i].z;\n      for (int j = i - 1; j &gt;= 0; j--)\n      {\n        if (b[i].x &lt; b[j].x &amp;&amp; b[i].y &lt; b[j].y) {\n          dp[i] = max(dp[j] + b[i].z, dp[i]);\n        }\n      }\n      ans = max(ans, dp[i]);\n    }\n    printf(&quot;Case %d: maximum height = %d\\n&quot;, ++kases, ans);\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"14-200-HDU1176-免费馅饼\"><a href=\"#14-200-HDU1176-免费馅饼\" class=\"headerlink\" title=\"14\\/200, HDU1176, 免费馅饼\"><\\/a>14\\/200, HDU1176, 免费馅饼<\\/h1><h2 id=\"Solution-1\"><a href=\"#Solution-1\" class=\"headerlink\" title=\"Solution\"><\\/a>Solution<\\/h2><p>这题有两种做法。<\\/p>\n<ol>\n<li><p>第一种是直接 DP，注意的是可以不要想太多去检查状态是否合法，状态表示和转移方程：<code>dp[i][j]<\\/code> 表示第 i 秒的时候站在第 j 个位置能接到的最大馅饼数，<br>则：<code>dp[i][j]  = max(dp[i-1][j], dp[i-1][j-1], dp[i-1][j+1]) + items[i][j] (如果 j-1 和 j+1 存在)<\\/code><\\/p>\n<\\/li>\n<li><p>数塔做法：联想一下数字三角形，从下往上递推回去就行了。<code>dp[i][j]<\\/code> 还是表示第 i 秒在第 j 个位置能取到的最大值，不同的是要逆推，并且可以直接覆盖掉之前的值（因为计算完就没有用了），则：<br><code>dp[i][j] =  max(dp[i+1][j-1], dp[i+1][j], dp[i+1][j+1]) + dp[i][j]<\\/code><\\/p>\n<\\/li>\n<\\/ol>\n<h2 id=\"Code-1\"><a href=\"#Code-1\" class=\"headerlink\" title=\"Code\"><\\/a>Code<\\/h2><pre><code class=\"cpp\">\\/\\/ Solution 1\n#include &lt;bits\\/stdc++.h&gt;\nusing namespace std;\n\nconst int MAXT = 1e5 + 10;\nconst int MAXP = 11;\n\nint n, mt, ans = 0;\nint items[MAXT][MAXP];\nint dp[MAXT][MAXP];\n\nint cmp(int a, int b, int c)\n{\n  return max(a, max(b, c));\n}\n\nint main()\n{\n  while (scanf(&quot;%d&quot;, &amp;n) != EOF &amp;&amp; n != 0)\n  {\n    memset(items, 0, sizeof(items));\n    memset(dp, 0, sizeof(dp));\n    mt = 0, ans = 0;\n    for (int i = 0; i &lt; n; i++)\n    {\n      int x, t;\n      scanf(&quot;%d%d&quot;, &amp;x, &amp;t);\n      items[t][x]++;\n      mt = max(t, mt);\n    }\n\n    dp[1][4] = items[1][4];\n    dp[1][5] = items[1][5];\n    dp[1][6] = items[1][6];\n\n    for (int i = 2; i &lt;= mt; i++)\n    {\n      for (int j = 0; j &lt; MAXP; j++)\n      {\n        dp[i][j] = dp[i-1][j];\n        if (j == 0) {\n          dp[i][j] = max(dp[i-1][j], dp[i-1][j+1]) + items[i][j];\n        } else if (j == MAXP - 1) {\n          dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + items[i][j];\n        } else {\n          dp[i][j] = cmp(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]) + items[i][j];\n        }\n        ans = max(ans, dp[i][j]);\n      }\n    }\n\n    printf(&quot;%d\\n&quot;, ans);\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<pre><code class=\"cpp\">\\/\\/ Solution 2\n#include &lt;bits\\/stdc++.h&gt; \nusing namespace std;\nconst int MAXT = 1e5 + 10;\nconst int MAXP = 11;\n\nint n, mt, ans = 0;\nint pies[MAXT][MAXP];\n\nint main()\n{\n  while (scanf(&quot;%d&quot;, &amp;n) != EOF &amp;&amp; n)\n  {\n    memset(pies, 0, sizeof(pies));\n    ans = 0;\n    for (int i = 0; i &lt; n; i++)\n    {\n      int x, t;\n      scanf(&quot;%d%d&quot;, &amp;x, &amp;t);\n      pies[t][x]++;\n      mt = max(mt, t);\n    }\n\n    for (int i = mt - 1; i &gt;= 0; i--)\n    {\n      for (int j = 0; j &lt; MAXP; j++)\n      {\n        int tmp = pies[i][j];       \\/\\/ current\n        pies[i][j] = pies[i+1][j];\n\n        if (j &gt; 0) {\n          pies[i][j] = max(pies[i+1][j-1], pies[i][j]);\n        }\n\n        if (j &lt; MAXP - 1) {\n          pies[i][j] = max(pies[i+1][j+1], pies[i][j]);\n        }\n\n        pies[i][j] += tmp;\n      }\n    }\n\n    printf(&quot;%d\\n&quot;, pies[0][5]);\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"15-200-Codeforces-846A-Curriculum-Vitae\"><a href=\"#15-200-Codeforces-846A-Curriculum-Vitae\" class=\"headerlink\" title=\"15\\/200, Codeforces 846A, Curriculum Vitae\"><\\/a>15\\/200, Codeforces 846A, Curriculum Vitae<\\/h1><h2 id=\"Solution-2\"><a href=\"#Solution-2\" class=\"headerlink\" title=\"Solution\"><\\/a>Solution<\\/h2><p>题意就是一个人要找工作，要在简历上介绍他所完成过的游戏，游戏有成功的和失败的，这个人不想让任何失败的游戏出现在成功的游戏之后，然后求他最多可以在他的简历上放上多少个这样的符合要求的游戏。<\\/p>\n<p>↑ 说成人话就是：求一个由 0 和 1 组成的序列的子序列，这个子序列满足没有一个 0 在 1 的右边，且长度尽可能大。例如 0 1 0 0 1 0 的符合要求的子序列为 0 0 0 1 或 0 0 0 0.<\\/p>\n<p>翻译完之后我们可以发现，只要找到一个最长的数列的，使得它的左边都是 0，右边都是 1 就可以了。然后我们可以发现这个子序列满足<strong>最长不下降（注意不是最长上升）<\\/strong>的性质。鉴于数据范围 &lt;= 100，所以我们可以用 O(n^2) 的最长不下降子序列算法直接过。<\\/p>\n<p>第二天想了一下，突然觉得这题似乎还有线性的做法：考虑第 i 件作品是否入选，和它的上一件符合性质要求的作品有关。假如第 i 件作品是失败的，那么第 i 件写入简历时，最大值为 <strong>上一件失败作品的最大值 + 1<\\/strong>；如果第 i 件作品是成功的，那么第 i 件写入简历时最大值为 <strong>上一件失败作品的最大值 和 上一件成功作品的最大值 两者的最大值 + 1<\\/strong>。这样，我们可以用一个 <code>last0<\\/code> 表示上一件失败作品的位置，用 <code>last1<\\/code> 表示上一件成功作品的位置。具体的转移方程可以看代码：<\\/p>\n<h2 id=\"Code-2\"><a href=\"#Code-2\" class=\"headerlink\" title=\"Code\"><\\/a>Code<\\/h2><pre><code class=\"cpp\">\\/\\/ Solution 1: O(n^2)\n#include &lt;bits\\/stdc++.h&gt; \nusing namespace std;\nconst int MAXN = 105;\nconst int INF = 1e9 + 7;\nint n, ans = 0;\nint arr[MAXN];\nint dp[MAXN];\nint main()\n{\n  memset(arr, 0, sizeof(arr));\n  memset(dp, 0, sizeof(dp));\n\n  scanf(&quot;%d&quot;, &amp;n);\n  for (int i = 0; i &lt; n; i++)\n  {\n    scanf(&quot;%d&quot;, &amp;arr[i]);\n  }\n\n  for (int i = 0; i &lt; n; i++)\n  {\n    dp[i] = 1;\n    for (int j = 0; j &lt; i; j++)\n    {\n      if (arr[j] &lt;= arr[i] &amp;&amp; dp[i] &lt; dp[j] + 1)\n      {\n        dp[i] = dp[j] + 1;\n      }\n    }\n    ans = max(dp[i], ans);\n  }\n\n  printf(&quot;%d&quot;, ans);\n\n  return 0;\n}\n<\\/code><\\/pre>\n<pre><code class=\"cpp\">\\/\\/ Solution 2: O(n)\n#include &lt;bits\\/stdc++.h&gt;\nusing namespace std;\nconst int MAXN = 105;\nint n;\nint dp[MAXN];\nint last0 = -1, last1 = -1;\nint main()\n{\n    memset(dp, 0, sizeof(dp));\n    scanf(&quot;%d&quot;, &amp;n);\n    for (int i = 0; i &lt; n; i++)\n    {\n        int tmp;\n        scanf(&quot;%d&quot;, &amp;tmp);\n        if (tmp == 0) {\n            dp[i] = (last0 == -1 ? 1 : dp[last0] + 1);\n            last0 = i;\n        } else {\n            if (i == 0) {\n                dp[i] = 1;\n            } else {\n              dp[i] = 1;\n                if (last0 != -1) {\n                    dp[i] = max(dp[last0] + 1, dp[i]);\n                }\n                if (last1 != -1) {\n                    dp[i] = max(dp[last1] + 1, dp[i]);\n                }\n            }\n            last1 = i;\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i &lt; n; i++)\n    {\n      ans = max(ans, dp[i]);\n  }\n  printf(&quot;%d&quot;, ans);\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"16-200-Codeforces-854A-Fraction\"><a href=\"#16-200-Codeforces-854A-Fraction\" class=\"headerlink\" title=\"16\\/200, Codeforces 854A, Fraction\"><\\/a>16\\/200, Codeforces 854A, Fraction<\\/h1><p>嗯……太水了，不想写了，就是单纯的计算。<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nconst int INF = 1e9 + 7;\nint gcd(int a, int b)\n{\n  return (a == 0) ? b : gcd(b % a, a);\n}\nint main()\n{\n  int ori, curi = 1, curj = INF;\n\n  scanf(&quot;%d&quot;, &amp;ori);\n  for (int i = 1; i &lt; ori; i++)\n  {\n    for (int j = i + 1; j &lt; ori; j++)\n    {\n      int gcder = gcd(j, i);\n      double a = (double) i, b = (double) j;\n\n      if (\n        (i + j) == ori &amp;&amp;\n        gcder == 1 &amp;&amp;\n        (double)(a \\/ b) &gt; (double)((double)curi \\/ (double)curj)\n      ) {\n        curi = i, curj = j;\n      }\n    }\n  }\n\n  printf(&quot;%d %d&quot;, curi, curj);\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"17-200-HDU4568-Hunter\"><a href=\"#17-200-HDU4568-Hunter\" class=\"headerlink\" title=\"17\\/200, HDU4568, Hunter\"><\\/a>17\\/200, HDU4568, Hunter<\\/h1><p>这题前前后后花了我两星期的时间……这星期又花了三天的时间看它，终于理解并且 A 掉了这题……果然状态压缩还是一个大坑 Orz……<\\/p>\n<h2 id=\"Solution-3\"><a href=\"#Solution-3\" class=\"headerlink\" title=\"Solution\"><\\/a>Solution<\\/h2><p>题目大意是给定一个 n*m 的地图，其中有一些点当中有宝藏，经过地图中的每个点都需要花费相应的代价。一个人要从边界进入这个地图，经过所有的宝藏点，然后从边界走出，问这样做的最小代价是多少。n, m &lt;= 200, 宝藏数目 1 &lt;= k &lt;= 13.<\\/p>\n<p>首先题目的模型说成人话就是从边界的任何一点进入，取走所有宝藏，然后从边界的任意一点走出，所以我们可以知道最小代价应该是：从边界到第一个点的代价+第一个点到第二个点的代价+……+从终点走出边界的代价，这样这道题就被我们分解成了一个个的子问题了，我们只需要分别计算这些子问题就可以了。现在：<\\/p>\n<ol>\n<li><p>从边界到第一个点的最小代价和从终点走出的边界如何知道？从第 i 个点到第 j 个点的最小代价又如何知道？SPFA 对每一个宝藏点跑一遍就行了，这样我们总共需要进行 k 次 SPFA。<\\/p>\n<\\/li>\n<li><p>如何决策？每次拓展都选择当前一步代价最小的方案走显然有可能不是最优解，所以我们还是用动态规划来解全局最优的最小代价。<\\/p>\n<\\/li>\n<li><p>用 DP 如何表示状态？这道题的要求是走完所有的宝藏点，那么我们首先考虑如何表示经过的和未经过的宝藏点。因为 k &lt;= 13，我们的第一反应应该是状态压缩。用二进制表示状态点的经过情况，二进制第 i 位为 0 表示未经过第 i 个宝藏点，为 1 则表示已经经过，然后把二进制状态转换成十进制的整数即可。还有一个问题，假如只设置这样的一个状态，那么只能表示经过的点情况，不能表示终点在哪一个点，而我们到达终点的时候还需要从边界走出去，这样就还差一步，所以我们再设计一维状态，那么：<\\/p>\n<\\/li>\n<\\/ol>\n<blockquote>\n<p>设 <code>dp[i][j]<\\/code> 为当前经过的点状态为 i 且最后所在的终点位置为 j 时，所花费的最小代价。这样我们还能顺便得到转移方程：<code>dp[s | (1 &lt;&lt; next)][next] = min(dp[s | (1 &lt;&lt; next)][next], dp[s][cur] + toEach[cur][next])<\\/code>, 其中 s 是当前状态，cur 是当前状态的终点，next 是下一步的点。<\\/p>\n<\\/blockquote>\n<p>（为什么这里不需要表示起点？因为我们用 <code>dp[1 &lt;&lt; i][i] = toEdge[i]<\\/code> 可以很容易地表示以第 i 个点为起点时的代价，又我们的状态从 0 开始，所以起点在哪可以直接决策；但是终点我们很难通过 DP 方程直接决策，所以我们多一维状态。）<\\/p>\n<p>首先我们用 SPFA 先求出每两个宝藏点之间的距离和每个宝藏点到边界的距离（注意节点的拓展方向），然后就可以状态压缩了。DP 完之后，别忘了要回到边界，所以最终 <code>ans = min(dp[(1 &lt;&lt; k) - 1][i] + toEdge[i], ans), 其中 i = 0...k<\\/code>.<\\/p>\n<p>这样我们就完美地解决了这个问题。<\\/p>\n<h2 id=\"Code-3\"><a href=\"#Code-3\" class=\"headerlink\" title=\"Code\"><\\/a>Code<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt;\nusing namespace std;\nconst int INF = 1e9 + 7;\nconst int MAXN = 205;\nconst int MAXT = 14;\n\nstruct Point {\n  int x, y;\n};\nPoint target[MAXT];    \\/\\/ 宝藏坐标\n\nint k, cases, row, col;\n\n\\/\\/ dp[i][j] 表示当前已经过的宝藏点状态为 i, 并且终点为 j 时所花费的最小代价\n\\/\\/ 那么有 DP 方程：dp[s|(1&lt;&lt;next)][next] = min(dp[s|(1&lt;&lt;next)][s], dp[s][cur] + toEach[cur][next]);\n\\/\\/ 其中 next 是下一个目标状态点，cur 是当前状态的终点\nint dp[1 &lt;&lt; MAXT][MAXT];\n\n\\/\\/ 用于 SPFA 计算每个宝藏点之间的距离\nint dist[MAXN][MAXN];\n\n\\/\\/ toEdge[i] 表示第 i 个宝藏点到边界的最小代价（不包括本身）\n\\/\\/ toEach[i][j] 表示第 i 个宝藏点到第 j 个宝藏点的最小代价\nint toEdge[MAXT], toEach[MAXT][MAXT];\n\n\\/\\/ SPFA 拓展节点的方向\nint dir[2][4] = {\n  { 0, 0, 1, -1 },\n  { 1, -1, 0, 0 }\n};\n\n\\/\\/ SPFA 记录点访问情况的数组\nbool vis[MAXN][MAXN];\n\n\\/\\/ 用不定长数组存储地图\nvector&lt;int&gt; G[MAXN];\n\nvoid SPFA(int s)\n{\n  \\/\\/ 初始化 SPFA\n  memset(vis, 0, sizeof(vis));\n  for (int i = 0; i &lt; MAXN; i++)\n    for (int j = 0; j &lt; MAXN; j++)\n      dist[i][j] = INF;\n\n  queue&lt;Point&gt; Q;\n\n  Point start;\n  start.x = target[s].x, start.y = target[s].y;\n  vis[start.x][start.y] = 1;    \\/\\/ 标记起点为已访问\n  dist[start.x][start.y] = 0;   \\/\\/ 起点到自身的最短路为 0\n  Q.push(start);\n\n  while (!Q.empty())\n  {\n    Point cur = Q.front();\n    Q.pop();\n    vis[cur.x][cur.y] = 0;    \\/\\/ 当前节点出队，标记为未访问\n\n    \\/\\/ 到达边界，更新该点到边界的距离\n    if (cur.x == 0 || cur.y == 0 || cur.x == row - 1 || cur.y == col - 1) {\n      toEdge[s] = min(toEdge[s], dist[cur.x][cur.y]);\n    }\n\n    \\/\\/ 拓展节点\n    for (int i = 0; i &lt; 4; i++)\n    {\n      Point next;\n      next.x = cur.x + dir[0][i], next.y = cur.y + dir[1][i];\n      \\/\\/ 检验节点合法性以及是否可到达\n      if (next.x &gt;= 0 &amp;&amp; next.y &gt;= 0 &amp;&amp; next.x &lt; row &amp;&amp; next.y &lt; col &amp;&amp; G[next.x][next.y] != -1) {\n        \\/\\/ 松弛操作\n        if (dist[next.x][next.y] &gt; dist[cur.x][cur.y] + G[next.x][next.y]) {\n          dist[next.x][next.y] = dist[cur.x][cur.y] + G[next.x][next.y];\n          if (!vis[next.x][next.y]) {\n            Q.push(next);\n            vis[next.x][next.y] = 1;\n          }\n        }\n      }\n    } \\/\\/ end for i\n  } \\/\\/ end while\n}\n\nvoid init()\n{\n  for (int i = 0; i &lt; MAXN; i++)\n    G[i].clear();\n\n  for (int i = 0; i &lt; (1 &lt;&lt; MAXT); i++)\n    for (int j = 0; j &lt; MAXT; j++)\n      dp[i][j] = INF;\n\n  fill(toEdge, toEdge + MAXT, INF);\n\n  for (int i = 0; i &lt; MAXT; i++)\n    for (int j = 0; j &lt; MAXT; j++)\n      toEach[i][j] = INF;\n}\n\nint main()\n{\n  scanf(&quot;%d&quot;, &amp;cases);\n  while (cases--)\n  {\n    init();\n    scanf(&quot;%d%d&quot;, &amp;row, &amp;col);\n    for (int i = 0; i &lt; row; i++)\n    {\n      for (int j = 0; j &lt; col; j++)\n      {\n        int tmp;\n        scanf(&quot;%d&quot;, &amp;tmp);\n        G[i].push_back(tmp);\n      }\n    }\n    scanf(&quot;%d&quot;, &amp;k);\n    for (int i = 0; i &lt; k; i++)\n    {\n      scanf(&quot;%d%d&quot;, &amp;target[i].x, &amp;target[i].y);\n    }\n\n    \\/\\/ 求每两个宝藏点之间的最短距离（最小代价）\n    for (int i = 0; i &lt; k; i++)\n    {\n      SPFA(i);\n      for (int j = 0; j &lt; k; j++)\n      {\n        \\/\\/ 自身到自身的代价为 0\n        if (i == j) {\n          toEach[i][j] = 0;\n          continue;\n        }\n        int jx = target[j].x, jy = target[j].y;\n        toEach[i][j] = min(toEach[i][j], dist[jx][jy]);\n      }\n      \\/\\/ dp[1 &lt;&lt; i][i] 表示只访问了第 i 个点时的代价\n      \\/\\/ 等于：从边界进来时的代价 + 自身的代价\n      dp[1 &lt;&lt; i][i] = toEdge[i] + G[target[i].x][target[i].y];\n    }\n\n    \\/\\/ solve\n    \\/\\/ 枚举从 0 到 (1 &lt;&lt; k) - 1 的每个状态\n    for (int state = 0; state &lt; (1 &lt;&lt; k); state++)\n    {\n      \\/\\/ 枚举该状态当前的终点\n      for (int i = 0; i &lt; k; i++)\n      {\n        \\/\\/ 如果状态不包含当前点，则回溯\n        if ((state &amp; (1 &lt;&lt; i)) == 0) {\n          continue;\n        }\n\n        \\/\\/ 如果当前状态下到终点的距离还没有计算，则回溯？\n        \\/\\/ 不太清楚是不是这样的，因为我注释掉这段代码仍然是 AC 的\n        if (dp[state][i] == INF) {\n          continue;\n        }\n\n        \\/\\/ 枚举在当前状态时，下一个目标是去哪一个宝藏点呢\n        for (int j = 0; j &lt; k; j++)\n        {\n          \\/\\/ 如果这个宝藏点已经访问过了，就回溯，因为每个点只能走一次\n          if ((state &amp; (1 &lt;&lt; j)) == 1) {\n            continue;\n          }\n          \\/\\/ 下一个状态\n          int next = (state | (1 &lt;&lt; j));\n\n          \\/\\/ 下一个状态 next，终点为 j 的最小代价等于 这个代价 和 当前代价+(cur, next)两点间最短距离 的最小值\n          dp[next][j] = min(dp[next][j], dp[state][i] + toEach[i][j]);\n        } \\/\\/ for j\n      } \\/\\/ for i\n    } \\/\\/ for state\n\n    \\/\\/ 输出答案\n    int ans = INF;\n    for (int i = 0; i &lt; k; i++)\n    {\n      \\/\\/ 最终的最优答案是 min(dp[(1 &lt;&lt; k) - 1][i]), i = 0...k\n      \\/\\/ 因为 dp[i][j] 是以 j 为终点，但是我们最终需要从边界出去，所以还要加上终点到边界的最短距离\n      ans = min(dp[(1 &lt;&lt; k) - 1][i] + toEdge[i], ans);\n    }\n    printf(&quot;%d\\n&quot;, ans);\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<p>\\/\\/ EOF<\\/p>\n",
      "excerpt": "<p>经过了一周阶段考的折磨过后，这一周终于有时间更新解题报告了。上一周因为时间太少，加上填 MUSE 的坑，只做了一题，索性都屯到这一周来发了，但虽然这样这周的题量还是没有多到哪里去……<\\/p>\n<p>有些比较简单的题目我就两句话带过就好了。特地在 GitHub 上开了个仓库，这一篇包括之前那些解题报告中题目的所有完整代码（以及部分题的数据）以及接下来做的 HDU 的题都会汇总在<a href=\"https:\\/\\/github.com\\/kirainmoe\\/oh-my-hdu\">这个地方<\\/a>。<\\/p>",
      "slug": "practicing-record-4th-8-20-9-10",
      "published": true,
      "layout": "post",
      "path": "blog/post/practicing-record-4th-8-20-9-10/",
      "permalink": "https://kirainmoe.com/blog/post/practicing-record-4th-8-20-9-10/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "algorithm",
          "slug": "algorithm",
          "path": "tags/algorithm/",
          "permalink": "https://kirainmoe.com/tags/algorithm/",
          "length": 8
        }
      ],
      "categories": []
    }
  ],
  "menu": {
    "Home": "/",
    "Guestbook": "/pages/guestbook/",
    "Friends": "/pages/friends/",
    "About": "https://about.me/kirainmoe"
  },
  "socials": {
    "twitter": "https://twitter.com/yume_kankawa",
    "github": "https://github.com/kirainmoe",
    "weibo": "https://weibo.com/returnnnn",
    "medium": "https://medium.com/@kotori",
    "lastfm": "https://www.last.fm/user/kirainmoe"
  },
  "avatar": "https://secure.gravatar.com/avatar/c47187d311099868de825697fa419654?s=200&r=G",
  "menuIcon": {
    "Home": "home",
    "Guestbook": "book",
    "Friends": "users",
    "Archives": "tags",
    "About": "id-card-o"
  },
  "disqus": "yume-diary",
  "prev": 0,
  "next": 2
}</script>
  <!-- hook node of React -->
  <div id="himawari-app"></div>

  
    <!-- scripts list from theme config.yml -->
    
      <script src="https://unpkg.com/muse-player/dist/assets/muse-player.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/prism.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-clike.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-php.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-css.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-c.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-cpp.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-javascript.min.js"></script>
    
      <script src="/common.js"></script>
    
      <script src="/main.js"></script>
    
  

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-111347233-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-111347233-1');
  </script>

</body>
</html>
