<!-- Himawari no Yakusoku -->

<!DOCTYPE html>
<html lang="Zh-cn">
<head>
  <meta charset="UTF-8">
  <meta name="theme-color" content="#FF98A8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Archives: 2017 [ YumeのDiary ]</title>
  <meta name="description" content="6 年間、共に歩んでくれたあなたへ。">
  <link rel="manifest" href="/manifest.json">
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    
      <link rel="stylesheet" href="/himawari.css">
    
  
</head>
<body>
  
  <!-- infos -->
  <script type="text/json" id="himawari-json">{
  "title": "YumeのDiary",
  "siteTitle": "YumeのDiary",
  "description": "6 年間、共に歩んでくれたあなたへ。",
  "author": "Yume Kankawa",
  "route": "year",
  "format": "blog/:layout/:title/",
  "posts": [
    {
      "title": "开发一个简单的 webpack 插件",
      "date": "2017-09-02T03:59:44.000Z",
      "modified": "2018-01-07T05:18:45.784Z",
      "content": "<p>之前为了尝试实现 <a href=\"https:\\/\\/kotori.love\" target=\"_blank\" rel=\"external\">dalao<\\/a> 的一个 idea，浅浅地踩了一下 webpack 插件开发的坑。今天才想起来，趁着有时间，应该整理一下开发 webpack 插件的思路。<\\/p>\n<a id=\"more\"><\\/a>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"><\\/a>前言<\\/h1><p>首先呢，webpack 的强大功能其中有很大的一部分是离不开插件的，通过插件你几乎可以<s>为所欲为<\\/s>，也能更充分地利用 webpack. 事实上 webpack 的配置什么的很多看起来很复杂，文档也很多，所以会给很多人一种它的插件也很难搞的错觉……和其它的程序类似， webpack 的插件也有一个模子，也就是基本框架。<\\/p>\n<p>为了让整理出来的东西看起来具体一些，我以前文提到的那个想法为例，这个想法具体如下：<\\/p>\n<blockquote>\n<p>在我们使用 webpack-dev-server 结合 webpack 开发的时候，webpack-dev-server 会把 console 中的错误和警告信息转发到浏览器端，但是单纯用 <code>webpack --watch<\\/code> 的时候，webpack 除了会检测文件变动重新 compile 之外并不会把其他信息转发到浏览器上，以至于有时候我们发现了一些问题，到最后切到 console 才发现是编译的过程出现了偏差。所以有没有什么办法让 <code>webpack --watch<\\/code> 的时候也能把错误和警告显示到浏览器的 console？<\\/p>\n<\\/blockquote>\n<p>当然我不把具体的实现过程展开了。这样的需求显然可以通过 webpack 插件实现，监听 webpack 的 compile 事件，获取异常信息，然后前端和后端建立一个 socket 连接，实时输出这些信息。<\\/p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"><\\/a>实现<\\/h1><p>是的，以上所有的步骤都可以通过一个 webpack 插件做到。不多说废话，在开发之前稍微浏览一下 webpack 的官方开发文档还是很重要的：<\\/p>\n<blockquote>\n<p>How to write a plugin: <a href=\"https:\\/\\/webpack.js.org\\/development\\/how-to-write-a-plugin\\/#compiler-and-compilation\" target=\"_blank\" rel=\"external\">https:\\/\\/webpack.js.org\\/development\\/how-to-write-a-plugin\\/#compiler-and-compilation<\\/a><br>Plugin API: <a href=\"https:\\/\\/webpack.js.org\\/api\\/\" target=\"_blank\" rel=\"external\">https:\\/\\/webpack.js.org\\/api\\/<\\/a><\\/p>\n<\\/blockquote>\n<p>先来看看我们是怎么在 webpack 中应用插件的：<\\/p>\n<pre><code class=\"js\">\\/\\/ webpack.config.js\nplugins: [\n  new webpack.HotModuleReplacementPlugin(),\n  new webpack.NoEmitOnErrorsPlugin()\n],\n<\\/code><\\/pre>\n<p>可以看到，我们在 <code>webpack config<\\/code> 中的 <code>plugins<\\/code> 字段里实例化一个对象来应用插件，所以我们的新插件也应该有一个 class. 官方文档中用的是 ES5 的 <code>function + prototype<\\/code> 的写法，我们可以直接用上 ES6 的 class. 假设插件名字为 <code>MyAwesomePlugin<\\/code>, 首先我们创建一个 <em>MyAwesomePlugin.js<\\/em>：<\\/p>\n<pre><code class=\"js\">module.exports = class MyAwesomePlugin {\n    constructor(options) {\n        this.options = options;\n    }\n\n    apply(compiler) {\n        console.log(&#39;Hello world!&#39;);\n    }\n};\n<\\/code><\\/pre>\n<p>在这个文件里我们 export 了一个叫做 <code>MyAwesomePlugin<\\/code> 的类。其中有一个 <code>apply()<\\/code> 方法，它表示在 webpack 初次加载完此插件的时候应该做的事情，也就是只会在 webpack 启动的时候被执行一次。接下来如果我们监听 compile 的事件等等，首先就要在这里写一下；假如我们的插件依赖于一个 express 的后端服务器，那么我们也可以在 <code>apply()<\\/code> 里初始化 express。<\\/p>\n<p>然后我们试着应用这个插件，在你的 <code>webpack.config.js<\\/code> 中：<\\/p>\n<pre><code class=\"js\">const MyAwesomePlugin = require(&#39;.\\/MyAwesomePlugin&#39;);\n\n\\/\\/ ...\n\nplugins: [\n    \\/\\/ ...\n    new MyAwesomePlugin()\n]\n<\\/code><\\/pre>\n<p>然后尝试着启动 webpack，如果一切正常，你应该在 console 中看到 <code>Hello, world!<\\/code> 了。<\\/p>\n<p>接下来我们就开始做实事了，回头看看我们的需求，这是一个需要前后端配合的工作，首先我们需要在后端拥有一个 socket 服务器，然后监听 webpack 每次编译完后的结果，把信息通过这个 socket 服务器发送到浏览器。要实现这一步，还需要浏览器加载和后端服务器通信的相关 JS.启动 socket 服务器这件事我们在 <code>apply()<\\/code> 方法中完成就可以了，接下来是事件监听。<\\/p>\n<p>说到事件监听，首先这里要区分一下 webpack 中的两个概念：<code>compiler<\\/code> 和 <code>compilation<\\/code>.<\\/p>\n<hr>\n<h2 id=\"compiler\"><a href=\"#compiler\" class=\"headerlink\" title=\"compiler\"><\\/a>compiler<\\/h2><p>首先你一定已经注意到上文的代码中，<code>apply()<\\/code> 方法传入了一个叫 <code>compiler<\\/code> 的参数。这个所谓的 <code>compiler<\\/code> 对象从字面意思上看是编译器的意思，实际上它也就指向了当前运行的 webpack 实例。这个实例包含了 webpack 的所有 options, loaders 和 plugins, 它随着 webpack 的启动而产生，可以说是 webpack 的“灵魂”。当我们运用一个插件时（即插件类被实例化，同时类中的 <code>apply()<\\/code> 方法被调用的时候），<code>apply()<\\/code> 方法便会接收到一个指向这个 <code>compiler<\\/code> 的参数，我们可以通过这个 <code>compiler<\\/code> 访问整个 webpack 环境。<\\/p>\n<h3 id=\"compilation\"><a href=\"#compilation\" class=\"headerlink\" title=\"compilation\"><\\/a>compilation<\\/h3><p>对 <code>compiler<\\/code> 有了一定的了解之后，大概我们就可以猜到 <code>compilation<\\/code> 是干什么用的了。所谓 <code>compilation<\\/code> 包含了 webpack 每次 build 后的详细信息，包括编译出的结果、错误信息、模块、编译后的资源、改变的文件和依赖等的当前状态，同时它提供了很多的事件挂钩，以便于插件来执行一些<s>黑魔法<\\/s>。<\\/p>\n<hr>\n<p>具体的 API 可以在上文给出的链接中找到，这里我们直接贴出代码后再解释：<\\/p>\n<pre><code class=\"js\">apply(compiler) {\n    compiler.plugin(&#39;compilation&#39;, this.injectScriptToBundle.bind(this));\n    compiler.plugin(&#39;done&#39;, this.onBuildCompleted.bind(this));\n}\n<\\/code><\\/pre>\n<p>这一段代码中我们监听了 <code>compiler<\\/code> 的两个事件（可以看到我们是用 <code>compiler.plugin(hook, method)<\\/code> 方法注册事件的）：<\\/p>\n<ul>\n<li>第一是在每次文件变动，重新编译的时候，执行 <code>this.injectScriptToBundle()<\\/code> 方法；<\\/li>\n<li>第二是编译完成之后，执行 <code>this.onBuildCompleted()<\\/code> 方法。<\\/li>\n<\\/ul>\n<p>根据方法名我们大致可以构想一下，前一个方法用于把前端与后端交互用的 JS 代码注入到 bundle 中（显然，我们是不会直接把这样的调试用代码写到源代码里的），后一个方法大概就是把编译完成之后异常信息发送出去了。<\\/p>\n<p>我们先来看看 <code>injectScriptToBundle()<\\/code> 方法：<\\/p>\n<pre><code class=\"js\">injectScriptToBundle(compilation) {\n    compilation.mainTemplate(&#39;startup&#39;, source =&gt; {\n        return &quot;\\nconsole.log(&#39;Hello world!&#39;);\\n&quot; + source;\n    });\n}\n<\\/code><\\/pre>\n<p>我已经截掉了一些对这篇文章没有什么用的代码。首先我们可以看到这个方法有一个参数，而这个参数正是上文提到的 <code>compilation<\\/code>. 这一段代码的作用就是在即将编译的源代码的开头部分插入一段我们自定义的 JS 代码。<\\/p>\n<p>对了，这里面出现了一个 <code>mainTemplate<\\/code> 方法，具体可以看看 webpack 的官方文档：<a href=\"https:\\/\\/webpack.js.org\\/api\\/plugins\\/template\\/#src\\/components\\/Sidebar\\/Sidebar.jsx\" target=\"_blank\" rel=\"external\">https:\\/\\/webpack.js.org\\/api\\/plugins\\/template\\/#src\\/components\\/Sidebar\\/Sidebar.jsx<\\/a><\\/p>\n<p>然后接下来我们只需要在 <code>onBuildCompleted()<\\/code> 方法中获取并向前端发送信息即可：<\\/p>\n<pre><code class=\"js\">onBuildCompleted(stats) {\n    const detail = stats.toJson({\n        errorDetails: false\n    });\n\n    this.sendWarnings(statsJson.warnings);\n    this.sendErrors(statsJson.errors);\n}\n<\\/code><\\/pre>\n<p>忽略掉发送信息那部分的代码，我们只要看上半部分就好了。<code>stats<\\/code> 参数随着 <code>compiler<\\/code> 的 <code>done<\\/code> 事件被触发后产生，包含本次编译的结果统计信息。它提供了一个 <code>toJson()<\\/code> 方法，可以把这些信息转换成直观的 JSON，然后我们也就可以从这个 JSON 里拿到我们想要的内容了。<\\/p>\n<p>做好了这一切之后，大概已经实现了我们的目标了。上文的示例代码可以在<a href=\"https:\\/\\/github.com\\/moefront\\/webpack-plugin-console-to-browser\" target=\"_blank\" rel=\"external\">这里<\\/a>找到。<\\/p>\n<h1 id=\"推荐阅读\"><a href=\"#推荐阅读\" class=\"headerlink\" title=\"推荐阅读\"><\\/a>推荐阅读<\\/h1><ul>\n<li>细说webpack之流程篇：<a href=\"http:\\/\\/www.cnblogs.com\\/yxy99\\/p\\/5852987.html\" target=\"_blank\" rel=\"external\">http:\\/\\/www.cnblogs.com\\/yxy99\\/p\\/5852987.html<\\/a><\\/li>\n<li>Compiler and Compilation: <a href=\"https:\\/\\/webpack.js.org\\/development\\/how-to-write-a-plugin\\/#compiler-and-compilation\" target=\"_blank\" rel=\"external\">https:\\/\\/webpack.js.org\\/development\\/how-to-write-a-plugin\\/#compiler-and-compilation<\\/a><\\/li>\n<li>Accessing the compilation: <a href=\"https:\\/\\/webpack.js.org\\/development\\/how-to-write-a-plugin\\/#accessing-the-compilation\" target=\"_blank\" rel=\"external\">https:\\/\\/webpack.js.org\\/development\\/how-to-write-a-plugin\\/#accessing-the-compilation<\\/a><\\/li>\n<li>webpack 插件开发简要：<a href=\"http:\\/\\/www.cnblogs.com\\/sampapa\\/p\\/6958166.html\" target=\"_blank\" rel=\"external\">http:\\/\\/www.cnblogs.com\\/sampapa\\/p\\/6958166.html<\\/a><\\/li>\n<\\/ul>\n",
      "excerpt": "<p>之前为了尝试实现 <a href=\"https:\\/\\/kotori.love\">dalao<\\/a> 的一个 idea，浅浅地踩了一下 webpack 插件开发的坑。今天才想起来，趁着有时间，应该整理一下开发 webpack 插件的思路。<\\/p>",
      "slug": "webpack-plugin-developing-tutorial",
      "published": true,
      "layout": "post",
      "path": "blog/post/webpack-plugin-developing-tutorial/",
      "permalink": "https://kirainmoe.com/blog/post/webpack-plugin-developing-tutorial/",
      "tags": [
        {
          "name": "webpack",
          "slug": "webpack",
          "path": "tags/webpack/",
          "permalink": "https://kirainmoe.com/tags/webpack/",
          "length": 3
        },
        {
          "name": "frontend",
          "slug": "frontend",
          "path": "tags/frontend/",
          "permalink": "https://kirainmoe.com/tags/frontend/",
          "length": 4
        }
      ],
      "categories": []
    },
    {
      "title": "八月のif",
      "date": "2017-08-26T10:27:16.000Z",
      "modified": "2018-01-07T05:18:27.776Z",
      "content": "<p>炎夏的阳光在远处悠悠荡荡地摇曳<br>注视着西下的夕阳 心中无限遐思<br>倘若当初我们没有相遇相识<br>等待着我们的会是怎样的夏天呢<br><a id=\"more\"><\\/a><br>想象着 （这不一样的夏天）<br>大家追寻着 （各自的梦想）<br>可是真的会 变成那样吗<br>到底还是会 在某一天 走到一起的吧<\\/p>\n<p>这熠熠生辉的 八月的遐想<br>来探索这转瞬即逝的夏天的秘密吧<br>就这样下去 屏住呼吸就好<br>放弃那遐想吧 把当下紧紧拥入怀中吧<\\/p>\n<hr>\n<p><em>算下来已经很久没有在自己的博客里写过日记了。自从换了 Hexo 之后惊喜地发现某辣鸡爬虫站（对，就是那个叫什么推酷的）终于不爬我的文章了，所以就可以没有后顾之忧地在这里写一点什么乱七八糟的东西了。一直以来都认认真真并且很谨慎地在写博客的每一篇文章，是时候加点什么不一样的东西了。<\\/em><br>这个八月很快就要结束了。八月，对于很多孩子们来说大概是很令人享受的暑假时光，只不过这个八月对我来说似乎并没有什么特别的地方，除了过完这个月距离 2017 年高考倒计时又少了好几天罢了。<br>是的，过完这个八月，我就真的正式踏进高三的门了。所以从另一个角度来说，这也是我人生中意义最非凡的一个八月之一了吧。<br>过去的二十多天里经历了很多的事情。接踵而来的来自四面八方的打击，失去了陪伴自己很久的东西……以及其它无法一一列举的让人不愉快的事情。我大概就是那种只有在心情很糟糕的时候才会有想法的人，所以说每次情绪低落的时候，我都会想写点什么东西。有时候把自己的想法通过文字表达出来会让自己好受很多，但是自己的文笔又非常烂，以至于总是有时候心血来潮想到哪里写到哪里的时候突然就不知道往下要怎么动笔了，只好又把自己的那些负情绪咽回去。<\\/p>\n<hr>\n<p><div id=\"muse-container\"><\\/div><\\/p>\n<script type=\"text\\/javascript\">\n    var playlist = [{\n        title: '八月のif',\n        artist: 'Poppin\\'Party',\n        cover: 'https:\\/\\/dn-iidream.qbox.me\\/_20170820_081434.jpg',\n        src: 'https:\\/\\/dn-iidream.qbox.me\\/%E5%85%AB%E6%9C%88%E3%81%AEif-Poppin%20Party.mp3',\n        lyric: '[by:吟梦]\\n[00:20.58](香澄) 陽炎がゆらゆら揺れてる\\n[00:27.06]沈む太陽を見つめながら考えてた\\n[00:36.49](沙綾) 私達もしも出会えてなかったなら\\n[00:42.84]どんな夏が待っていたんだろう\\n[00:50.18](香澄) 違う夏\\n[00:52.43](沙綾) 探してた\\n[00:54.28](香澄) それぞれ\\n[00:56.29](香澄＆沙綾) 夢追いかけた\\n[00:58.53](香澄) でもホントに\\n[01:00.50](沙綾) そうなのかな\\n[01:02.19](香澄) やっぱりね\\n[01:04.20](沙綾) いつかは\\n[01:06.20](香澄＆沙綾) 出会ってたのかな\\n[01:10.66]煌めいた八月のif\\n[01:18.37](香澄) 短い夏の\\n[01:20.90](沙綾) 秘密捜し\\n[01:23.62](香澄＆沙綾) に行こうよ\\n[01:26.36](香澄＆沙綾) 息を止めてそのままでいて\\n[01:34.22](香澄) もしかじゃない\\n[01:35.71](沙綾) 今を\\n[01:37.38](香澄＆沙綾) 抱きしめている',\n        translation: '炎夏的阳光在远处悠悠荡荡地摇曳\\n注视着西下的夕阳 心中无限遐思\\n倘若当初我们没有相遇相识\\n等待着我们的会是怎样的夏天呢\\n想象着\\n这不一样的夏天\\n大家追寻着\\n各自的梦想\\n可是真的会\\n变成那样吗\\n到底还是会\\n在某一天\\n走到一起的吧\\n这熠熠生辉的 八月的遐想\\n来探索\\n这转瞬即逝的夏天的\\n秘密吧\\n就这样下去 屏住呼吸就好\\n放弃那遐想吧\\n把当下\\n紧紧拥入怀中吧'\n    }];\n    var player = MUSE.render(playlist, document.getElementById('muse-container'), {\n        layout: 'muse-layout-landscape'\n    });\n    MUSE.changeState(player.id, 'volume', 0.75);\n\n\n    function is_pc() {\n        var userAgentInfo = navigator.userAgent;\n        var Agents = [\"Android\", \"iPhone\",\n        \"SymbianOS\", \"Windows Phone\",\n        \"iPad\", \"iPod\"];\n        var flag = true;\n        for (var v = 0; v < Agents.length; v++) {\n            if (userAgentInfo.indexOf(Agents[v]) > 0) {\n                flag = false;\n                break;\n            }\n        }\n        return flag;\n    }\n\n    if (is_pc()) {\n        MUSE.togglePlay(player.id);\n    }\n<\\/script>\n\n<p>这是 《BanG Dream! OVA》 里的一首插曲《八月のif》，可以算是目前为止 Poppin’Party 的歌里我最喜欢的一首了，尽管还没有出完整版。<br>抛开作画崩什么的，真心觉得这部动漫 &amp; 企划不错。推 PPP 让我找到了刚开始推缪那一会的那种感觉，这也是我对<s>梦幻少女乐队<\\/s>这个企划评价很高的原因之一。也许有梦想之人的故事是最能打动人的了吧，无论是追逐那一束的光的穗乃果和 μ’s，还是幻想、仰望着星空的香澄和 popipa.<\\/p>\n<p>真正的梦想，应该就是像这样，哪怕是在别人眼中的再不切实际、再难以达成，也要咬紧牙关去尝试实现它的吧。这样的梦想不仅仅是一种单纯的利益驱动型的动力，更多的是一种信仰。<\\/p>\n<p>我？大概也有一个藏了很久的所谓“不切实际”的梦呢。<\\/p>\n<hr>\n<p>初中毕业快要三年，初中班级群总是安安静静的，最长的纪录是半年没人讲一句话，最后打破沉默的是同学的 QQ 号被盗之后群发的诈骗信息。今天，这个沉默了很久的群突然在会话列表里冒了出来。初中的班主任（之前也是从来不怎么说话的）发了一条信息。<\\/p>\n<p>她说，亲爱的同学们，你们已经是高三的学生了，大家要用自己的智慧和勤奋去走进人生的大礼堂。要杀出气魄，杀出豪迈。<br>看到她说的话那会儿我还是被震撼到了。震撼的不只是毕业三年她仍然记得我们，记得她当年带过的班级（当时我们那一届和她的关系确实还不错），我对其中一句话很有感触，宁可是不快乐的少年，也不要委曲求全的成年。<\\/p>\n<p>高三确实很累。有很多漏洞需要去修补，有很多东西需要去巩固，于此同时你还要继续接触和吸收很多新的内容，日复一日，直到第二年的六月，将会是一个很枯燥很无聊的过程。每每想到这将会是个很漫长的过程，就很想放弃。可是从另一个角度想，努力熬过这个漫长、无聊、“不快乐”的过程，总比明年委曲求全来的值得。这可能就是人为什么要把眼光放的远一点的原因吧，如果只图去追求眼前的片刻的安逸，将来真的会后悔和愧疚比这一段时间长不知道多少倍。<\\/p>\n<hr>\n<p>感觉自己度过了一个很奇葩的高中三年，比起班级里其他普通的高中同学来说我算是比较特殊的，因为过去的两年当中一直在“学业”和“竞赛”的两头徘徊。最终竞赛的结果大都不尽人意，倒是给我带来了一些很珍贵和难忘的经历。今年 11 月过后，算是可以抛开除了学业之外的全部的杂念了。也算是一种解脱吧。<br>自己的拖延症和总是把事情做一半就丢下的问题，是时候该改一改了。<br>总是觉得自己的时间不够用，也许是时候对自己的时间有更严格的规划了。<\\/p>\n<p>虽然身边的人都很理解很支持，但是无论周围的人怎样说“高三你不是一个人”，归根结底高三还是自己一个人的战役。无论是挑灯夜读还是最终坐在考场上的那个人都是你自己，不是其他任何一个人。<br>一定要学会适应这种孤独呢。<\\/p>\n<p>我有时候在想，我如果能像我对待和接触前端这么热忱，能像我写博客这么谨慎和一丝不苟去对待我的学习就好了。也许我真的应该这么尝试着做一下。<\\/p>\n<hr>\n<p>从六点半开始对着编辑器，想了很多事情，一直在删删改改，最后才发现把我脑子里那些零碎的感觉和想法拼凑出来也不过是篇连事情都讲不清楚的语无伦次日记。这一刻我有些犹豫要不要删掉这一篇乱七八糟毫无逻辑的日记，但是想了想我还是决定留下它。正如我说的那样，“博客是将我本人性格最真实地体现得最淋漓尽致的地方”。<\\/p>\n<p>好了，那就这样吧，反正没有人看。如果有人忍着各种吐槽耐心地看我说一堆废话读到这儿的话，那么希望你和我能在接下来的日子里努力朝着自己的梦想前行，让这个八月的遐想成为现实吧。<\\/p>\n<p>共勉。<\\/p>\n",
      "excerpt": "<p>炎夏的阳光在远处悠悠荡荡地摇曳<br>注视着西下的夕阳 心中无限遐思<br>倘若当初我们没有相遇相识<br>等待着我们的会是怎样的夏天呢<br>",
      "slug": "hachigatsu-no-if",
      "published": true,
      "layout": "post",
      "path": "blog/post/hachigatsu-no-if/",
      "permalink": "https://kirainmoe.com/blog/post/hachigatsu-no-if/",
      "tags": [
        {
          "name": "diary",
          "slug": "diary",
          "path": "tags/diary/",
          "permalink": "https://kirainmoe.com/tags/diary/",
          "length": 3
        },
        {
          "name": "life",
          "slug": "life",
          "path": "tags/life/",
          "permalink": "https://kirainmoe.com/tags/life/",
          "length": 1
        }
      ],
      "categories": []
    },
    {
      "title": "每周解题报告 (3rd, 8/14~8/20)",
      "date": "2017-08-20T06:43:46.000Z",
      "modified": "2018-01-07T05:18:35.157Z",
      "content": "<p>这周主要是尝试了一些新的东西（ 做了一些之前一直想看但是一直没看懂和没做的题目。依旧是做 HDU 的题。虽然写得不是很熟练，不过慢慢来应该也是可以的。<br>另外下周由于要阶段考试这样子，可能就没有时间做题目了。<\\/p>\n<a id=\"more\"><\\/a>\n<div class=\"muse-app\"><\\/div>\n\n<script type=\"text\\/javascript\">\nvar playList = [{\n    title: 'やくそく',\n    artist: '三森すずこ \\/ 花澤香菜',\n    src: 'https:\\/\\/api.kotori.love\\/netease\\/mp3?id=488256626',\n    cover: 'http:\\/\\/p1.music.126.net\\/9uq04GzHBnhhJCgQTccq_Q==\\/19012755067719433.jpg',\n    lyric: '[by:lyricshare]\\n[00:25.93]さよならじゃない今未来が始まるんだ\\n[00:37.23]淡い蕾は花開いて祝福を歌う\\n[00:48.93]秘密の場所に埋めたのは\\n[00:54.65]密かな夢と宝の地図\\n[01:00.94]時間巡りを閉じ込めた\\n[01:06.41]小さなガラスの欠片だった\\n[01:11.87]あの時 君は君は勇気を得た\\n[01:17.79]友を信じ抜く勇気を得た\\n[01:23.80]永遠に消えない誇りになるだろう\\n[01:29.83]最後の鐘が響き出す\\n[01:35.33]たとえ涙が落ちてしまうとしても\\n[01:41.03]下を向いたりしないと誓おう\\n[01:47.39]そっと重ねた思い出の数だけ\\n[01:53.20]光ゆらめいて背中を押した\\n[02:05.22]流れ続ける砂時計のような時よ\\n[02:16.67]翼広げてさあ飛び立とう地平線の果て\\n[02:28.44]あどけなかった横顔が\\n[02:34.10]凛々しくなったはいつの日か\\n[02:40.03]速まる日々に負けぬよう\\n[02:45.85]毎日夢中で追いかけてた\\n[02:51.57]あの時君は君は希望を見た\\n[02:57.28]暗闇に浮かぶ 希望を見た\\n[03:03.14]行き先照らす明かりになるだろう\\n[03:09.24]もう迷うことはないんだ\\n[03:14.94]いつか傷つくことがあるとしても\\n[03:20.64]友がくれた言葉を胸に\\n[03:27.03]傷を癒して進み続けるよ\\n[03:32.70]きっとその先でまた会えるから\\n[04:01.90]あの時君は君は勇気を得た\\n[04:07.50]友を信じ抜く勇気を得た\\n[04:13.36]永遠に消えない誇りになるだろう\\n[04:19.78]最後の鐘が響き出す\\n[04:24.82]たとえ 涙が落ちてしまうとしても\\n[04:30.82]下を向いたりしないと誓おう\\n[04:37.28]そっと重ねた思い出の数だけ\\n[04:42.95]光ゆらめいて背中を押した\\n[04:54.83]あのね ありがとう またあの場所で',\n    translation: '这并不是永别 未来从现在才开始\\n含苞待放的花蕾盛开 颂唱祝福之歌\\n在秘密场所里埋藏的是\\n潜藏于心的梦想与藏宝图\\n将反复的时间紧闭门中\\n化成了小小的玻璃碎片\\n那时候 是你让我获得了勇气\\n让我获得了坚信朋友的勇气\\n它会成为我永不消逝的骄傲吧\\n终结的钟声响起\\n让我们发誓 即便再流下眼泪\\n也不再低下头\\n只有那默默积累下的记忆\\n在虚渺的光芒中一直支持着我\\n时间仿佛不断流逝的沙漏\\n张开双翼 向着地平线的尽头翱翔吧\\n你那天真烂漫的侧脸\\n不知在何时已变得如此冷酷严峻\\n为了不输给忙碌的生活\\n每日都不顾一切地追赶\\n在那时 是你让我看见了希望\\n让我看见了在黑暗中浮现的希望\\n它会成为我通向终点的照明灯吧\\n我已经不会再次迷失自我了\\n即便在未来某刻会受伤\\n朋友托付于我的咒语 也会在我心中\\n治愈着我的伤痕 让我向前迈进\\n一定会在前方再次相遇吧\\n那时候 是你让我获得了勇气\\n让我获得了坚信朋友的勇气\\n它会成为我永不消逝的骄傲吧\\n终结的钟声响起\\n让我们发誓 即便再流下眼泪\\n也不再低下头\\n只有那默默积累下的记忆\\n在虚渺的光芒中一直支持着我\\n我想对你说 谢谢你 让我们再次在那个地方相遇吧'\n}];\n\nMUSE.render(playList, document.querySelector('.muse-app'));\n<\\/script>\n\n<h1 id=\"8-200-HDU5489-Removed-Interval\"><a href=\"#8-200-HDU5489-Removed-Interval\" class=\"headerlink\" title=\"8\\/200, HDU5489, Removed Interval\"><\\/a>8\\/200, HDU5489, Removed Interval<\\/h1><h2 id=\"题意-amp-扯淡\"><a href=\"#题意-amp-扯淡\" class=\"headerlink\" title=\"题意 &amp; 扯淡\"><\\/a>题意 &amp; 扯淡<\\/h2><p>题意就是已知一个数列，从中删除连续的 n 个数，然后要使得删除完之后它的最长上升子序列最大。n &lt;= 1e5.<\\/p>\n<p>这题好像有很多的解法，有用传统 LIS 做的，还有用 LIS + BIT 或者 LIS + Segment Tree 做的……后面两种做法没能理解（说实话，第一种做法也没怎么能理解），所以我还是硬着头皮看了一下直接做的。<\\/p>\n<h2 id=\"所谓题解\"><a href=\"#所谓题解\" class=\"headerlink\" title=\"所谓题解\"><\\/a>所谓题解<\\/h2><p>因为要从数列中删除一些数之后求 LIS，然后就是我们枚举删除的数的终点，然后对终点右边的第一个数为起点求一次 LIS<br>然后再从最左边到删除的起点求一次 <strong>最大的数不超过终点右边第一个数<\\/strong> 的 LIS<br>从右往左的这个 LIS 必须在枚举起点之前预处理求出，所以：<br>从右往左求 LIS 可以用负数的方法来做，然后倒着求回来，一直从 n 求到 l 为止。<\\/p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"><\\/a>代码<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nusing namespace std;\n\nconst int MAXN = 1e5 + 10;\nconst int INF = 1e9 + 7;\n\nint kases, tmp;\nint n, l;\nint a[MAXN], b[MAXN], dp[MAXN], LIS[MAXN];\n\nint main()\n{\n  scanf(&quot;%d&quot;, &amp;kases);\n\n  while (kases--)\n  {\n    tmp++;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;l);\n\n    fill(dp, dp + MAXN, INF);\n\n    for (int i = 0; i &lt; n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;a[i]);\n      b[i] = -a[i];\n    }\n\n    \\/\\/ reverse LIS\n    int pos = 0;\n    fill(LIS, LIS + MAXN, INF);\n\n    for (int i = l; i &gt;= l; i--)\n    {\n      pos = lower_bound(LIS, LIS + n, b[i]) - LIS;\n      LIS[pos] = b[i];\n      dp[i] = pos + 1;\n    }\n\n    int ans = 0, maxlen = 0;\n    fill(LIS, LIS + MAXN, INF);\n    for (int i = l; i &lt; n; i++)\n    {\n      pos = lower_bound(LIS, LIS + n, a[i]) - LIS;      \\/\\/ from left to right\n      ans = max(ans, pos + 1 + dp[i] - 1);        \\/\\/ &gt;=\n\n      pos = lower_bound(LIS, LIS + n, a[i - l]) - LIS;    \\/\\/ update left LIS\n      LIS[pos] = a[i-l];\n      maxlen = max(maxlen, pos + 1);\n    }\n    ans = max(ans, maxlen);\n    printf(&quot;Case #%d: %d\\n&quot;, tmp, ans);\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"9-200-HDU1074-Doing-Homework\"><a href=\"#9-200-HDU1074-Doing-Homework\" class=\"headerlink\" title=\"9\\/200, HDU1074, Doing Homework\"><\\/a>9\\/200, HDU1074, Doing Homework<\\/h1><h2 id=\"扯淡\"><a href=\"#扯淡\" class=\"headerlink\" title=\"扯淡\"><\\/a>扯淡<\\/h2><p>DP，而且不是一般的 DP……是状压 DP 的说。这种 DP 也不是很好理解也很难想……主要还是要写题积累经验。算是我的第一道状压吧 QAQ，之前一直以为状压 DP 涉及各种二进制和位操作挺可怕的……看理论什么的也一直看不太懂。<\\/p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"><\\/a>题解<\\/h2><p>嘛……这是我有生以来写过的第一道状态压缩 DP 的题……第一眼看到 N &lt;= 15 就有种不好的预感 2333……<\\/p>\n<p>状态压缩嘛，就是把 DP 中用到的状态用二进制来表示，然后就这道题目理解了一下状态压缩 DP 的基本的写法，下面是我稍微总结的一下状态压缩 DP 的框架：<\\/p>\n<pre><code>const MAXN = 最大的状态点数目\nconst MAXS = 1 &lt;&lt; MAXN            \\/\\/ 最多的状态数，表示 2^MAXN 个\nvar dp[MAXS]                \\/\\/ DP 数组\n\nread n\n\nfor (i = 1...(1 &lt;&lt; n))            \\/\\/ 枚举每个用二进制表示的状态\n    for (j = 0....n)            \\/\\/ 枚举每一个点\n        var cur = 1 &lt;&lt; j        \\/\\/ 当前点用二进制表示后的整数\n    if (i &amp; cur)            \\/\\/ 判断当前状态是否合法，即当前枚举的状态 (i) 必须包含当前枚举的点 (cur)\n            var last = i - cur        \\/\\/ 这一步是可选的，如果你要获得当前状态的上一个状态\n                    \\/\\/ 那么可以用当前枚举的状态减去当前枚举的点的二进制状态\n\n            dp equation            \\/\\/ 那么现在就可以开始你的 DP 方程了\n\nprint dp[(1 &lt;&lt; n) - 1]            \\/\\/ 最终答案就是 dp[(1 &lt;&lt; n) - 1] 了\n<\\/code><\\/pre><p>然后说回到这一题上吧。题意就是某人要做好多的作业，每个作业有一个上交期限 deadline 和需要花费的时间 cost。如果每超过一天上交就扣一分，然后让你求出扣分最少的方案并输出字典序最小的方案。<\\/p>\n<p>由于最多只有 15 个状态点，那么用二进制表示这 15 个状态点的话，十进制的数不会超过 2^15 = 32768，所以我们想到用状压 DP 来解。那么，设整数 i 为用二进制表示了当前状态然后转换后的十进制数，然后我们就可以开一个数组 dp[1…MAXS] 来表示对于每个状态扣的分最少是多少，这里我们用二进制来表示状态，即用 0 来表示未完成这个作业，1 表示已完成这个作业。然后我们就可以从低位向高位填充来表示是否坐过这个作业了。<\\/p>\n<p>例如说有 5 门作业，你做了 第一门、第二门和第五门，那么用二进制表示就是 10011，然后转成十进制数就是 19.<\\/p>\n<p>我们用 i 枚举当前状态，然后再枚举一维 j 表示当前枚举的状态点（每一科的作业），当 i 状态包含了当前状态点的时候我们就可以根据我们的 DP 方程对 dp 数组进行更新。具体地，我们可以判断 i &amp; (1 &lt;&lt; j) 是否等于 1 的结果来看，如果等于 1 的话那么 i 状态就完成了第 j 门功课。<\\/p>\n<p>dp 方程如下（不要忘记转移的同时更新时间）：<\\/p>\n<pre><code>dp[i].score = dp[prev].score + max(dp[prev].time + lesson[j].cost - lesson[j].deadline, 0)\n<\\/code><\\/pre><p>我们记 curscore = 在完成第 j 门作业前的上一个状态（可以用 i - (1 &lt;&lt; j) 来求得上一个状态）已经花费掉的时间 + 做当前作业需要花费的时间 - 当前作业的 deadline，那么 curscore 有两种情况：1. 当 curscore &gt; 0 的时候，就是当前决策会被扣掉的分数；2. 当 curscore &lt;= 0 的时候，表明当前决策还不会被扣分，但是提早上交作业也不会加分，所以我们要把它设为 0.<\\/p>\n<p>然后呢看题目要求除了输出最小代价之外还要输出方案，那么我们可以用一个结构体来表示当个状态，除了记录代价 score 和所用时间 times 外还需要记录上一个状态 prev 和当前的科目 subject. 利用最终答案是 dp[(1 &lt;&lt; n) - 1] 这个性质，我们就可以通过 prev 回溯回去输出方案了，具体的做法就是从最终状态往前搜寻，并把它们加入一个栈中。然后你知道怎么做了。<\\/p>\n<p>还有一个要注意的地方就是边界处理，不然会无限 WA。<\\/p>\n<h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"><\\/a>代码<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \n\nusing namespace std;\n\nconst int MAXN = 15;\nconst int MAXS = 1 &lt;&lt; MAXN;\nconst int INF = 1e9 + 7;\n\nstruct Lesson {\n  int deadline;\n  int need;\n  char name[105];\n};\n\nstruct State {\n  int day;\n  int doing;\n  int score;\n  int previous;\n};\n\nLesson les[MAXN];\nState dp[MAXS];\n\nint cases;\nint n, l;\n\nint main()\n{\n  scanf(&quot;%d&quot;, &amp;cases);\n  while (cases--)\n  {\n    memset(dp, 0, sizeof(dp));\n\n    scanf(&quot;%d&quot;, &amp;n);\n\n    for (int i = 0; i &lt; n; i++)\n    {\n      cin &gt;&gt; les[i].name &gt;&gt; les[i].deadline &gt;&gt; les[i].need;\n    }\n\n    int terminal = 1 &lt;&lt; n;\n\n    \\/\\/ state-compressing\n    for (int i = 1; i &lt; terminal; i++)\n    {\n      dp[i].score = INF;\n      for (int j = n - 1; j &gt;= 0; j--)\n      {\n        int current = 1 &lt;&lt; j;\n        if (i &amp; current)\n        {\n          int prev = i - current;     \\/\\/ previous state\n          int score = dp[prev].day + les[j].need - les[j].deadline;\n          if (score &lt; 0)\n            score = 0;\n\n          int newState = score + dp[prev].score;\n          if (newState &lt; dp[i].score)\n          {\n            dp[i].score = newState;\n            dp[i].day = dp[prev].day + les[j].need;\n            dp[i].previous = prev;\n            dp[i].doing = j;\n          }\n        }\n      } \\/\\/ for j = n-1 =&gt; 0\n    } \\/\\/ for i = 1 =&gt; terminal\n\n    printf(&quot;%d\\n&quot;, dp[terminal - 1].score);\n\n    \\/\\/ print solutions\n    stack&lt;int&gt; solutions;\n    int cur = terminal - 1;\n    while (cur != 0)\n    {\n      solutions.push(dp[cur].doing);\n      cur = dp[cur].previous;\n    }\n\n    while (!solutions.empty())\n    {\n      printf(&quot;%s\\n&quot;, les[solutions.top()].name);\n      solutions.pop();\n    }\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"10-100-HDU3192-Hamburger-Magi\"><a href=\"#10-100-HDU3192-Hamburger-Magi\" class=\"headerlink\" title=\"10\\/100, HDU3192, Hamburger Magi\"><\\/a>10\\/100, HDU3192, Hamburger Magi<\\/h1><h2 id=\"题意-amp-扯淡-1\"><a href=\"#题意-amp-扯淡-1\" class=\"headerlink\" title=\"题意 &amp; 扯淡\"><\\/a>题意 &amp; 扯淡<\\/h2><p>第二道状压。具体的题意看题解吧，其实这些解题报告都是我把写完一题的时候 YY 出来的题解拼出来的，所以就不想浪费时间排版什么的了，看得懂找得到就行。<\\/p>\n<h2 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"><\\/a>题解<\\/h2><p>感觉状态压缩的题目写的还是不太多，然后就没有那种感觉……不过经过上一题之后看到这道题就有些靠谱的思路了，虽然因为掉进了上一题的思维定式里然后 WA 了好几回 QAQ……<\\/p>\n<p>这一题的话，题意大概就是要做汉堡包，然后每个汉堡包有自己的价值 v（下文用 val 表示） 和制作所需要的能量 e（用 cost 表示），总共可以消耗的能量为 E. 再然后就是有些种类的汉堡包可能有“依赖”，也即在做他们之前需要有些汉堡包已经做好了。每种汉堡包最多做一个，然后综合上述条件，求出满足题意的最大价值 maxVal. 1 &lt;= n &lt;= 15.<\\/p>\n<p>老规律，看到 n &lt;= 15 就想到状态压缩 DP。这道题和上一题有个比较不一样的地方在于，上一题是根据当前枚举到的状态作为已知，而当前状态的先前一个状态未知，所以是从后向前推的；这道题是把当前枚举到的状态作为已知，当前状态的下一个状态未知，然后要从前向后推。<\\/p>\n<p>我们记 i 为当前汉堡种类的状态，用 j 表示下一个状态相较当前状态多做的汉堡种类，在 DP 之前我们先要判断条件是否合适。由于这题当中有一个“依赖”的概念，又有一个能量的限定，所以我们在判断 DP 状态是否合法的时候要注意一下。由于前一个“依赖”的限定是硬性的，也就是这个限制只能在我们 DP 下一个状态之前先判断当前状态能否推出下一个状态；但是对于“能量”这个限定就显得比较宽松，我们既可以边 DP 边剪枝，把所需能量大于总能量的解答直接剪掉；也可以暂时不剪掉，但是记录它们的花费（尽管有时候该花费已经超过了总能量），然后在 DP 完成之后循环一遍 dp 数组，这个时候就可以很方便地根据 dp[i].cost 来判断状态是否合法了，因为这个值已经固定下来不会改变了，所以我们可以在状态合法的前提下更新答案。网上的题解大致也分这两种写法，我觉得后面一种比较好理解也好写，所以我们用第二种做法。<\\/p>\n<p>至于判断依赖是否满足的话，我们遍历 j 的每一个依赖 deps[j][x]，如果 (i &amp; (1 &lt;&lt; j 的每一个依赖))，说明当前状态合法，可以由当前状态推向下一个状态；反之则不能从当前状态通过做第 j 个汉堡包达到下一个状态。<\\/p>\n<p>DP 方程如下，设 items[j] 为第 j 种汉堡的信息，i 为在 n 个不同的状态点的二进制状态转换成的十进制数，那么：<\\/p>\n<pre><code>dp[i | (1 &lt;&lt; j)].val = dp[i].val + items[j].val, dp[i | (1 &lt;&lt; j)].cost = dp[i].cost + items[j].cost;\n<\\/code><\\/pre><p>这里的 (1 &lt;&lt; j) 表示一个“只做当前枚举的第 j 个汉堡的二进制状态”，i 是当前状态，由于 (1 &lt;&lt; j) 二进制下只有第 j 位是 1 其他都是 0（注意这里 j 的下标是从 0 开始的），所以 i 与 1 &lt;&lt; j 按位或返回的结果就是下一个状态。<\\/p>\n<p>做完 DP 之后循环一遍 dp 数组更新 ans 就可以了： <code>ans = max(ans, dp[i].val), 其中 dp[i].cost &lt;= E.<\\/code><\\/p>\n<h2 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"><\\/a>代码<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt;\nusing namespace std;\n\nconst int MAXN = 15;\nconst int MAXS = 1 &lt;&lt; 15;\nconst int INF = 1e9 + 7;\n\nstruct Hamburger {\n  int val;\n  int cost;\n  int dep;\n  int deps[15];\n};\nHamburger items[MAXN];\n\nstruct State {\n  int val;\n  int cost;\n};\nState dp[MAXS];\n\nint cases;\nint n, e;\n\nint main()\n{\n  scanf(&quot;%d&quot;, &amp;cases);\n\n  while (cases--)\n  {\n    memset(items, 0, sizeof(items));\n    memset(dp, -1, sizeof(dp));\n\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;e);\n    for (int i = 0; i &lt; n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;items[i].val);\n    }\n    for (int i = 0; i &lt; n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;items[i].cost);\n    }\n    for (int i = 0; i &lt; n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;items[i].dep);\n      if (items[i].dep &gt; 0)\n      {\n        for (int j = 0; j &lt; items[i].dep; j++)\n        {\n          scanf(&quot;%d&quot;, &amp;items[i].deps[j]);\n          items[i].deps[j]--;\n        }\n      }\n    } \\/\\/ end read\n\n    int end = 1 &lt;&lt; n;\n    int ans = 0;\n\n    dp[0].cost = 0, dp[0].val = 0;\n\n    for (int i = 0; i &lt; end; i++)\n    {\n      if (dp[i].cost == -1)\n        continue;\n\n      for (int j = 0; j &lt; n; j++)\n      {\n        int cur = 1 &lt;&lt; j;\n        if (!(i &amp; cur))\n        {\n          int next = i | cur;\n\n          bool flag = true;\n          if (items[j].dep &gt; 0)\n          {\n            for (int x = 0; x &lt; items[j].dep; x++)\n            {\n              int depState = 1 &lt;&lt; items[j].deps[x];\n              if (!(i &amp; depState)) {\n                flag = false;\n                break;\n              }\n            } \\/\\/ for x = 0 -&gt; items[j].dep\n          } \\/\\/ if items[j].dep &gt; 0\n\n          if (flag)\n          {\n            dp[next].val = dp[i].val + items[j].val;\n            dp[next].cost = dp[i].cost + items[j].cost;\n          }\n\n        } \\/\\/ if i &amp; cur\n      } \\/\\/ for j = 0 -&gt; n\n    } \\/\\/ for i = 1 -&gt; end\n\n    for (int i = 0; i &lt; end; i++)\n    {\n      if (dp[i].cost &lt;= e)\n        ans = max(ans, dp[i].val);\n    }\n\n    printf(&quot;%d\\n&quot;, ans);\n\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"11-200-HDU1520-Anniversary-Party\"><a href=\"#11-200-HDU1520-Anniversary-Party\" class=\"headerlink\" title=\"11\\/200, HDU1520, Anniversary Party\"><\\/a>11\\/200, HDU1520, Anniversary Party<\\/h1><h2 id=\"题意-amp-扯淡-2\"><a href=\"#题意-amp-扯淡-2\" class=\"headerlink\" title=\"题意 &amp; 扯淡\"><\\/a>题意 &amp; 扯淡<\\/h2><p>树形 DP 入门题，是之前突然想学学树形 DP 的时候找到的。题意大概就是一个宴会上要邀请员工，每个员工都有一个开心指数，只有在宴会上见不到自己的直属上司的时候才会开心，然后要求出开心指数的最大值。<\\/p>\n<h2 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"><\\/a>题解<\\/h2><p>这道题有个很坑的地方就是它一个样例有好多个子任务，但是它什！么！都！没！说！ <\\/p>\n<ul>\n<li>然后我交了 7 遍还是不知道为什么 WA 的……找了个 std 一看，卧槽要处理多组数据……<\\/li>\n<\\/ul>\n<p>设 dp[i][0] 为不邀请第 i 个人的最大值， dp[i][1] 为邀请第 i 个人的最大值。如果我们邀请了第 i 个人，那么我们就不能邀请第 i 个人的直接下属，但是他的直接下属的下属是可以邀请的……然后按照这个思路转移方程就出来了。<\\/p>\n<p>首先要建树，然后这里我采用的是用图的保存方法，直接用了 vector<int>[MAXN] 数组来存第 i 个人的直接下属。首先找到树根，也就是入度为 0 的（没有父亲或者说父亲是本身的）那个节点 Q，然后以此节点为起点做一遍 DFS，边 DFS 边状态转移，之后输出答案就好了。<\\/int><\\/p>\n<p>状态转移方程如下：<\\/p>\n<pre><code>dp[i][0] = max(dp[k1][0], dp[k1][1]) + ... + max(dp[kx][0], dp[kx][1])\n\\/\\/ 其中 k1 ... kx 是第 i 个员工的所有直属下属的下标\n\ndp[i][1] = dp[k1][0] + dp[k2][0] + ... + dp[kx][0]\n\\/\\/ 假如第 i 个员工要出席宴会，这种情况下他的直接下属都不能参加\n<\\/code><\\/pre><p>然后答案就是 <code>ans = max(dp[Q][0], dp[Q][1]);<\\/code>.<\\/p>\n<h2 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"><\\/a>代码<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nusing namespace std;\n\nconst int MAXN = 6010;\nint n;\nint rate[MAXN], p[MAXN];\nint dp[MAXN][2];\nvector&lt;int&gt; T[MAXN];\n\nvoid dfs(int s)\n{\n  if (T[s].size() == 0)\n  {\n    dp[s][1] = rate[s];\n    dp[s][0] = 0;\n    return;\n  }\n\n  for (int i = 0; i &lt; T[s].size(); i++)\n  {\n    int cur = T[s][i];\n    dfs(cur);\n    dp[s][0] += max(dp[cur][1], dp[cur][0]);\n    dp[s][1] += dp[cur][0];\n  }\n  dp[s][1] += rate[s];\n  return;\n}\n\nint main()\n{\n  while (scanf(&quot;%d&quot;, &amp;n) != EOF)\n  {\n    memset(rate, 0, sizeof(rate));\n    memset(p, 0, sizeof(p));\n    memset(dp, 0, sizeof(dp));\n\n    for (int i = 0; i &lt;= MAXN; i++)\n    {\n      T[i].clear();\n    }\n\n    for (int i = 1; i &lt;= n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;rate[i]);\n    }\n\n    int x, y;\n    while (scanf(&quot;%d%d&quot;, &amp;x, &amp;y) != EOF &amp;&amp; x != 0 &amp;&amp; y != 0)\n    {\n      T[y].push_back(x);\n      p[x] = y;\n    }\n\n    int s;\n    for (int i = 1; i &lt;= n; i++)\n    {\n      if (p[i] == 0)\n      {\n        s = i;\n        break;\n      }\n    }\n\n    dfs(s);\n    int ans = max(dp[s][0], dp[s][1]);\n    printf(&quot;%d\\n&quot;, ans);    \n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"12-200-HDU1166-敌兵布阵\"><a href=\"#12-200-HDU1166-敌兵布阵\" class=\"headerlink\" title=\"12\\/200, HDU1166, 敌兵布阵\"><\\/a>12\\/200, HDU1166, 敌兵布阵<\\/h1><p>题意自己看原题吧 Orz 反正是中文的，这题用 BIT 和单点修改的线段树都可以做，是个裸的板子题。记一下这道题的板子代码以防将来需要。<\\/p>\n<h2 id=\"BIT-version\"><a href=\"#BIT-version\" class=\"headerlink\" title=\"BIT version\"><\\/a>BIT version<\\/h2><p>因为只有单点修改，所以用树状数组完全可以胜任。<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt;\n\nconst int MAXN = 50005;\nint n;\nint c[MAXN];\n\nint lowbit(int x)\n{\n  return x &amp; (-x);\n}\n\nvoid add(int i, int value)\n{\n  while (i &lt;= n)\n  {\n    c[i] += value;\n    i += lowbit(i);\n  }\n}\n\nint sum(int x)\n{\n  int res = 0;\n  while (x &gt; 0)\n  {\n    res += c[x];\n    x -= lowbit(x);\n  }\n  return res;\n}\n\nint main()\n{\n  int t;\n  scanf(&quot;%d&quot;, &amp;t);\n\n  for (int i = t; i &gt; 0; i--)\n  {\n    printf(&quot;Case %d:\\n&quot;, t - i + 1);\n    scanf(&quot;%d&quot;, &amp;n);\n    memset(c, 0, sizeof(c));\n\n    for (int j = 1; j &lt;= n; j++)\n    {\n      int x;\n      scanf(&quot;%d&quot;, &amp;x);\n      add(j, x);\n    }\n\n    char str[10];\n    int x, y;\n    while (scanf(&quot;%s&quot;, str) != EOF &amp;&amp; str[0] != &#39;E&#39;)\n    {\n      scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\n      if (str[0] == &#39;Q&#39;) {\n        int res = sum(y) - sum(x-1);\n        printf(&quot;%d\\n&quot;, res);\n      }\n\n      if (str[0] == &#39;A&#39;) {\n        add(x, y);\n      }\n\n      if (str[0] == &#39;S&#39;) {\n        add(x, -y);\n      }\n    }\n\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n<h2 id=\"Segment-Tree-version\"><a href=\"#Segment-Tree-version\" class=\"headerlink\" title=\"Segment Tree version\"><\\/a>Segment Tree version<\\/h2><p>线段树的单点修改区间查询版也可以做这题，如下。写起来会比树状数组的版本麻烦一些。记得一个很重要的地方就是线段树的数组要开到 MAXN 的 4 倍。<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nconst int MAXN = 50010;\n\nint n;\nint kases, tmp;\n\nstruct SegTree\n{\n  int sum[MAXN &lt;&lt; 2];\n\n  void pushUp(int root) \n  {\n    sum[root] = sum[root * 2] + sum[root * 2 + 1];\n  }\n\n  void build(int left, int right, int root)\n  {\n    if (left == right)\n    {\n      scanf(&quot;%d&quot;, &amp;sum[root]);\n      return;\n    }\n    int middle = (left + right) \\/ 2;\n    build(left, middle, root * 2);\n    build(middle + 1, right, root * 2 + 1); \n\n    pushUp(root);\n  }\n\n  void update(int left, int right, int root, int pos, int addVal)\n  {\n    if (left == right)\n    {\n      sum[root] += addVal;\n      return;\n    }\n    int middle = (left + right) \\/ 2;\n\n    if (pos &lt;= middle)\n    {\n      update(left, middle, root * 2, pos, addVal);\n    }\n    else\n    {\n      update(middle + 1, right, root * 2 + 1, pos, addVal);\n    }\n\n    pushUp(root);\n  }\n\n  int query(int from, int to, int left, int right, int root)\n  {\n    if (from &lt;= left &amp;&amp; right &lt;= to)\n    {\n      return sum[root];\n    }\n\n    int middle = (left + right) \\/ 2;\n\n    int res = 0;\n    if (to &lt;= middle)\n    {\n      res += query(from, to, left, middle, root * 2);\n    }\n    else if (from &gt; middle)\n    {\n      res += query(from, to, middle + 1, right, root * 2 + 1);\n    }\n    else\n    {\n      res += query(from, to, left, middle, root * 2) + query(from, to, middle + 1, right, root * 2 + 1);\n    }\n\n    return res;\n  }\n\n  void init()\n  {\n    for (int i = 0; i &lt; MAXN; i++)\n    {\n      sum[i] = 0;\n    }\n  }\n};\n\nSegTree tree;\n\nint main()\n{\n  scanf(&quot;%d&quot;, &amp;kases);\n\n  while (kases--) \n  {\n    tmp++;\n    printf(&quot;Case %d:\\n&quot;, tmp);\n\n    scanf(&quot;%d&quot;, &amp;n);\n\n    tree.init();\n    tree.build(1, n, 1);\n\n    char commands[20];\n    while (scanf(&quot;%s&quot;, commands) != EOF &amp;&amp; commands[0] != &#39;E&#39;)\n    {\n      if (commands[0] == &#39;Q&#39;)\n      {\n        int x, y;\n        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\n        int res = tree.query(x, y, 1, n, 1);\n        printf(&quot;%d\\n&quot;, res);\n      }\n\n      if (commands[0] == &#39;A&#39;)\n      {\n        int x, y;\n        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n        tree.update(1, n, 1, x, y);\n      }\n\n      if (commands[0] == &#39;S&#39;)\n      {\n        int x, y;\n        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n        tree.update(1, n, 1, x, -y);\n      }\n    }\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n",
      "excerpt": "<p>这周主要是尝试了一些新的东西（ 做了一些之前一直想看但是一直没看懂和没做的题目。依旧是做 HDU 的题。虽然写得不是很熟练，不过慢慢来应该也是可以的。<br>另外下周由于要阶段考试这样子，可能就没有时间做题目了。<\\/p>",
      "slug": "practicing-record-3rd-8-14-8-20",
      "published": true,
      "layout": "post",
      "path": "blog/post/practicing-record-3rd-8-14-8-20/",
      "permalink": "https://kirainmoe.com/blog/post/practicing-record-3rd-8-14-8-20/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "algorithm",
          "slug": "algorithm",
          "path": "tags/algorithm/",
          "permalink": "https://kirainmoe.com/tags/algorithm/",
          "length": 8
        }
      ],
      "categories": []
    },
    {
      "title": "每周解题报告 (2nd, 8/7~8/13)",
      "date": "2017-08-13T08:46:17.000Z",
      "modified": "2018-01-07T05:18:34.286Z",
      "content": "<p>这一周主要在看 DP 的题目，嘛，都是一些我觉得很好<s>但是我写不出来的<\\/s>题。本周的话做的都是 HDU 的题，虽然看了一下 Codeforces 上的一两道这样子。感觉收获还是蛮多的。<\\/p>\n<a id=\"more\"><\\/a>\n<h1 id=\"偶然学到的黑科技\"><a href=\"#偶然学到的黑科技\" class=\"headerlink\" title=\"偶然学到的黑科技\"><\\/a>偶然学到的黑科技<\\/h1><p>在开始正式的记题之前，想先记一下这周做题和看题解的时候新学到的东西。<\\/p>\n<h2 id=\"STL-的-unique\"><a href=\"#STL-的-unique\" class=\"headerlink\" title=\"STL 的 unique()\"><\\/a>STL 的 unique()<\\/h2><p>STL 中提供了一个很方便的去重函数 unique(), 其功能是去除相邻的重复元素（只保留一个），所以使用前需要对数组进行排序。用 unique 之后对于有序数组就不用手动循环去重了。<\\/p>\n<h2 id=\"STL-lower-bound-和-upper-bound\"><a href=\"#STL-lower-bound-和-upper-bound\" class=\"headerlink\" title=\"STL lower_bound() 和 upper_bound()\"><\\/a>STL lower_bound() 和 upper_bound()<\\/h2><p>lower_bound(arr, arr + n, val) 返回在有序数组 arr 的 [0, n) 区间中的第一个不小于 val 的值的地址。<\\/p>\n<p>相反的，upper_bound(arr, arr + n, val) 则返回第一个不小于 val 的值的地址。<\\/p>\n<p>所以，我们可以利用这个好东西：<\\/p>\n<h2 id=\"四行写出最长上升子序列-LIS-的-O-nlogn-解法\"><a href=\"#四行写出最长上升子序列-LIS-的-O-nlogn-解法\" class=\"headerlink\" title=\"四行写出最长上升子序列 (LIS) 的 O(nlogn) 解法\"><\\/a>四行写出最长上升子序列 (LIS) 的 O(nlogn) 解法<\\/h2><p>LIS 的话，传统的写法是 O(n^2) 的，用二分优化过后可以降到 O(nlogn). 至于具体的原理我就不想详细在这里记录了，不然文章又要很长。<\\/p>\n<p>设 arr[] 为要求 LIS 的数列，lis[] 为保存 LIS 的数组。那么我们可以通过下面的代码来求 LIS：<\\/p>\n<pre><code class=\"cpp\">fill(lis, lis + n, INF);\nfor (int i = 0; i &lt; n; i++)\n    *lower_bound(lis, lis + n, arr[i]) = arr[i];\nint len = lower_bound(lis, lis + n, INF) - lis;            \\/\\/ LIS 的长度\n<\\/code><\\/pre>\n<p>简单快捷。<\\/p>\n<h1 id=\"4-200-HDU1024-Max-Sum-Plus-Plus\"><a href=\"#4-200-HDU1024-Max-Sum-Plus-Plus\" class=\"headerlink\" title=\"4\\/200, HDU1024, Max Sum Plus Plus\"><\\/a>4\\/200, HDU1024, Max Sum Plus Plus<\\/h1><h2 id=\"题意-amp-扯淡\"><a href=\"#题意-amp-扯淡\" class=\"headerlink\" title=\"题意 &amp; 扯淡\"><\\/a>题意 &amp; 扯淡<\\/h2><p>DP, 最大 m 子段和。没错题目很眼熟，是 P1003 的升级版，原题是最大连续子段和，这题是 n 子段和。是个挺不错的题目，之所以这么说是因为<s>我不会<\\/s>它的时间和空间限制挺严格的，尤其是空间限制是 32M….emmm….<\\/p>\n<p>题意还是给你一个很长的数列 a1….an，然后让你找出它的 m 个子序列使得这些子序列的总和最大，输出这个总和。1 &lt;= n &lt;= 1e6, m 的范围未知。注意就是求出的区间不能相交。<\\/p>\n<p>和上一题比一个比较人道的地方就是这一题不用输出位置了。但是反而比上一题更难了。看到 32M 的内存限制，反正你想到的不是正解的解法表示状态都需要二维，肯定就 GG 了。这道题的正解是用滚动数组优化，非常巧妙，<s>以至于我到现在还不是很理解。<\\/s><\\/p>\n<p>说的不太清楚，如果没明白的可以看看别人写的。直接从 notepad 复制过来的，不想理通顺了，凑合着看吧。<\\/p>\n<h2 id=\"开始正文\"><a href=\"#开始正文\" class=\"headerlink\" title=\"开始正文\"><\\/a>开始正文<\\/h2><p>虽然这道题的数据范围感人，n &lt;= 1e6, m 未知，内存 32M. 基本上告诉我们的信息就是二维的数组都开不下了，那么肯定要做一些黑科技的优化。但是这道题直接看正解是很难理解的，包括我现在看了正解还是有些地方不太明白，下面的解析是我按自己的理解 YY 的，可能有些地方并不一定对。<\\/p>\n<p>在正解之前，我们先来理解不做没优化的情况。如果抛开限制不谈，那么这道题的状态还是很好表示的。用 dp[i][j] 表示当子区间个数为 i，选取第 j 个数的时候的最大值。<\\/p>\n<p>对于 dp[i][j] 的值有两种决策：<\\/p>\n<p>1.将第 j 个数合并到第 i 个区间，区间个数不变，最大和为 dp[i][j-1]+a[j].<br>2.将第 j 个数单独划一个区间，此时区间个数由 i-1 变为 i，最大和为当区间长度为 i-1 的时候能取到的最大值 (也就是 dp[i-1][k]) 加上 a[j].<\\/p>\n<p>我们可以得到这样的状态转移方程：<\\/p>\n<pre><code>dp[i][j] = max(dp[i][j-1] + a[j], dp[i-1][k] + a[j]), 其中 k∈[i-1, j-1]\n<\\/code><\\/pre><p>也即<\\/p>\n<pre><code>dp[i-1][k] = max(dp[i-1][i-1], dp[i-1][i], ....., dp[i-1][j-1]).\n<\\/code><\\/pre><p>意思是，<strong>dp[i][j] 的取值只和 dp[i][j-1] 和 dp[i-1][k] 有关<\\/strong>。由于 i = 1 =&gt; m，那么我们事实上可以将数组降成两个一维的，也就是运用滚动数组来解这道题目：<\\/p>\n<p>设 d[j] 表示第 j 个数一定取的时候的最大值(dp[i][j])，premax[j] 表示 max(dp[i][i], …, dp[i][j])。那么原方程就可以化为 <code>dp[j] = max(dp[j-1] + a[j], premax[j-1] + a[j]);<\\/code><\\/p>\n<p>我们首先枚举区间的数量，用 curmax 表示当区间个数为 i 的时候能取得的最大值是多少，初始值为 -INF。<\\/p>\n<p>接着，我们枚举剩余的所有没有划分区间的数，每次枚举首先计算 dp[j]，然后再将 premax[j-1] 设为 curmax，然后更新 curmax 的值为 max(curmax, dp[j]). curmax 在这里的作用就相当于表示了 max(dp[i-1][i-1], …, dp[i-1][j-1])，我们可以利用滚动数组边 DP 边计算 curmax，然后把 curmax 更新给 premax 来保存. 全部计算完之后最后的结果就是最后一次更新后的 curmax 值了。<\\/p>\n<p>核心的伪代码如下：<\\/p>\n<pre><code>initialize curmax\nfor (i = 1 =&gt; m)\n    let curmax = -infinity\n    for (j = i =&gt; n)\n        calculate dp[j] = max(dp[j-1] + a[j], premax[j-1] + a[j])\n        update    premax[j-1] = curmax\n        update    curmax = max(dp[j], curmax)\nprint curmax\n<\\/code><\\/pre><h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"><\\/a>代码<\\/h2><pre><code class=\"cpp\">\\/**\n* HDU1024 DP 最大连续 m 区间和 \n*\\/\n#include &lt;bits\\/stdc++.h&gt;\nusing namespace std;\n\nconst int MAXN = 1e6 + 10;\nconst int INF = 1e9 + 7;\n\nint n, m;\nint a[MAXN];\nint dp[MAXN];\nint premax[MAXN];\n\nint main()\n{\n  while (scanf(&quot;%d%d&quot;, &amp;m, &amp;n) != EOF)\n  {\n    for (int i = 1; i &lt;= n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;a[i]);\n    }\n\n    for (int i = 0; i &lt;= n; i++)\n    {\n      dp[i] = 0;\n      premax[i] = 0;\n    }\n\n         \\/\\/ start solution\n    int curmax;\n    for (int i = 1; i &lt;= m; i++)\n    {\n      curmax = -INF;\n      for (int j = i; j &lt;= n; j++)\n      {\n        dp[j] = max(dp[j-1] + a[j], premax[j-1] + a[j]);\n        premax[j-1] = curmax;\n        curmax = max(curmax, dp[j]);\n      }\n    }\n\n    printf(&quot;%d\\n&quot;, curmax);\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"5-200-HDU1028-Ignatius-and-the-Princess-III\"><a href=\"#5-200-HDU1028-Ignatius-and-the-Princess-III\" class=\"headerlink\" title=\"5\\/200, HDU1028, Ignatius and the Princess III\"><\\/a>5\\/200, HDU1028, Ignatius and the Princess III<\\/h1><h2 id=\"题意-amp-扯淡-1\"><a href=\"#题意-amp-扯淡-1\" class=\"headerlink\" title=\"题意 &amp; 扯淡\"><\\/a>题意 &amp; 扯淡<\\/h2><p>依旧是 DP，虽然传闻有母函数的做法，但是本蒟蒻不知道也不会写什么母函数。题意大概就是给你一个整数 n，然后你看看这个整数 n 有多少种划分方法，例如说:<\\/p>\n<blockquote>\n<p>4 = 4<br>  = 3 + 1<br>  = 2 + 2<br>  = 2 + 1 + 1<br>  = 1 + 1 + 1 +1<\\/p>\n<\\/blockquote>\n<p>所以 4 有 5 种划分方法。<\\/p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"><\\/a>正文<\\/h2><p>题意就是整数划分嘛，给定一个整数 n，求 n 有多少种分法，然后不能重复。<\\/p>\n<p>一开始都没想到是 DP 题……为什么可以用 DP 呢，一定是因为有重复计算的步骤啦。比如说我们要划分整数 4，把 4 划分到 3+1 的时候，显然 3 还能再往下划分，那么我们就可以直接利用之前已经计算过的结果了。<\\/p>\n<p>网上现成的 DP 题解大概有两种说法，但是状态转移方程是一样的。这个方程挺好写，但是不好想。<\\/p>\n<p>第一种解法是设 dp[i][j] 为将整数 i 划分为<strong>最多 j 个数的和<\\/strong>的时候最多的方案数量。我觉得这种方案不太好理解，尤其是分类讨论的时候。所以以下分析以第二种解法为基础：设 dp[i][j] 为将整数 i 划分为<strong>不超过 j 的数的和<\\/strong>的时候最多的方案数量。<\\/p>\n<p>  1) 显然，当 i = 1 的时候，区间长度只能是 1，那么只有一种方法，也即 dp[1][1] = 1.<\\/p>\n<p>  2) 当 i &lt; j 的时候，由于不可能出现“目标数是 i，但是 j(j &gt; i) 是 i 的一个加数”的情况，所以我们让 dp[i][j] = dp[i][i].<\\/p>\n<p>  3) 当 i = j 的时候，dp[i][j] = dp[i][j-1] + 1<\\/p>\n<p>   (1) 用不超过 j 的整数划分的时候，我们考虑是否要分出 j 这个数，如果要分的话由于 n = m 那么只有一种方案，就是 m 本身（对应状态转移方程中的 1），如果不分，那么就是继承 dp[i][j-1] 的结果，即把 i 分成最大加数不超过 j-1 的多少份。<\\/p>\n<p>  (2) 如果我们用第一种解法来理解这个式子，那么 dp[i][j] = 将 i 分成 j-1 段的方案数最大值 + 将 i 分成 j 段的方案数，由于 i = j，那么将 i 分成 j 段只有一种方案，就是有 j 个 1 的情况。<\\/p>\n<p>  4) 当 i &gt; j 的时候，也是最不好理解的一个部分。这个时候我们可以发现一个包含 i 个数的集合 U={1, 2, 3, …, i} 可以被 j 划分为两部分：一个是 A={j}，一个是 CU(A). 那么这个时候我们可以考虑是否要分出 j 这个数：如果要分出 j，那么我们只要计算剩下来的数的分离方案数，就是 dp[i-j][j]；如果不分，那么答案还是把 i 分成不超过 j-1 的结果，也就是 dp[i][j-1]. 将两种方案相加，我们得到了 dp[i][j] = dp[i-j][j] + dp[i][j-1];<\\/p>\n<p>“这样我们就完美地解决了这个问题。”<\\/p>\n<h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"><\\/a>代码<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt;\nconst int MAXN = 120 + 5;\nint n;\nint dp[MAXN][MAXN];\n\nint main()\n{\n  while (scanf(&quot;%d&quot;, &amp;n) != EOF)\n  {\n    memset(dp, 0, sizeof(dp));\n    for (int i = 1; i &lt;= n; i++)\n    {\n      for (int j = 1; j &lt;= n; j++)\n      {\n        if (i &lt; j)\n        {\n          dp[i][j] = dp[i][i];\n        }\n        if (i == j)\n        {\n          dp[i][j] = dp[i][j-1] + 1;\n        }\n        if (i &gt; j)\n        {\n          dp[i][j] = dp[i][j-1] + dp[i-j][j];\n        }\n      }\n    }\n    printf(&quot;%d\\n&quot;, dp[n][n]);\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"6-200-HDU1025-Constructing-Roads-In-JGShining’s-Kingdom\"><a href=\"#6-200-HDU1025-Constructing-Roads-In-JGShining’s-Kingdom\" class=\"headerlink\" title=\"6\\/200, HDU1025 Constructing Roads In JGShining’s Kingdom\"><\\/a>6\\/200, HDU1025 Constructing Roads In JGShining’s Kingdom<\\/h1><p>还是 DP。懒得翻题意了，自己戳原链接看好了QAQ：<a href=\"http:\\/\\/acm.hdu.edu.cn\\/showproblem.php?pid=1025\" target=\"_blank\" rel=\"external\">http:\\/\\/acm.hdu.edu.cn\\/showproblem.php?pid=1025<\\/a><\\/p>\n<p>也就是在上文提到的最长上升子序列了，但是这一题的话用 O(n^2) 的解法是会 T 的。有两组数嘛，首先对一组排序（当然要保持和另外一组的对应关系），然后对另一组数做 LIS 就可以了。为什么是 LIS 自己画个图就知道了。<\\/p>\n<p>甚至可以，不用排序：在输入的时候只保存一组数据，而把另一组数作为数组的 key 即可，因为两组数是一一对应的，没有一对多的情况。<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt;\nusing namespace std;\n\nconst int MAXN = 5 * 1e5 + 10;\nconst int INF = 1e9 + 10;\n\nint n;\nint ans = 0, kases = 0;\nint maps[MAXN];\nint dp[MAXN];\nint LIS[MAXN];\nint main()\n{\n  while (scanf(&quot;%d&quot;, &amp;n) == 1)\n  {\n    kases++;\n\n    \\/\\/ read data\n    for (int i = 1; i &lt;= n; i++)\n    {\n      int x, y;\n      scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n      maps[x] = y;\n    }\n\n    \\/\\/ initialize\n    for (int i = 0; i &lt;= n; i++)\n    {\n      dp[i] = 0;\n      LIS[i] = INF;\n    }\n    dp[0] = 0;\n\n    \\/\\/ LIS\n    for (int i = 1; i &lt;= n; i++)\n    {\n      *lower_bound(LIS + 1, LIS + 1 + n, maps[i]) = maps[i];\n    }\n    ans = lower_bound(LIS + 1, LIS + 1 + n, INF) - LIS - 1;\n\n    printf(&quot;Case %d:\\n&quot;, kases);\n    printf(&quot;My king, at most %d &quot;, ans);\n    if (ans == 1)\n    {\n      printf(&quot;road can be built.\\n&quot;);\n    }\n    else\n    {\n      printf(&quot;roads can be built.\\n&quot;);\n    }\n    printf(&quot;\\n&quot;);\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n<p>以下是自己写的时候顺手 YY 的注释:<\\/p>\n<blockquote>\n<p>\\/**<\\/p>\n<ul>\n<li>附 nlogn 版的 LIS 写法：<\\/li>\n<li>设 LIS[MAXN] 为此数列的取得 LIS 最大值时的 LIS 一种可能的情况；<\\/li>\n<li>首先把 LIS 数组设为 INF：fill(LIS + 1， LIS + 1 + n, INF) ;<\\/li>\n<li>然后遍历数列，利用 lower_bound 函数二分查找到 LIS 中第一个不大于 a[i] 的值的位置 pos，<\\/li>\n<li>然后把 LIS[pos] 设为 a[i]. 也即 *lower_bound(LIS + 1, LIS + 1 , n, a[i]) = a[i];<\\/li>\n<li>最后统计 LIS 中不是 INF 的值的个数就可以了，即 ans = lower_bound(LIS + 1, LIS + 1 + n, INF);<br>*\\/<\\/li>\n<\\/ul>\n<\\/blockquote>\n<h1 id=\"6-1-HDU1029-Ignatius-and-the-Princess-IV\"><a href=\"#6-1-HDU1029-Ignatius-and-the-Princess-IV\" class=\"headerlink\" title=\"6.1, HDU1029, Ignatius and the Princess IV\"><\\/a>6.1, HDU1029, Ignatius and the Princess IV<\\/h1><p>之所以是 6.1 是因为这题实在是太。水。了。不是一般的水。要不是某个题目分类的帖子里说这题是 DP，我才不会做呢（<\\/p>\n<pre><code class=\"cpp\">\\/**\n* HDU1029 水题，谁说是 DP 的给我出来我保证打不死你 \n* 明明是这么简单的计数题！！ \n*\\/\n#include &lt;bits\\/stdc++.h&gt; \nconst int MAXN = 1e6 + 5;\nint data[MAXN];\nint main()\n{\n  int n, flag;\n  while (scanf(&quot;%d&quot;, &amp;n) != EOF)\n  {\n    bool state = true;\n    flag = (n + 1) \\/ 2;\n\n    memset(data, 0, sizeof(data));\n\n    for (int i = 0; i &lt; n; i++)\n    {\n      int x;\n      scanf(&quot;%d&quot;, &amp;x);\n      data[x]++;\n      if (data[x] &gt;= flag &amp;&amp; state)\n      {\n        printf(&quot;%d\\n&quot;, x);\n        state = false;\n      }\n    }\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"6-5-200-HDU1232-畅通工程\"><a href=\"#6-5-200-HDU1232-畅通工程\" class=\"headerlink\" title=\"6.5\\/200, HDU1232, 畅通工程\"><\\/a>6.5\\/200, HDU1232, 畅通工程<\\/h1><p>畅通工程系列的第一题，这是一道裸的并查集 OvO. 只要理解并查集的都会写啦。题目有个“温馨提示”，但是并不影响我们做题，管他什么多条道路连接的输入合不合法呢。<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \n\nconst int MAXN = 1e3 + 10;\nint p[MAXN];\nint n, m;\nint cnt = 0;\n\nvoid init()\n{\n  cnt = 0;\n  for (int i = 0; i &lt; MAXN; i++)\n  {\n    p[i] = i;\n  }\n}\n\nint find(int x)\n{\n  return x == p[x] ? x : p[x] = find(p[x]);\n}\n\nvoid unions(int x, int y)\n{\n  int px = find(x),\n      py = find(y);\n  if (px == py)\n  {\n    return;\n  }\n  else\n  {\n    p[px] = py;\n    cnt++;\n  }\n}\n\nint main()\n{\n  while (scanf(&quot;%d&quot;, &amp;n) != EOF &amp;&amp; n != 0)\n  {\n    init(); \n    scanf(&quot;%d&quot;, &amp;m);\n    for (int i = 0; i &lt; m; i++)\n    {\n      int x, y;\n      scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n      unions(x, y);\n    }\n    printf(&quot;%d\\n&quot;, (n - 1 - cnt));\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<p>剩下的是一些旧题重做的，然后就不贴上来了。<\\/p>\n",
      "excerpt": "<p>这一周主要在看 DP 的题目，嘛，都是一些我觉得很好<s>但是我写不出来的<\\/s>题。本周的话做的都是 HDU 的题，虽然看了一下 Codeforces 上的一两道这样子。感觉收获还是蛮多的。<\\/p>",
      "slug": "practicing-record-2nd-8-7-8-13",
      "published": true,
      "layout": "post",
      "path": "blog/post/practicing-record-2nd-8-7-8-13/",
      "permalink": "https://kirainmoe.com/blog/post/practicing-record-2nd-8-7-8-13/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "algorithm",
          "slug": "algorithm",
          "path": "tags/algorithm/",
          "permalink": "https://kirainmoe.com/tags/algorithm/",
          "length": 8
        }
      ],
      "categories": []
    },
    {
      "title": "每周解题报告 (1st, 8/3~8/6)",
      "date": "2017-08-07T04:49:06.000Z",
      "modified": "2018-01-07T05:18:33.532Z",
      "content": "<p>RT. 接下来打算在 11 月份之前刷个 200 题的算法题（包括线上和线下）……然后想着就是开个帖子来整理和记录题解什么的，大概能碰到电脑的话那就每周一篇这样子。<\\/p>\n<p>这一阶段的话主要是挑 <a href=\"http:\\/\\/acm.hdu.edu.cn\\/\" target=\"_blank\" rel=\"external\">HDUOJ<\\/a> 的题目来做（因为可以找到详细的题目分类），会从简单的题目开始（<s>比如 A+B Problem<\\/s>），然后辅以一些 Codeforces 的题。之前那个 LeetCode 的记录帖就这么弃坑了（<\\/p>\n<a id=\"more\"><\\/a>\n<h1 id=\"1-200-HDU1003-Max-Sum\"><a href=\"#1-200-HDU1003-Max-Sum\" class=\"headerlink\" title=\"1\\/200, HDU1003, Max Sum\"><\\/a>1\\/200, HDU1003, Max Sum<\\/h1><p>题意大概是给一个很长的数列，有正有负，然后要求这个数列的子序列的和的最大值。然后范围大概是 1e5 以内。有个比较迷的地方就是不仅要求最大值，而且还要求出取得最大值的时候，子区间的位置。时间 1s, 内存 64M.<\\/p>\n<p>第一反应是不是区间 DP 的题啊，然后看了一下数据范围果断把这个白痴的想法扔回肚子里去了。子序列最大值倒是会求啊，但是一开始没有反应过来要怎么统计位置。后来想了一下，开不下二维数组那我开一维的总可以了吧。所以这就是一道最大连续子区间和的动态规划问题了。<\\/p>\n<p>设 <code>dp[i]<\\/code> 表示以 <code>a[i]<\\/code> 为区间终点时能取到的和的最大值，然后开两个辅助数组 <code>left[i]<\\/code> 和 <code>right[i]<\\/code> 来表示当取到这个最大值的时候的区间左界和右界分别在哪里，然后最后 for 一遍统计最大值就做完了。需要注意这里一个地方就是数据可正可负，那么考虑一种情况就是假设 <code>dp[i-1]<\\/code> 小于 0 的时候，那么无论 <code>a[i]<\\/code> 是正数还是负数，显然只取 <code>a[i]<\\/code> 的结果会比取 <code>d[i-1] + a[i]<\\/code> 的结果更优，所以遇到这种情况就要重置一下区间的左右界。<\\/p>\n<p>还有一个要注意的地方就是输出的格式，当时做的时候各种 PE……<\\/p>\n<p>转移方程为 <code>dp[i] = max(dp[i-1] + a[i], a[i])<\\/code>.<\\/p>\n<p>Code:<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nconst int INF = 1e9 + 7;\nconst int MAXN = 1e5 + 10;\n\nint n, sn;\nint a[MAXN];\nint dp[MAXN];\nint left[MAXN], right[MAXN];\n\nvoid init()\n{\n  for (int i = 0; i &lt; MAXN; i++)\n  {\n    dp[i] = -INF;\n    left[i] = 0;\n    right[i] = 0;\n  }\n}\n\nint main()\n{\n  scanf(&quot;%d&quot;, &amp;n);\n  sn = n;\n\n  int tmp = 1;\n  while (sn--)\n  {\n    printf(&quot;Case %d:\\n&quot;, tmp++);\n    init();\n\n    int num;\n    scanf(&quot;%d&quot;, &amp;num);\n    for (int i = 0; i &lt; num; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;a[i]);\n    }\n\n    dp[0] = a[0], left[0] = 0, right[0] = 0;\n    for (int i = 1; i &lt;= num; i++) \n    {\n      \\/\\/ 遇到负数的时候重新计数 \n      if (dp[i-1] &lt; 0)\n      {\n        left[i] = right[i] = i;\n        dp[i] = a[i];\n        continue;\n      }\n\n      dp[i] = dp[i-1] + a[i];\n      left[i] = left[i-1];\n      right[i] = i;\n    }\n\n    int maximum = -INF;   \\/\\/ 维护最大值\n    int l, r;\n    for (int i = 0; i &lt; num; i++) \n    {\n      if (dp[i] &gt; maximum)\n      {\n        maximum = dp[i];\n        l = left[i], r = right[i];\n      }\n    }\n\n    printf(&quot;%d %d %d\\n&quot;, maximum, l+1, r+1);\n\n    if (tmp-1 != n)\n      printf(&quot;\\n&quot;);\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"2-200-HDU1004-Let-the-Balloon-Raise\"><a href=\"#2-200-HDU1004-Let-the-Balloon-Raise\" class=\"headerlink\" title=\"2\\/200, HDU1004, Let the Balloon Raise\"><\\/a>2\\/200, HDU1004, Let the Balloon Raise<\\/h1><p>题意就是已知有 n 个气球和它们的颜色，然后要问最受欢迎的气球（也就是出现次数最多的颜色种类）是哪个，颜色用字符串表示且长度不超过 15，有多个子任务，且对于每个子任务保证只有一个合法答案。<\\/p>\n<p>嘛，简单的字符串计数嘛。这个用什么方法达到都可以的，你开心就好了。在这里我是用一个奇怪的做法，首先用 STL 的 string 保存每个气球的颜色，然后再按字典序用 <code>sort()<\\/code> 排序一下，最后就可以很方便地统计出出现次数最多的那种气球来了。<\\/p>\n<p>Code:<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nusing namespace std;\nconst int MAXN = 1010;\nstring balloons[MAXN];\nint main()\n{\n  int num;\n  int maximum, tmp, handle;\n\n  while (scanf(&quot;%d&quot;, &amp;num) != EOF &amp;&amp; num != 0)\n  { \n    for (int i = 0; i &lt; num; i++)\n    {\n      cin &gt;&gt; balloons[i];\n    }\n    sort(balloons, balloons + num);\n\n    maximum = 0, tmp = 0, handle = 0;\n    for (int i = 1; i &lt; num; i++)\n    {\n      if (balloons[i] != balloons[i-1])\n      {\n        tmp = 1;\n      }\n      else\n      {\n        tmp++;\n      }\n\n      if (tmp &gt; maximum)\n      {\n        maximum = tmp;\n        handle = i;\n      }\n    }\n    cout &lt;&lt; balloons[handle]  &lt;&lt; endl;\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"3-200-HDU1005-Number-Sequence\"><a href=\"#3-200-HDU1005-Number-Sequence\" class=\"headerlink\" title=\"3\\/200, HDU1005, Number Sequence\"><\\/a>3\\/200, HDU1005, Number Sequence<\\/h1><p>题意是对于一个函数 f(n), 满足 f(1) = 1, f(2) = 1, f(n) = (A <em> f(n-1) + B <\\/em> f(n-2)) % 7, 然后求对于给定的 A, B 和 N, f(N) 的值是多少。1 &lt;= n &lt;= 1e8, 有多个子任务。<\\/p>\n<p>看数据范围我想没人敢一个一个算过去吧……而且还有好多个子任务，直接就 T 了。<\\/p>\n<p>这题的话一看我就猜到是递推……手推了 7 个之后发现好像没有什么规律……开始怀疑人生.jpg 后来才知道，因为结果要模 7，那么对于 f(n-1) 有 7 种可能的值 (0-6)，对于 f(n-2) 也是有 7 种可能的值，那么 f(n-1) 和 f(n-2) 一共有 7^2=49 种不同的组合可能，也就是最多 49 次就会出现一个循环节……找到循环节，接下来就可以直接算 f(N) 了，然后就做完了。<\\/p>\n<p>做的时候不知道为啥各种 RE，把计算输出的那部分改了一下就 AC 了。<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nint arr[55];\nint main()\n{\n  arr[0] = 1, arr[1] = 1;\n\n  int a, b, n;\n  int pot = 0;\n  while (scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;n) != EOF &amp;&amp; n != 0)\n  {\n    int pot;\n    for (int i = 2; i &lt;= 54; i++)\n    {\n      arr[i] = (a * arr[i-1] + b * arr[i-2]) % 7;\n      if (arr[i] == 1 &amp;&amp; arr[i-1] == 1)\n      {\n        pot = i;\n        break;\n      }\n    }\n\n    n = n % (pot-1);\n\n    if (n == 0)\n    {\n      printf(&quot;%d\\n&quot;, arr[pot-2]);\n    }\n    else\n    {\n      printf(&quot;%d\\n&quot;, arr[n-1]);\n    }\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n",
      "excerpt": "<p>RT. 接下来打算在 11 月份之前刷个 200 题的算法题（包括线上和线下）……然后想着就是开个帖子来整理和记录题解什么的，大概能碰到电脑的话那就每周一篇这样子。<\\/p>\n<p>这一阶段的话主要是挑 <a href=\"http:\\/\\/acm.hdu.edu.cn\\/\">HDUOJ<\\/a> 的题目来做（因为可以找到详细的题目分类），会从简单的题目开始（<s>比如 A+B Problem<\\/s>），然后辅以一些 Codeforces 的题。之前那个 LeetCode 的记录帖就这么弃坑了（<\\/p>",
      "slug": "practicing-record-1st-8-3-8-6",
      "published": true,
      "layout": "post",
      "path": "blog/post/practicing-record-1st-8-3-8-6/",
      "permalink": "https://kirainmoe.com/blog/post/practicing-record-1st-8-3-8-6/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "algorithm",
          "slug": "algorithm",
          "path": "tags/algorithm/",
          "permalink": "https://kirainmoe.com/tags/algorithm/",
          "length": 8
        }
      ],
      "categories": []
    },
    {
      "title": "一次搭建内部 Online Judge 及调优的笔记",
      "date": "2017-08-05T13:05:18.000Z",
      "modified": "2018-01-07T05:18:32.715Z",
      "content": "<p>嗯，就是搭 OJ 这破事把我拽进了 Python 和 docker 的大坑中……<br>为了给本校 OI 学员的交流和练(gao)习(shi)提供条件，便有了搭建 OJ 的这么一个想法。以前一直以为这种事情就和装个 WordPress 什么的差不多嘛，真正跳进去才发现，woc 这水居然这么深。<br>关于 OJ 的选择，这里我用的是青岛大学 (QingdaoU) 的开源项目 <a href=\"https:\\/\\/github.com\\/QingdaoU\\/OnlineJudge\" target=\"_blank\" rel=\"external\">qduoj<\\/a>。<\\/p>\n<a id=\"more\"><\\/a>\n<p>之所以选 qduoj 呢是因为<s>好看<\\/s>这个 OJ 的架构比较让人满意，网页端采用了 Python Django，判题端的沙箱做得还可以，然后整个项目跑在 docker 中，可以最大限度地减少对宿主机留下的后遗症，以及在判题方面有更高的安全保障。<\\/p>\n<p>我是在一台 Xeon E3 的 ThinkServer 上部署的 Online Judge，操作系统是 Arch Linux, 运行截至写本文之日最新版的 docker. 这个环境可以供各位参考一下，<s>毕竟 Arch Linux 大法好<\\/s>.<\\/p>\n<h1 id=\"Installation\"><a href=\"#Installation\" class=\"headerlink\" title=\"Installation\"><\\/a>Installation<\\/h1><p>部署之前，先按照项目 README 中的一步一步走就是了。项目需要 docker 和 docker-compose，由于我用的是 Arch，所以通过下面的命令安装依赖：<\\/p>\n<pre><code class=\"shell\"># pacman -S git python-pip docker docker-compose\n<\\/code><\\/pre>\n<p>安装完之后我们启动 docker 服务：<\\/p>\n<pre><code class=\"shell\"># systemctl start docker\n<\\/code><\\/pre>\n<p>然后就是把项目克隆到本地，这一步就不多说了，然后接下来是关键的一步，同时也是这个项目的第一个坑：<\\/p>\n<p>首先我们来看看原文 (README) 中是怎么说的：<\\/p>\n<blockquote>\n<p>启动服务：运行 docker-compose up -d ，不需要其他的步骤，大约一分钟之后 web 界面就可以访问了，默认开放80和443端口。其中443端口是自签名证书。<\\/p>\n<p>这就结束了：超级管理员用户名是root，默认密码是password@root，请及时修改。登录\\/admin，添加一个判题服务器，地址为judger，端口为8080，密码是上面自定义的rpc_token。修改custom_settings.py可以自定义站点信息。<\\/p>\n<\\/blockquote>\n<p>天真的我照做了，然后一切正常，打开浏览器访问 <a href=\"http:\\/\\/localhost\\/\" target=\"_blank\" rel=\"external\">http:\\/\\/localhost\\/<\\/a> ，然后喜闻乐见地 connection reset 了。对于一个对 docker 和 python 一窍不通的萌新来说，没有什么比用当场懵逼形容更合适不过的了……<\\/p>\n<p>于是翻 issues, 查找 docker 的玩法，调出了 oj_web_server 这个容器的 log，从 log 中发现找不到 WEBSITE_INFO 的 attribute，WEBSITE_INFO 在 custom_settings.py 当中有定义，初步推断应该是容器内的 django 读不到放在容器外的 custom_settings.py.<\\/p>\n<p>然后打开 docker-compose.yml 一看，似乎没什么不对啊。于是乎在群内求助，经由<a href=\"https:\\/\\/boot.pw\\/\" target=\"_blank\" rel=\"external\">田师傅<\\/a>的指导，将 docker-compose.yml 中的 <code>$PWD<\\/code> 变量统统改成 <code>.\\/<\\/code> 之后，重新 <code>docker-compose up -d<\\/code>，终于在浏览器中看到了这个 OJ 的真容。大概可能也许是原项目对 <code>$PWD<\\/code> 的环境变量使用有问题吧 OvO……或者是不同发行版不兼容……或者是我少配置了什么……谁知道呢。<\\/p>\n<h1 id=\"一些优化\"><a href=\"#一些优化\" class=\"headerlink\" title=\"一些优化\"><\\/a>一些优化<\\/h1><p>搭好了之后，就是魔改它的时间了……想了想，这是个基于 docker 的项目诶，想要魔改似乎很麻烦的说。<\\/p>\n<p>鉴于每次在容器中修改之后再 commit 的方法十分麻烦，这里我直接把容器里的代码部分复制出来，然后再用 docker 的数据卷机制从宿主机映射回去，这样就可以很方便地修改了，同时容器中也会实时更新：<\\/p>\n<pre><code class=\"shell\"># docker cp oj_web_server:\\/code \\/home\\/username\\/code\n<\\/code><\\/pre>\n<p>然后再修改 docker-compose.yml，按照其中的其它映射数据卷的配置的格式抄一遍，把复制出来的目录映射回去镜像里就可以了。<\\/p>\n<h1 id=\"填坑\"><a href=\"#填坑\" class=\"headerlink\" title=\"填坑\"><\\/a>填坑<\\/h1><p>生产过程中还是在不停地踩坑……大部分是在判题的部分踩的。<\\/p>\n<h3 id=\"添加题目的时候标题等字段必须有英文，且不能出现公式字符\"><a href=\"#添加题目的时候标题等字段必须有英文，且不能出现公式字符\" class=\"headerlink\" title=\"添加题目的时候标题等字段必须有英文，且不能出现公式字符\"><\\/a>添加题目的时候标题等字段必须有英文，且不能出现公式字符<\\/h3><p>这个只能说似乎防 XSS 的机制做得好像太严格了，稍微修改一下问题的表达，问题不大。<\\/p>\n<h3 id=\"编译失败，Compile-Error，后面是一大串-JSON\"><a href=\"#编译失败，Compile-Error，后面是一大串-JSON\" class=\"headerlink\" title=\"编译失败，Compile Error，后面是一大串 JSON\"><\\/a>编译失败，Compile Error，后面是一大串 JSON<\\/h3><p>大概像这样的：<\\/p>\n<pre><code class=\"json\">Compile error: Compile error, info: {&#39;cpu_time&#39;: 1203, &#39;exit_status&#39;: 0, &#39;signal&#39;: 0, &#39;flag&#39;: 3, &#39;memory&#39;: 164458496, &#39;real_time&#39;: 1263}\n<\\/code><\\/pre>\n<p>当我看到标程 CE 的时候，又是一脸懵逼状。<\\/p>\n<p>参考这个 issue: <a href=\"https:\\/\\/github.com\\/QingdaoU\\/OnlineJudge\\/issues\\/40\" target=\"_blank\" rel=\"external\">https:\\/\\/github.com\\/QingdaoU\\/OnlineJudge\\/issues\\/40<\\/a> ，原来是评测机里限制了编译时候的资源，包括 CPU 时间和内存什么的。但是可能是评测机的性能太差了，即使原作者放宽了限制依旧存在这个问题。那么只能再人为地放宽这个限制了。<\\/p>\n<p>用你喜欢的办法修改 judger 容器中的 language.py，把其中的 compile_max_cpu_time 和 compile_max_memory 稍微调大一点就好了。<\\/p>\n<h3 id=\"Compiler-Bomb\"><a href=\"#Compiler-Bomb\" class=\"headerlink\" title=\"Compiler Bomb\"><\\/a>Compiler Bomb<\\/h3><p>如果你闲着无聊的话，试试下面这件事：在一个 .c 文件中写入这段代码: <code>main[-1u]={1};<\\/code>，然后用 gcc 编译。仅对 C 语言有效，C++ 无效。<\\/p>\n<p><s>这可是你自己要作死的。<\\/s><\\/p>\n<blockquote>\n<p>编译这段代码之后，会生成16GB的文件。<\\/p>\n<\\/blockquote>\n<p>关于编译器炸弹的原理，请看这里：<a href=\"http:\\/\\/link.zhihu.com\\/?target=https%3A\\/\\/wikicoding.org\\/wiki\\/c\\/Compiler_Bomb\\/%3Futm_content%3Dbuffer7c944%26utm_medium%3Dsocial%26utm_source%3Dfacebook.com%26utm_campaign%3Dbuffer\" target=\"_blank\" rel=\"external\">http:\\/\\/link.zhihu.com\\/?target=https%3A\\/\\/wikicoding.org\\/wiki\\/c\\/Compiler_Bomb\\/%3Futm_content%3Dbuffer7c944%26utm_medium%3Dsocial%26utm_source%3Dfacebook.com%26utm_campaign%3Dbuffer<\\/a><\\/p>\n<p>网上有一篇文章说限制编译出的可执行文件的大小，然而我并没有在 gcc 的编译选项中看到任何可以限制大小的参数……<\\/p>\n<p>不过既然这个东西会生成 16GB 的文件，那么写入的话肯定需要时间对吧，既然如此我们还是可以通过限制编译所用的最大时间来防范这种攻击，超时的话直接干掉编译器返回 CE. 鉴于我并不知道判题端容器中的 gcc 似乎没有受到上文说的 compile_max_cpu_time 的限制的原因，我们直接从编译命令上下手，修改 language.py 中的 compile_command：<\\/p>\n<pre><code>&quot;compile_command&quot;: &quot;\\/usr\\/bin\\/gcc -DONLINE_JUDGE -O2 -w -fmax-errors=3 -std=c99 {src_path} -lm -o {exe_path}\\/main&quot;\n<\\/code><\\/pre><p>改成：<\\/p>\n<pre><code>&quot;compile_command&quot;: &quot;timeout 3s \\/usr\\/bin\\/gcc -DONLINE_JUDGE -O2 -w -fmax-errors=3 -std=c99 {src_path} -lm -o {exe_path}\\/main&quot;\n<\\/code><\\/pre><p>这样子给编译设置一个最长 3s 的限制（当然，根据机器性能的不同，你可以设置短一点或者长一点），超过了就直接 kill 掉 gcc.<\\/p>\n<p>（大概还有很多坑没有踩，接下来再慢慢补充吧……）<\\/p>\n",
      "excerpt": "<p>嗯，就是搭 OJ 这破事把我拽进了 Python 和 docker 的大坑中……<br>为了给本校 OI 学员的交流和练(gao)习(shi)提供条件，便有了搭建 OJ 的这么一个想法。以前一直以为这种事情就和装个 WordPress 什么的差不多嘛，真正跳进去才发现，woc 这水居然这么深。<br>关于 OJ 的选择，这里我用的是青岛大学 (QingdaoU) 的开源项目 <a href=\"https:\\/\\/github.com\\/QingdaoU\\/OnlineJudge\">qduoj<\\/a>。<\\/p>",
      "slug": "notes-of-building-an-online-judge",
      "published": true,
      "layout": "post",
      "path": "blog/post/notes-of-building-an-online-judge/",
      "permalink": "https://kirainmoe.com/blog/post/notes-of-building-an-online-judge/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "online judge",
          "slug": "online-judge",
          "path": "tags/online-judge/",
          "permalink": "https://kirainmoe.com/tags/online-judge/",
          "length": 1
        },
        {
          "name": "python",
          "slug": "python",
          "path": "tags/python/",
          "permalink": "https://kirainmoe.com/tags/python/",
          "length": 1
        },
        {
          "name": "docker",
          "slug": "docker",
          "path": "tags/docker/",
          "permalink": "https://kirainmoe.com/tags/docker/",
          "length": 1
        }
      ],
      "categories": []
    },
    {
      "title": "奇怪的道路 (FCS2017 D2T1)",
      "date": "2017-07-19T12:12:30.000Z",
      "modified": "2018-01-07T05:18:39.209Z",
      "content": "<p>emmm… FCS2017 夏令营的一道题目……用的是分治的算法，为了题目的一些细节本蒟蒻足足推了两个小时QAQ……所以要写篇文章记录一下不然哪天自己就看不明白了……<\\/p>\n<p>由于我比较啰嗦，以及我太弱了导致文章有可能有一些部分讲错了，所以，大家将就着看一下吧（虽然我不相信有人看）。<\\/p>\n<a id=\"more\"><\\/a>\n<h1 id=\"奇怪的道路\"><a href=\"#奇怪的道路\" class=\"headerlink\" title=\"奇怪的道路\"><\\/a>奇怪的道路<\\/h1><h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"><\\/a>问题描述<\\/h2><p>从前，有一座网格城市，城市中每个房子占据一个正方形小格子的中<br>心，每个正方形小格子的边长均为1。<\\/p>\n<p><img src=\"https:\\/\\/i.loli.net\\/2017\\/07\\/19\\/596f4bfc53442.png\" alt=\"road\"><\\/p>\n<p>这座城市道路的设计方式是这样的，首先，定义(𝑎)图为一个基本图形，其阶为1，之后，将(𝑎)图中每一个房子都用一个基本图形代替，得到(𝑏)图，那么(𝑏)图的阶即为2，再将(𝑏)图中的每一个房子都用基本图形替代，得到阶为3的(c)图，以此类推，只要知道这座城市的阶𝑛，就可以知道它的道路设计。<\\/p>\n<p>这种七拐八弯的道路设计使得这座城市之间的道路交通运输相当不便，于是该市的市长决定改造一下这座城市的道路，但在此之前他需要做一系列的评估，比如这座网格城市中，连接第𝑖1行第𝑗1列的房屋与第𝑖2行第𝑗2列的房屋之间（两座房屋可能相同）的道路有多长，由于这种道路设计太过奇怪，人力难以计算，于是这个任务就交给作为软件工程师的你了。<\\/p>\n<h2 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"><\\/a>输入格式<\\/h2><p>每个测试点第一行有两个正整数𝑛, 𝑇，表示城市的阶数和询问数。<br>接下来𝑇行，每行4个正整数𝑖1 𝑗1 𝑖2 𝑗2，表示要查询的两个房屋的坐标。<\\/p>\n<h2 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"><\\/a>输出格式<\\/h2><p>对每个询问输出一行相应的值表示答案。<\\/p>\n<h2 id=\"样例输入\"><a href=\"#样例输入\" class=\"headerlink\" title=\"样例输入\"><\\/a>样例输入<\\/h2><blockquote>\n<p>2 4<br>2 1 3 1<br>3 2 2 2<br>2 3 3 3<br>3 4 2 4<\\/p>\n<\\/blockquote>\n<h2 id=\"样例输出\"><a href=\"#样例输出\" class=\"headerlink\" title=\"样例输出\"><\\/a>样例输出<\\/h2><blockquote>\n<p>13<br>11<br>1<br>3<\\/p>\n<\\/blockquote>\n<h2 id=\"样例解释\"><a href=\"#样例解释\" class=\"headerlink\" title=\"样例解释\"><\\/a>样例解释<\\/h2><p>样例对应题目中的(𝑏)图。<br>第一个询问问的是图中编号为2的房子与编号为15的房子的距离。<br>第二个询问问的是图中编号为14的房子与编号为3的房子的距离。<br>第三个询问问的是图中编号为8的房子与编号为9的房子的距离。<br>第四个询问问的是图中编号为10的房子与编号为7的房子的距离。<\\/p>\n<h2 id=\"数据规模\"><a href=\"#数据规模\" class=\"headerlink\" title=\"数据规模\"><\\/a>数据规模<\\/h2><p>Easy：对于30%的数据，1 ≤ 𝑛 ≤ 3。<br>Normal：对于60%的数据，1 ≤ 𝑛 ≤ 8。<br>Hard：对于100%的数据，均有1 ≤ 𝑛 ≤ 15，1 ≤ 𝑖1, 𝑗1, 𝑖2, 𝑗2 ≤ 2𝑛，1 ≤ 𝑇 ≤ 10000。<\\/p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"><\\/a>思路<\\/h2><p>观察题意，不难看出，对于给定的坐标 (x1, y1) 和 (x2, y2)，记他们所对应的房子编号分别为 A, B，要求 A, B 两个房子之间的距离，可以看出<strong>这个距离等于编号A - 编号B 的绝对值<\\/strong>，记这个距离为 x，则我们可以看出：<code>x = abs(A - B)<\\/code>。既然距离是由两个房子的编号唯一决定，那么我们就可以将目标转移到<strong>求这两个坐标对应的房子的编号上<\\/strong>。<\\/p>\n<p>首先看 n 的范围不超过 15，也就是说最大的房子数量不超过 4 ^ 15 = 1073741824，做预处理的话开不下这么大的空间。这启示我们，一定存在一种方法，<strong>对于给定的一个城市坐标 (x, y)，通过这种方法能够直接推算出这个坐标所对应的房子编号<\\/strong>。<\\/p>\n<p>我们先观察这个图：观察当 n &gt;= 2 时候的图形，可以发现图形有这样的规律：基本图形总是会占满整个四分之一矩阵后，才会进入下一个四分之一矩阵。通过这样的规律，我们又能发现这四个被均分的矩阵<strong>具有相似的子结构<\\/strong>，所以我们可以想到——<strong>分！治！<\\/strong><\\/p>\n<p>接下来，目标转移到找到这个方法。题意告诉我们，对于任意已知的 n，以从上到下（行）为 x 轴正方向，以从左到右（列）为 y 轴正方向，第一个房子的坐标一定位于 (1, 1)，第 4^n 个房子一定位于 (2^n+1, 1)，所以根据这个性质我们一定能够推算出这个城市的具体道路规划图。<\\/p>\n<p>问题在于，编号和坐标之间有没有什么关系？<s>当然这种琢磨不透的题目<\\/s>一定不会让你一眼看出这个关系，所以我们需要一点小小的计算：<\\/p>\n<p>首先让我们看当 n = 1，即这个城市只有 1 阶，边长为 2^1=2，房子数 4^1 = 4。根据题意，我们有这样的关系：<\\/p>\n<pre><code>  1     2\n=========\n1 1 --- 2\n        |\n        |\n        |\n2 4 --- 3\n<\\/code><\\/pre><p>可以看到对于这样的矩阵，知道坐标的区间，就可以唯一确定城市的房子了。比如说在这里，(1, 1) 就对应房子 1。至于为什么和怎么确定，我们下面再说。不过说到这里有人还是会对这个 <s>flag<\\/s> 将信将疑：坐标对应的房子可能会受到这个“基本图形”开口的影响，凭什么说它可以唯一确定一个房子的编号？的确，假如它的开口不同，就会导致这个性质是错的。<s>既然如此我们就把这个反例消灭<\\/s>，保证一个子矩阵始终满足这个基本图形的性质。具体地说，对于已知 n = k 的 k 阶矩阵，一定要满足这个性质：<\\/p>\n<blockquote>\n<p>在最左上方取到这个矩阵中数的最小值，并在最左下方取到这个矩阵中数的最大值。<\\/p>\n<\\/blockquote>\n<p>具体的操作，比如说我们看下面的这个图，这也是由基本图形变形而来的：<\\/p>\n<pre><code> 1     4\n |     |\n |     |\n 2 --- 3\n<\\/code><\\/pre><p>那么怎么把它变成基本图形那样，可能大家的第一想法是旋转。但是旋转之后，并不满足在左上取最小值和左下取最大值的性质，所以旋转是不行的。所以我们采取另外一个方法，就是对称。例如上图中，我们取 1, 3 连接而成的对角线为对称轴，将这个图形沿着轴对称，那么这个图形就在还原回基本图形的同时，也保持了这个性质。<\\/p>\n<p>现在又有一个问题。如何知道什么时候对称，沿什么轴来对称？根据分治的思想我们再观察四个图形，我们发现，记当 n=k 的时候边长为 E, 则 E = 2^k，节点数为 N, 则 N = 4^k. 以中点为界将这个矩阵划分为相等的四个部分，<strong>右上角的矩阵和右下角的矩阵会始终保持着这个性质<\\/strong>，那么我们的对称操作只需要对左上和左下的两个矩阵执行就可以了。观察左上和左下的两个矩阵，我们在确定对称轴的时候只需要找到对称后<strong>还原出基本图形及满足其性质<\\/strong>（<s>窝说话太啰嗦了，所以希望你们还记得这个性质<\\/s>）的那一条对称轴即可。再看图形，我们很容易找出，使得左上部分矩阵符合以上性质的对称轴为<strong>从左上到原矩阵中心位置<\\/strong>的这条<strong>对角线<\\/strong>，同样我们为左下矩阵找到的对称轴为<strong>从左下到原矩阵中心位置<\\/strong>的这条<strong>对角线<\\/strong>。<\\/p>\n<p>下面开始用坐标推算房子的编号。我们规定<code>getnum(n, x, y)<\\/code>为<strong>第 n 阶中坐标位于 (x, y) 的房子的编号<\\/strong>，并且规定当 n = 0 的时候，<code>getnum(0, 1, 1) = 1<\\/code>。令 edgeMid = 当前阶的大矩阵边长的一半，有 <code>mid = 2^(n-1)<\\/code>，nodeNum = 当前阶的大矩阵被四均分后的节点数目，有 <code>node = 4^(n-1) = 2^(2n-2)<\\/code>.<\\/p>\n<p>注意到我们刚才提到的性质1：基本图形会先填满一个四分之一矩阵之后，才会进入下一个矩阵。而且无论 n 为何值，进入四个矩阵的先后顺序一定是：左上 =&gt; 右上 =&gt; 右下 =&gt; 左下。所以呢，对于右上的矩阵，编号最小的房子一定是 nodeNum + 1；对于右下的矩阵，编号最小的房子一定是 2 × nodeNum + 1；对于左下的矩阵，编号最小的房子一定是 3 × nodeNum + 1。最大的也很容易推出。<\\/p>\n<p>先从简单的两个子矩阵——也就是不需要做任何对称的两个矩阵入手：对于每个阶段右上和右下这两个不需要做对称操作的部分，其坐标和编号的关系是显然的一个递推式：<\\/p>\n<pre><code>\\/\\/ 右上\nindex = 1 * nodeNum + getnum(n - 1, x, y - edgeMid);\n\n\\/\\/ 右下\nindex = 2 * nodeNum + getnum(n - 1, x - edgeMid, y - edgeMid);\n<\\/code><\\/pre><p>其中进行坐标变换是为了确保起点为 (1, 1)，终点为 (2^n+1, 1)，这样根据坐标推出的编号才会成立。<\\/p>\n<p>进行对称操作的部分的坐标需要进行额外的小变化，因为<strong>进行了对称<\\/strong>，所以我们要<strong>将 x 和 y 进行反转<\\/strong>。同样也要进行坐标变换确保起点为 (1, 1) 和 (2^n+1, 1)。这里要注意一下左下矩阵的边界处理。<\\/p>\n<pre><code>\\/\\/ 左上\nindex = getnum(n - 1, y, x);\n\n\\/\\/ 左下\nindex = 3 * nodeNum + getnum(n - 1, edgeMid + 1 - y, 2 * edgeMid + 1 - x);\n<\\/code><\\/pre><p>注意这里的坐标轴方向是以向下为 x 轴正方向，向右为 x 轴负方向，这样大家画一画草图就可以很容易地推出左下矩阵这个让人看了十分害怕的递推式。<\\/p>\n<p>至此，我们的目的——根据节点坐标推算它的编号——已经达到了。不信的话你可以随便找个点按照上面的递推式试一下。<\\/p>\n<p>以下贴的是参考代码。事实上理解了上面的内容，代码也就不难出来了。<\\/p>\n<h2 id=\"示例代码-C\"><a href=\"#示例代码-C\" class=\"headerlink\" title=\"示例代码 (C++)\"><\\/a>示例代码 (C++)<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nint getNum(int stage, int x, int y)\n{\n  if (stage == 1) {\n    if (x == 1 &amp;&amp; y == 1)\n      return 1;\n    if (x == 1 &amp;&amp; y == 2)\n      return 2;\n    if (x == 2 &amp;&amp; y == 2)\n      return 3;\n    if (x == 2 &amp;&amp; y == 1)\n      return 4;\n  }\n\n  int edgeMid = 1 &lt;&lt; (stage - 1),                    \\/\\/ edgeMid = 2^(stage-1)\n      nodeNum = 1 &lt;&lt; (2 * (stage - 1));   \\/\\/ nodeNum = 4^(stage-1) = 2^2(stage-1)\n\n  if (x &lt;= edgeMid &amp;&amp; y &lt;= edgeMid)\n    return getNum(stage - 1, y, x);\n  if (x &lt;= edgeMid &amp;&amp; y &gt; edgeMid)\n    return nodeNum + getNum(stage - 1, x, y - edgeMid);\n  if (x &gt; edgeMid &amp;&amp; y &gt; edgeMid)\n    return 2 * nodeNum + getNum(stage - 1, x - edgeMid, y - edgeMid);\n  if (x &gt; edgeMid &amp;&amp; y &lt;= edgeMid)\n    return 3 * nodeNum + getNum(stage - 1, edgeMid + 1 - y, 2 * edgeMid + 1 - x);\n\n}\n\nint main()\n{\n  freopen(&quot;road.in&quot;, &quot;r&quot;, stdin);\n  freopen(&quot;road.out&quot;, &quot;w&quot;, stdout);\n\n  int n, T;\n  scanf(&quot;%d%d&quot;, &amp;n, &amp;T);\n\n  while (T--)\n  {\n    int x1, y1, x2, y2;\n    scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);\n    printf(&quot;%d\\n&quot;, abs(getNum(n, x1, y1) - getNum(n, x2, y2)));\n  }\n\n  fclose(stdin);\n  fclose(stdout);\n\n  return 0;\n}\n<\\/code><\\/pre>\n<blockquote>\n<p>这样我们就圆满地解决了这个问题。 —— 题解<\\/p>\n<\\/blockquote>\n<ul>\n<li>原题版权归出题人所有。<\\/li>\n<\\/ul>\n",
      "excerpt": "<p>emmm… FCS2017 夏令营的一道题目……用的是分治的算法，为了题目的一些细节本蒟蒻足足推了两个小时QAQ……所以要写篇文章记录一下不然哪天自己就看不明白了……<\\/p>\n<p>由于我比较啰嗦，以及我太弱了导致文章有可能有一些部分讲错了，所以，大家将就着看一下吧（虽然我不相信有人看）。<\\/p>",
      "slug": "strange-road-fcs2017-d2-solution",
      "published": true,
      "layout": "post",
      "path": "blog/post/strange-road-fcs2017-d2-solution/",
      "permalink": "https://kirainmoe.com/blog/post/strange-road-fcs2017-d2-solution/",
      "tags": [
        {
          "name": "algorithms",
          "slug": "algorithms",
          "path": "tags/algorithms/",
          "permalink": "https://kirainmoe.com/tags/algorithms/",
          "length": 1
        },
        {
          "name": "divide",
          "slug": "divide",
          "path": "tags/divide/",
          "permalink": "https://kirainmoe.com/tags/divide/",
          "length": 1
        }
      ],
      "categories": []
    },
    {
      "title": "从根源缩小 webpack 打包的 React App 体积",
      "date": "2017-06-06T02:51:43.000Z",
      "modified": "2018-01-07T05:18:36.776Z",
      "content": "<p>用 webpack 打包 React App 可谓是 React 开发中的最佳实践，但是有个令人十分头疼的问题就是在堆上了一堆依赖之后，用 webpack 打包出来的东西体积非常非常非常大，加载和首屏渲染的时间就要非常非常非常久，用户体验自然也就非……很不好。有很多前辈已经研究了很多缩小 webpack 打包出的 React App 体积的办法，这里我想讲一下自己踩这个大坑的经历以及发现的一个可行的方案。<\\/p>\n<a id=\"more\"><\\/a>\n<p><s>上一次更文已经是四……三……月份了？再不写点啥这里都有长草了……<\\/s><\\/p>\n<h1 id=\"在这之前\"><a href=\"#在这之前\" class=\"headerlink\" title=\"在这之前\"><\\/a>在这之前<\\/h1><p>关于如何缩小 webpack 打包出的 bundle 的体积，已经有很多的引路人为我们填下了很多的坑，所以如果你想要缩减体积提高 React App 的首屏渲染效率，你可以参考以下的这些方法：<\\/p>\n<h2 id=\"将第三方库与业务代码分离打包\"><a href=\"#将第三方库与业务代码分离打包\" class=\"headerlink\" title=\"将第三方库与业务代码分离打包\"><\\/a>将第三方库与业务代码分离打包<\\/h2><p>大概是个治标不治本的方法，因为要正常渲染还是都要加载的，只是分开之后业务代码的部分体积会小一些，而且 React 和 ReactDOM 这类的库可以直接从 CDN 取得。这个地方目前据我所知有三种主流的方法：<\\/p>\n<p>一个是修改 webpack.config.js 中的 vendor 和使用 CommonsChunkPlugin 来分离 vendor 和 bundle，可以参考：<\\/p>\n<ul>\n<li><a href=\"http:\\/\\/blog.csdn.net\\/tyro_java\\/article\\/details\\/54755610；\" target=\"_blank\" rel=\"external\">http:\\/\\/blog.csdn.net\\/tyro_java\\/article\\/details\\/54755610；<\\/a><\\/li>\n<li><a href=\"https:\\/\\/webpack.github.io\\/docs\\/code-splitting.html#multiple-entry-chunks\" target=\"_blank\" rel=\"external\">https:\\/\\/webpack.github.io\\/docs\\/code-splitting.html#multiple-entry-chunks<\\/a><\\/li>\n<\\/ul>\n<p>二是通过 webpack.config.js 中的 external 把模块的对象暴露到 window 中去，个人不是很推荐这种方法，虽然很方便，但不太好维护什么的；<\\/p>\n<p>三是用 webpack 的 DLL 方式来分离：<\\/p>\n<ul>\n<li><a href=\"http:\\/\\/www.jianshu.com\\/p\\/a5b3c2284bb6。\" target=\"_blank\" rel=\"external\">http:\\/\\/www.jianshu.com\\/p\\/a5b3c2284bb6。<\\/a><\\/li>\n<\\/ul>\n<h2 id=\"去掉不必要的东西和使用-uglifyJS-压缩\"><a href=\"#去掉不必要的东西和使用-uglifyJS-压缩\" class=\"headerlink\" title=\"去掉不必要的东西和使用 uglifyJS 压缩\"><\\/a>去掉不必要的东西和使用 uglifyJS 压缩<\\/h2><p>诸如 react-hot-loader 和 redux-devtools 一类的东西生产环境是不需要的，所以在 dist 的时候就不要打包进去了。<\\/p>\n<p>以及很重要也很有效的一个方法就是用 uglifyJS 插件压缩 JS 代码，webpack 中自带了 UglifyJsPlugin，只需要修改一下 webpack config 中的 plugin 就可以了：<\\/p>\n<pre><code class=\"javascript\">new webpack.optimize.UglifyJsPlugin({\n  compress: {\n    warnings: false,\n    comments: false\n  }\n})\n<\\/code><\\/pre>\n<h2 id=\"把代码分割成小块-Code-Split\"><a href=\"#把代码分割成小块-Code-Split\" class=\"headerlink\" title=\"把代码分割成小块 (Code Split)\"><\\/a>把代码分割成小块 (Code Split)<\\/h2><p>Code Split 的应用场景是当很多时候用户加载一个页面的时候只需要部分的内容，而却要下载所有的页面，因为它们被 webpack 一起打包在 bundle 当中了。解决方法就是把代码分块，然后按需加载。此方案支持 CommonJS 和 AMD, 但是暂时不支持 ES6 module. 这个方案可能对那些纠结 SPA 体积过大的开发者们很有帮助：<\\/p>\n<p><a href=\"https:\\/\\/webpack.github.io\\/docs\\/code-splitting.html\" target=\"_blank\" rel=\"external\">https:\\/\\/webpack.github.io\\/docs\\/code-splitting.html<\\/a><\\/p>\n<h2 id=\"从服务器端着手优化\"><a href=\"#从服务器端着手优化\" class=\"headerlink\" title=\"从服务器端着手优化\"><\\/a>从服务器端着手优化<\\/h2><p>从服务器端下手也是在正式发布生产环境之前一个很重要的环节——例如，开启 gzip 压缩的话能让 bundle 的体积缩小不少。以及不要忘记还有一个屡试不爽的方案——服务端渲染（SSR）。这两个方案的要求比较高也很好用，但是有些场景下并不适用<s>例如你没有服务器的控制权<\\/s>。<\\/p>\n<h1 id=\"直接从-React-上下手\"><a href=\"#直接从-React-上下手\" class=\"headerlink\" title=\"直接从 React 上下手\"><\\/a>直接从 React 上下手<\\/h1><p>在我完成一个 React 项目的过程中也因为体积太大而捣鼓了好久，上面的这些方法也或多或少试过，鉴于应用场景的特殊性和广泛性有些上文提到的有效的方法都无法实践在这个项目中。一个小小的东西打包出来有 360K+ 的大小。考虑到其中 React + ReactDOM + redux 就占了将近一半（170K 左右）的空间，所以能否从 React 上下手来减少 bundle 的体积？<\\/p>\n<p>答案是肯定的，但是这并不是要你去自己精简 React —— 为了一个小项目去做这样的事情实在是太费神了，<s>不如直接重构<\\/s>。好在，现在市面上也有一些 React 的精简版本，我们可以直接使用它们，有些轻量版的 React 甚至可以平滑过渡，<s>实在是我这种懒人的福音<\\/s>。<\\/p>\n<p>当前有很多对 React 进行抽象精简或者自行实现 Virtual DOM 和 JSX 的方案，例如 deku, react-lite, preact 等等。<\\/p>\n<h2 id=\"react-lite\"><a href=\"#react-lite\" class=\"headerlink\" title=\"react-lite\"><\\/a>react-lite<\\/h2><p>这里之所以不介绍 deku 是因为虽然 deku 有一些诸如 VDOM 的关键理念，但是如果你想从 React 转到 deku 相当于重构。<\\/p>\n<p>react-lite 是一个 react 的轻量实现。日常用到的 React API 几乎都可以在 react-lite 中跑起来。与原有的 react 相比<br>，react-lite 保留了 react 的大量特性，例如 VDOM，JSX，等等；当然也丢了一些某些场景下用不到的东西，如果你不想要服务端渲染的话可以考虑使用 react-lite。<\\/p>\n<blockquote>\n<p>React-lite supports the core APIs of React, such as Virtual DOM, intended as a drop-in replacement for React, when you don’t need server-side rendering in browser(no ReactDOM.renderToString &amp; ReactDOM.renderToStaticMarkup).<\\/p>\n<\\/blockquote>\n<p>react-lite 也是我现在正在使用的代替 react 的方案，从某种意义上讲，react-lite 在某些方面（例如渲染等）的性能优于 react. 除了能有效地缩小 bundle 的体积（170K+ -&gt; 30K）以及配置方便以外，它最吸引人的地方还在于：<\\/p>\n<h3 id=\"它能和-react-router-redux-完美兼容！\"><a href=\"#它能和-react-router-redux-完美兼容！\" class=\"headerlink\" title=\"它能和 react-router \\/ redux 完美兼容！\"><\\/a>它能和 react-router \\/ redux 完美兼容！<\\/h3><h3 id=\"它能和-react-router-redux-完美兼容！-1\"><a href=\"#它能和-react-router-redux-完美兼容！-1\" class=\"headerlink\" title=\"它能和 react-router \\/ redux 完美兼容！\"><\\/a>它能和 react-router \\/ redux 完美兼容！<\\/h3><h3 id=\"它能和-react-router-redux-完美兼容！-2\"><a href=\"#它能和-react-router-redux-完美兼容！-2\" class=\"headerlink\" title=\"它能和 react-router \\/ redux 完美兼容！\"><\\/a>它能和 react-router \\/ redux 完美兼容！<\\/h3><p>简直太棒了有没有！！这意味着用 react-router + redux 构建的 react 项目几乎就可以直接平滑地过渡到 react-lite 上！！而且对于 react 的一些 unittest, react-lite 都能跑过。<\\/p>\n<p>从 react 过渡到 react-lite 也十分容易，在大部分情况下两者是可以兼容的，直接为 webpack 配置一个 alias，把对 react 的引用指向 react-lite 即可：<\\/p>\n<pre><code class=\"javascript\">\\/\\/ webpack.config.js\n{\n    resolve: {\n        alias: {\n            &#39;react&#39;: &#39;react-lite&#39;,\n            &#39;react-dom&#39;: &#39;react-lite&#39;\n        }\n    }\n}\n<\\/code><\\/pre>\n<p><a href=\"https:\\/\\/github.com\\/Lucifier129\\/react-lite\" target=\"_blank\" rel=\"external\">https:\\/\\/github.com\\/Lucifier129\\/react-lite<\\/a><\\/p>\n<h2 id=\"preact\"><a href=\"#preact\" class=\"headerlink\" title=\"preact\"><\\/a>preact<\\/h2><p>react-lite 能把 150K+ 的 react &amp; react-dom 弄到 25K 左右，接下来介绍的 preact 号称是“3KB 的 react”，而且与 react 有相似的 API：<\\/p>\n<blockquote>\n<p>Fast 3kB alternative to React, with the same ES2015 API.<\\/p>\n<p>All the power of Virtual DOM components, without the overhead:<\\/p>\n<ul>\n<li>Familiar React API &amp; patterns: ES6 Class and Functional Components<\\/li>\n<li>Extensive React compatibility via a simple preact-compat alias<\\/li>\n<li>Everything you need: JSX, VDOM, React DevTools, HMR, SSR..<\\/li>\n<li>A highly optimized diff algorithm and seamless Server Side Rendering<\\/li>\n<li>Transparent asynchronous rendering with a pluggable scheduler<\\/li>\n<\\/ul>\n<\\/blockquote>\n<p>和 react-lite 一样，它的渲染性能在某些场景下也能超过 react，毕竟没有了那么多奇奇怪怪的东西，性能飞起来也不足为奇嘛。<\\/p>\n<p>不过，体积小了 50 倍，相应地你也要付出一些代价。preact 不像 react-lite 那样可以平滑过渡，要修改组件的代码，自己配置 babel 对 JSX 的转译，很多东西也都需要替换成 preact 专用的东西，相对的讲不是那么方便，据说 react 的单元测试 preact 只能跑过一半。但是想到体积减小的大胜利，这点小小的工作就不值一提了。<\\/p>\n<p><a href=\"https:\\/\\/github.com\\/developit\\/preact\" target=\"_blank\" rel=\"external\">https:\\/\\/github.com\\/developit\\/preact<\\/a><\\/p>\n<h1 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"><\\/a>后记<\\/h1><p>通过上面的方案以及直接对 React 动刀子，项目的体积直接从原来的 360K 左右变到 170K 上下了，首屏渲染的速度也改善了很多。后续如果还有什么行之有效的优化方法再补充这篇文章吧。<\\/p>\n",
      "excerpt": "<p>用 webpack 打包 React App 可谓是 React 开发中的最佳实践，但是有个令人十分头疼的问题就是在堆上了一堆依赖之后，用 webpack 打包出来的东西体积非常非常非常大，加载和首屏渲染的时间就要非常非常非常久，用户体验自然也就非……很不好。有很多前辈已经研究了很多缩小 webpack 打包出的 React App 体积的办法，这里我想讲一下自己踩这个大坑的经历以及发现的一个可行的方案。<\\/p>",
      "slug": "reduce-react-webpack-app-volume-in-an-extreme-way",
      "published": true,
      "layout": "post",
      "path": "blog/post/reduce-react-webpack-app-volume-in-an-extreme-way/",
      "permalink": "https://kirainmoe.com/blog/post/reduce-react-webpack-app-volume-in-an-extreme-way/",
      "tags": [
        {
          "name": "react",
          "slug": "react",
          "path": "tags/react/",
          "permalink": "https://kirainmoe.com/tags/react/",
          "length": 4
        },
        {
          "name": "webpack",
          "slug": "webpack",
          "path": "tags/webpack/",
          "permalink": "https://kirainmoe.com/tags/webpack/",
          "length": 3
        },
        {
          "name": "volume",
          "slug": "volume",
          "path": "tags/volume/",
          "permalink": "https://kirainmoe.com/tags/volume/",
          "length": 1
        },
        {
          "name": "react-lite",
          "slug": "react-lite",
          "path": "tags/react-lite/",
          "permalink": "https://kirainmoe.com/tags/react-lite/",
          "length": 1
        },
        {
          "name": "preact",
          "slug": "preact",
          "path": "tags/preact/",
          "permalink": "https://kirainmoe.com/tags/preact/",
          "length": 1
        }
      ],
      "categories": []
    },
    {
      "title": "导出 Typecho 的数据到 Canvas：typecho-to-canvas",
      "date": "2017-04-09T08:28:10.000Z",
      "modified": "2018-01-07T05:15:25.777Z",
      "content": "<p>通过简单几步，将 Typecho 博客程序的数据（文章，标签一类）轻松转换到由 Laravel 驱动的 Canvas 博客平台。<br><a id=\"more\"><\\/a><br>有关 <a href=\"canvas.toddaustin.io\">Canvas<\\/a> 什么的我就不说了吧，大概知道这是个比较新的 PHP 博客程序，由 Laravel 框架驱动就可以了。<\\/p>\n<p>至于为什么为突发奇想写这样一个东西，首先主要是这是个比较新鲜的东西，相关的东西都还很少，我在 GitHub 上找到了 <em>wordpress-to-canvas<\\/em> 的东西，于是便觉得为何不搞一个 <em>typecho-to-canvas<\\/em> 呢～其次呢，因为我之前用过一段时间的 Typecho，也想借这个东西把之前的一些数据导回来（虽然我找不到我把 DB 的 备份扔到哪了……qwq），以及……其他的一些原因……所以就花了一些时间造这个轮子啦。<\\/p>\n<p>GitHub: <a href=\"https:\\/\\/github.com\\/kirainmoe\\/typecho-to-canvas\" target=\"_blank\" rel=\"external\">typecho-to-canvas: easily converting your data from Typecho to Canvas<\\/a><\\/p>\n<p>Packagist(Composer): <a href=\"https:\\/\\/packagist.org\\/packages\\/kirainmoe\\/typecho-to-canvas\" target=\"_blank\" rel=\"external\">typecho-to-canvas<\\/a><\\/p>\n<h2 id=\"功能特色\"><a href=\"#功能特色\" class=\"headerlink\" title=\"# 功能特色\"><\\/a># 功能特色<\\/h2><ul>\n<li>Typecho 下的第一个 “Switch to Canvas” 工具<\\/li>\n<li>支持转换 Typecho 的文章、标签和关系树，兼容性约 95%<\\/li>\n<li>自动加载和解析配置数据，你甚至可以全程 Enter<\\/li>\n<li>在 CLI 模式下运行<\\/li>\n<li><s>作者这么萌<\\/s><\\/li>\n<\\/ul>\n<h2 id=\"环境需求\"><a href=\"#环境需求\" class=\"headerlink\" title=\"# 环境需求\"><\\/a># 环境需求<\\/h2><ul>\n<li>确保 Typecho 和 Canvas 在转换环境下分别已正确安装<\\/li>\n<li>拥有转换环境的操作权限<\\/li>\n<li>PHP 5.6.4 以上的版本（Canvas 的版本要求）<\\/li>\n<li>已正确安装 composer 依赖管理工具<\\/li>\n<li>PHP 已加载对应 Typecho 和 Canvas 安装类型的数据库的 PDO 拓展<\\/li>\n<li>数据库正常运行<s>（废话）<\\/s><\\/li>\n<li>耐心，Patient<\\/li>\n<\\/ul>\n<h2 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"# 使用方法\"><\\/a># 使用方法<\\/h2><h4 id=\"数据无价，在进行以下操作之前，强烈建议手动备份-Typecho-和-Canvas-的数据库。\"><a href=\"#数据无价，在进行以下操作之前，强烈建议手动备份-Typecho-和-Canvas-的数据库。\" class=\"headerlink\" title=\"数据无价，在进行以下操作之前，强烈建议手动备份 Typecho 和 Canvas 的数据库。\"><\\/a>数据无价，在进行以下操作之前，强烈建议手动备份 Typecho 和 Canvas 的数据库。<\\/h4><h4 id=\"数据无价，在进行以下操作之前，强烈建议手动备份-Typecho-和-Canvas-的数据库。-1\"><a href=\"#数据无价，在进行以下操作之前，强烈建议手动备份-Typecho-和-Canvas-的数据库。-1\" class=\"headerlink\" title=\"数据无价，在进行以下操作之前，强烈建议手动备份 Typecho 和 Canvas 的数据库。\"><\\/a>数据无价，在进行以下操作之前，强烈建议手动备份 Typecho 和 Canvas 的数据库。<\\/h4><h4 id=\"数据无价，在进行以下操作之前，强烈建议手动备份-Typecho-和-Canvas-的数据库。-2\"><a href=\"#数据无价，在进行以下操作之前，强烈建议手动备份-Typecho-和-Canvas-的数据库。-2\" class=\"headerlink\" title=\"数据无价，在进行以下操作之前，强烈建议手动备份 Typecho 和 Canvas 的数据库。\"><\\/a>数据无价，在进行以下操作之前，强烈建议手动备份 Typecho 和 Canvas 的数据库。<\\/h4><p>重要的事情说三遍。<br>再次确保你的环境工作正常，Typecho 和 Canvas 的数据库可以访问～然后接着往下看吧～<\\/p>\n<h4 id=\"准备：安装-te2cn\"><a href=\"#准备：安装-te2cn\" class=\"headerlink\" title=\"准备：安装 te2cn\"><\\/a>准备：安装 te2cn<\\/h4><p>安装教程可以在 GitHub 的 README 找到：<a href=\"https:\\/\\/github.com\\/kirainmoe\\/typecho-to-canvas\" target=\"_blank\" rel=\"external\">https:\\/\\/github.com\\/kirainmoe\\/typecho-to-canvas<\\/a><\\/p>\n<p>这里提供通过 Git 的安装方法，简单快捷～如果你没有安装 Git，请自行搜索当前系统的安装方式。<\\/p>\n<pre><code class=\"shell\"># 首先将项目仓库拉下来\n$ git clone https:\\/\\/github.com\\/kirainmoe\\/typecho-to-canvas\n$ cd typecho-to-canvas\n\n# 然后用 composer 安装依赖\n$ composer install\n\n# 运行 te2cn，按照提示转换数据就行啦\n$ chmod -R 755 .\\/te2cn\n$ .\\/te2cn\n<\\/code><\\/pre>\n<hr>\n<h4 id=\"填写数据库配置信息\"><a href=\"#填写数据库配置信息\" class=\"headerlink\" title=\"填写数据库配置信息\"><\\/a>填写数据库配置信息<\\/h4><p>运行程序首先是一贯的套路 welcome，然后 <strong>te2cn<\\/strong> 会先后向你询问 <em>Typecho<\\/em> 和 <em>Canvas<\\/em> 的数据库配置信息。首先会询问 Typecho 的数据库配置信息，请按顺序依次输入：数据库主机、用户、密码、数据库名称、端口、以及数据库的种类。程序会给出默认值，如果你不需要修改默认值，可以直接敲回车。<br>（小技巧：直接将 Typecho 的配置文件 <strong>config.inc.php<\\/strong> 复制到程序目录下，<strong>te2cn<\\/strong> 会自动解析数据库配置，无需人工填写）<\\/p>\n<p>接下来会询问 Canvas 数据库的配置信息。首先会问你 Canvas 和 Typecho 是否安装在同一数据库主机中，如果是的话直接回车，程序会问你 Canvas 安装的数据库名称；如果不是的话，会收集 Canvas 安装数据库的配置。<br>（目前暂时不支持解析 Laravel .ENV 的说 qwq）<\\/p>\n<p>接下来会列出所收集或解析的数据库的配置信息，请检查是否有误，如果无误可以直接敲回车。<\\/p>\n<h4 id=\"开始转换进程\"><a href=\"#开始转换进程\" class=\"headerlink\" title=\"开始转换进程\"><\\/a>开始转换进程<\\/h4><p>如果信息填写正确，程序就会自动开始数据导出进程。不过在这之前会先询问你是否保留 Canvas 的现有数据，如果你需要保留直接回车，不保留的话需要确认两次，以防误操作丢失数据。<\\/p>\n<p>然后，程序就会自动启动转换进程。取决于 Typecho 数据量的大小以及服务器 IO 性能，这个过程可能需要一些时间，请耐心等待，在依次导出了 tags, posts, relationships 之后，就完成了操作。<\\/p>\n<h4 id=\"Enjoy～\"><a href=\"#Enjoy～\" class=\"headerlink\" title=\"Enjoy～\"><\\/a>Enjoy～<\\/h4><p>当看到转换完成的提示之后，Typecho 的数据就成功地被导出到 Canvas 了。你可以试一试运行 Canvas 看看效果：<\\/p>\n<pre><code class=\"shell\">$ cd \\/path\\/to\\/your\\/canvas\n$ php artisan serve\n<\\/code><\\/pre>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"# 问题解决\"><\\/a># 问题解决<\\/h2><p>目前由于 Canvas 暂时不支持本地评论以及其他一些 Typecho 的 features，所以只做了文章、标签和关系树的单向转换。如果有时间会更新逆向转换功能（canvas-to-typecho）。<\\/p>\n<p>有任何问题或者建议，都可以到 GitHub 的项目主页提 issues 或者 Pull request 告诉我们。<\\/p>\n<p>嘛。希望这个轮子能对你们有帮助～<\\/p>\n",
      "excerpt": "<p>通过简单几步，将 Typecho 博客程序的数据（文章，标签一类）轻松转换到由 Laravel 驱动的 Canvas 博客平台。<br>",
      "slug": "export-data-of-typecho-to-canvas",
      "published": true,
      "layout": "post",
      "path": "blog/post/export-data-of-typecho-to-canvas/",
      "permalink": "https://kirainmoe.com/blog/post/export-data-of-typecho-to-canvas/",
      "tags": [],
      "categories": []
    }
  ],
  "menu": {
    "Home": "/",
    "Guestbook": "/pages/guestbook/",
    "Friends": "/pages/friends/",
    "About": "https://about.me/kirainmoe"
  },
  "socials": {
    "twitter": "https://twitter.com/yume_kankawa",
    "github": "https://github.com/kirainmoe",
    "weibo": "https://weibo.com/returnnnn",
    "medium": "https://medium.com/@kotori",
    "lastfm": "https://www.last.fm/user/kirainmoe"
  },
  "avatar": "https://secure.gravatar.com/avatar/c47187d311099868de825697fa419654?s=200&r=G",
  "menuIcon": {
    "Home": "home",
    "Guestbook": "book",
    "Friends": "users",
    "Archives": "tags",
    "About": "id-card-o"
  },
  "disqus": "yume-diary",
  "prev": 1,
  "next": 3
}</script>
  <!-- hook node of React -->
  <div id="himawari-app"></div>

  
    <!-- scripts list from theme config.yml -->
    
      <script src="https://unpkg.com/muse-player/dist/assets/muse-player.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/prism.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-clike.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-php.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-css.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-c.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-cpp.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-javascript.min.js"></script>
    
      <script src="/common.js"></script>
    
      <script src="/main.js"></script>
    
  

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-111347233-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-111347233-1');
  </script>

</body>
</html>
