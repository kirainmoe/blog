<!-- Himawari no Yakusoku -->

<!DOCTYPE html>
<html lang="Zh-cn">
<head>
  <meta charset="UTF-8">
  <meta name="theme-color" content="#FF98A8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Archives: 10/2017: 2017 [ YumeのDiary ]</title>
  <meta name="description" content="6 年間、共に歩んでくれたあなたへ。">
  <link rel="manifest" href="/manifest.json">
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    
      <link rel="stylesheet" href="/himawari.css">
    
  
</head>
<body>
  
  <!-- infos -->
  <script type="text/json" id="himawari-json">{
  "title": "YumeのDiary",
  "siteTitle": "YumeのDiary",
  "description": "6 年間、共に歩んでくれたあなたへ。",
  "author": "Yume Kankawa",
  "route": "year",
  "format": "blog/:layout/:title/",
  "posts": [
    {
      "title": "记自己的第一次差点翻车的出题经历",
      "date": "2017-10-29T13:01:52.000Z",
      "modified": "2018-01-07T05:18:30.966Z",
      "content": "<p>复赛在即，我们学校里面的四个撒币不知道是谁突发奇想，说要出一套模拟题。于是我们四个人分别出了一道要多恶心有多恶心的题= =本来嘛是要在学校内部自己测的，不过人太少，不好玩，于是就连夜 py 到洛谷上搞了公开赛。从早上 8 点到中午 12 点，虽然出了很多的锅，不过还是要记录一下我的第一次出题经历（<\\/p>\n<a id=\"more\"><\\/a>\n<p><div id=\"muse-app\"><\\/div><\\/p>\n<script type=\"text\\/javascript\">\nvar playList = [\n  {\n    \"title\": \"未来の僕らは知ってるよ\",\n    \"artist\": \"Aqours\",\n    \"cover\": \"http:\\/\\/p1.music.126.net\\/03tA9ZYD51gTLxlEuY3_vw==\\/109951163049447102.jpg\",\n    \"src\": \"https:\\/\\/api.kotori.love\\/netease\\/514543403.mp3\",\n    \"lyric\": \"[00:00.00] 作曲 : 光増ハジメ\\n[00:00.17] 作词 : 畑亜贵\\n[00:00.51](千歌)本気を ぶつけあって\\n[00:06.15]手に入れよう (全员)未来を\\n[00:14.63]\\n[00:20.23]味方なんだ 空も この海も\\n[00:25.75]さあ頑張るんだと 輝いてるよ\\n[00:30.73]遠くへ 遠くへ 声が届くように\\n[00:36.34]もっと大きくユメを叫ぼうか\\n[00:41.22](2年生)(希望でいっぱいの)\\n[00:43.20](3年生)今日が明日を引き寄せるんだと\\n[00:47.33](1年生)ハートの磁石を握って走る\\n[00:51.81](全员)今は 楽しいんだ それが\\n[00:55.92]「ずっと一緒に行こう！」\\n[00:57.92]\\n[00:58.15]未来をどうしようかな\\n[01:01.02]みんな夢のカタチを探して\\n[01:06.53]泣いたり 笑ったり\\n[01:08.74]未来の僕たちは きっと答えを持ってる\\n[01:15.11]はずだから 本気で駆け抜けて\\n[01:23.33]\\n[01:30.19](梨子)歌いながら 雨に濡れながら\\n[01:36.11](曜)絶対晴れると信じてるんだよ\\n[01:40.96](花丸)元気な (露比)元気な\\n[01:43.40](花丸)声で (花露)呼んでみよう\\n[01:46.69](善子)きっと大きな\\n[01:48.70](夜羽)夢に会えるはずさ\\n[01:52.10](果南)進化したいから すぐできないこと\\n[01:56.30](黛雅)ひとつ ひとつ 乗り越えて\\n[02:01.74](鞠莉)雲の間に間に新しい青空が\\n[02:07.20]待ってるよ (全员)待ってるよ\\n[02:11.94]\\n[02:12.36](全员)期待で弾け飛ぼう\\n[02:15.60]こんな勢いのままで\\n[02:18.73]行きたいよ\\n[02:20.71]泣いても 笑っても\\n[02:22.95]期待が僕たちへたくさん合図くれるから\\n[02:29.40]逃がさないで チャンスを捕まえて\\n[02:36.68]\\n[02:45.10]I live I live lovelive days！！\\n[02:48.47]\\n[02:52.69]本気をぶつけたら\\n[02:57.26]叶うんじゃないかな ユメ\\n[03:04.00]\\n[03:05.51](千歌)未来をどうしようかな\\n[03:08.21]みんなユメのカタチを ah (ah～)\\n[03:13.77]探してるんだ みんなで\\n[03:15.61]\\n[03:15.97](全员)期待で弾け飛ぼう\\n[03:18.85]こんな勢いのままで 行きたいよ\\n[03:24.41]泣いても 笑っても\\n[03:26.64]未来の僕たちは きっと答えを持ってる\\n[03:33.18]はずだから 本気で駆け抜けて\\n[03:40.28]チャンスを捕まえて\\n[03:48.10]光る風になろう\\n[03:51.10]We got dream!\\n\",\n    \"translation\": \"[00:00.51]让我们触碰彼此真心\\n[00:06.15]将未来紧握手中\\n[00:14.63]\\n[00:20.23]碧海蓝天 与我们同在\\n[00:25.75]来吧 高喊加油 闪耀起来哟\\n[00:30.73]为了让声音传向更远更远\\n[00:36.34]更加放声呼喊梦想吧\\n[00:41.22]（希望已充盈四周）\\n[00:43.20]今日之行引导着明日之景\\n[00:47.33]紧握心型磁石向前奔跑\\n[00:51.81]如今这样就让人非常欢乐\\n[00:55.92] “一直携手同行吧”\\n[00:57.92]\\n[00:58.15]究竟要怎样对待未来呢\\n[01:01.02]大家一路捕捉梦想的形状\\n[01:06.53]时而落泪 时而欢笑\\n[01:08.74]未来的我们一定早已知晓答案\\n[01:15.11]所以更应全心全意勇往直前\\n[01:23.33]\\n[01:30.19]在风雨中坚持歌唱\\n[01:36.11]因为相信着一定会放晴\\n[01:40.96]试着用元气满满的\\n[01:43.40]声音来呼喊吧\\n[01:46.69]这样定能相遇\\n[01:48.70]壮阔的梦想\\n[01:52.10]因为想要蜕变 所以要将尚且力所不及的事情\\n[01:56.30]一件一件把它们战胜\\n[02:01.74]波涛云海间的崭新蓝天\\n[02:07.20]正等待着 等待着我们呢\\n[02:11.94]\\n[02:12.36]满怀期待尽情绽放\\n[02:15.60]希望就着这个劲头\\n[02:18.73]一直勇往直前\\n[02:20.71]即使一路有笑有泪\\n[02:22.95]期待会向我们发来许多指引的信号\\n[02:29.40]所以不要逃避了 快把握住每个机遇\\n[02:36.68]\\n[02:45.10]\\n[02:48.47]\\n[02:52.69]跟随自我本心而努力\\n[02:57.26]是不是就能让梦想实现呢\\n[03:04.00]\\n[03:05.51]究竟要怎样对待未来呢\\n[03:08.21]那些梦想的轮廓\\n[03:13.77]就让大家一起来寻找吧\\n[03:15.61]\\n[03:15.97]满怀期待尽情绽放\\n[03:18.85]希望照着这个劲头一直勇往直前\\n[03:24.41]即使一路有笑有泪\\n[03:26.64]未来的我们一定早已知晓答案\\n[03:33.18]所以更应全心全意勇往直前\\n[03:40.28]把握住每个机遇\\n[03:48.10]化作闪耀的风儿\\n[03:51.10]\"\n  }\n];\nwindow.MUSE.render(playList, document.getElementById('muse-app'));\n<\\/script>\n\n<h1 id=\"感受\"><a href=\"#感受\" class=\"headerlink\" title=\"感受\"><\\/a>感受<\\/h1><p>各位有兴趣看题目的话地址在这里：<br><a href=\"https:\\/\\/www.luogu.org\\/contest\\/show?tid=4291\" target=\"_blank\" rel=\"external\">https:\\/\\/www.luogu.org\\/contest\\/show?tid=4291<\\/a><br><a href=\"https:\\/\\/www.luogu.org\\/problemnew\\/show\\/U14667\" target=\"_blank\" rel=\"external\">https:\\/\\/www.luogu.org\\/problemnew\\/show\\/U14667<\\/a><\\/p>\n<p>安排给我的出题难度是压轴（也就是最难的那一题），不过被我活生生出成了水题= =……出了一道状压 DP 的模板题（大概），然后呢并没有人帮我验题（事实上他们三个人互相 A 不掉对方的题目总共前前后后调到比赛都开始了还在出锅）……<\\/p>\n<p>于是因此发生了一件很尴尬的事情，就是造数据的时候呢，因为 std 出了锅少写了一个等于号，然后造出了一堆错误的数据，把正解卡到了 30 分= =比赛完了之后写题解才发现，卧槽标程都出锅了，然后更新数据、重传数据，联系了 luogu 的管理员帮我们重测，然后还一个一个给可能写了正解的参赛者发私信道歉+让他们请求重新提交……<\\/p>\n<p>提交了 80 多个人有将近 90% 是输出 No Answer 骗分的233333早知道不设这个点了（<\\/p>\n<p>最后重新提交完有两个写出了正解的 julao，一个写了接近正解但是差一点的 dalao……嘛，看起来这题出得还是挺水的（不过话说回来，比同校人出的那些题良心多了2333<\\/p>\n<hr>\n<p>接下来是题目：<\\/p>\n<h1 id=\"肝活动-event-pas-c-cpp\"><a href=\"#肝活动-event-pas-c-cpp\" class=\"headerlink\" title=\"肝活动 (event.pas\\/.c\\/.cpp)\"><\\/a>肝活动 (event.pas\\/.c\\/.cpp)<\\/h1><p>时间限制：1s \\/ 空间限制：512MB \\/ 测试点数目：20<\\/p>\n<h2 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"><\\/a>题目描述<\\/h2><p>Yume 最近在玩一个名为《LoveLive! School idol festival》的音乐游戏。他之所以喜欢上这个游戏，是因为这个游戏对非洲人十分友好，即便你脸黑到抽不出好卡，还可以通过在每个月举办的两次活动中达成一定的目标来获得奖励。<br>Yume 很喜欢这一期活动奖励卡的卡面，于是他决定要肝这一期的活动，拿到活动奖励。这一期的活动规则很特殊，玩家需要在活动规定的结束时间前，完成所有指定的歌曲<strong>（每首歌只能打一次）<\\/strong>，并获得一定的分数，就可以拿到活动奖励。如果在规定的时间前没有完成所有的歌曲，或者分数不够奖励的分数线，则不能领取活动奖励。每首歌有一个限定的奖励开放时间，玩家如果在这段时间内完成了这首歌，便可以获得一定的分数<strong>（获得的分数 = 开放时间 - 当前已用的总时间）<\\/strong>。如果超出了这段时间之后再完成这首歌，就不能获得分数了。<br>这样的规则对 Yume 这样的老玩家来说本应是轻而易举，但不巧的是 Yume 把活动的结束时间记成了活动的开始时间，以至于当他上线跃跃欲试的时候，惊恐地发现活动已经快要结束了。现在他想知道，在剩余的时间之内，他能否完成所有的歌、达成奖励的分数线拿到活动卡。为了节省时间，他把这个问题交给了你来解决。请你根据给定的数据，帮他计算出能否在剩余的时间内达成目标。如果能，请告诉他完成每首歌曲的顺序。<\\/p>\n<h2 id=\"输入数据\"><a href=\"#输入数据\" class=\"headerlink\" title=\"输入数据\"><\\/a>输入数据<\\/h2><p>从文件 event.in 读取输入数据。<br>输入的第一行是三个整数 n, m, t，分别表示规定完成的歌曲数目、获得奖励需要达到的最低分数和距离活动结束剩余的时间。<br>接下来有 n 行，第 i 行有一个字符串 Si 和两个整数 Ti 和 Mi，表示第 i 首歌的歌名为 Si，完成第 i 首歌所需要的时间为 Ti，第 i 首歌的奖励开放时间剩余 Mi。保证 Ti ≤ Mi. 其中数据已按 Si 的字典序给出。<\\/p>\n<h2 id=\"输出数据\"><a href=\"#输出数据\" class=\"headerlink\" title=\"输出数据\"><\\/a>输出数据<\\/h2><p>将答案输出到 event.out 中。<br>如果在活动结束前 Yume 可以完成指定的目标拿到奖励，则在第一行输出一个整数 C，表示在获得奖励的前提下，所能够获得的分数的最大值；接下来的 n 行中，按照完成歌曲的顺序输出第 i 首歌的歌名。如果有多种可能性，则输出字典序最小的情况。<br>如果在活动结束前 Yume 不能完成所有的歌曲，输出 No Answer .<\\/p>\n<h2 id=\"输入样例\"><a href=\"#输入样例\" class=\"headerlink\" title=\"输入样例\"><\\/a>输入样例<\\/h2><blockquote>\n<p>【样例1】<br>3 2 10<br>BokutachiwaHitotsunoHikari 3 8<br>Korekara 1 2<br>SnowHalation 2 5<\\/p>\n<p>【样例2】<br>2 1 2<br>AoizoraJumpingHeart 1 2<br>TimeLapse 2 4<\\/p>\n<\\/blockquote>\n<h2 id=\"输出样例\"><a href=\"#输出样例\" class=\"headerlink\" title=\"输出样例\"><\\/a>输出样例<\\/h2><blockquote>\n<p>【样例1】<br>6<br>SnowHalation<br>BokutachiwaHitotsunoHikari<br>Korekara<\\/p>\n<p>【样例2】<br>No Answer<\\/p>\n<p>样例1说明：<br>首先打第三首歌，用时 2，获得分数为 (5-2)=3；<br>接着打第一首歌，用时 3，获得分数为 (8-2-3)=3；<br>最后打第二首歌，用时 1，由于打完第二首歌之后总用时为 6，但第二首歌的奖励获得时间为 2，因此不能获得分数。<br>总用时为 6 &lt; 10，分数为 6 &gt; 2，完成目标。<\\/p>\n<\\/blockquote>\n<h2 id=\"数据规模\"><a href=\"#数据规模\" class=\"headerlink\" title=\"数据规模\"><\\/a>数据规模<\\/h2><p>对于 0% 的数据，与测试数据完全相同。<br>对于 20% 的数据，满足 n ≤ 5。<br>对于 40% 的数据，满足 n ≤ 9。<br>对于 70% 的数据，满足 n ≤ 15。<br>对于 100% 的数据，满足 n ≤ 22，Si 的长度不超过 50. 保证 m, t 和 Ti, Mi 以及其相加的结果都在 int 的最大范围内。<br>另有 10% 的数据满足 Sigma(T1, T2, …, Tn) &lt; t.<\\/p>\n<h1 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"><\\/a>题解<\\/h1><p>没错，这是一道状态压缩 DP（而且事实上是道水题吧，感觉对不起提高+\\/省选-的评级 Orz）。很多人没写出来大概是因为被这个比赛发起人瞎 YY 的评级吓到了……不太明白状态压缩 DP 原理的= =嘛，建议先去理解一下，出题人太懒，不想在题解里写状压 DP 的原理（逃<\\/p>\n<p>首先要读懂题目的意思，找出关键的信息，这个不多说。注意一下分数的计算方式和获得奖励的条件即可。<\\/p>\n<p>先考虑无解的情况，第一种情况是当 <code>Sigma(T1, T2, T3, ..., Tn) &lt; t<\\/code> 的时候，在剩余时间内无法完成所有的歌，很明显应该输出 <code>No Answer<\\/code>.<\\/p>\n<p>还有一种情况是即便在规定时间内打完了所有的歌，仍然达不到规定的分数 m 的时候，也是 <code>No Answer<\\/code>，这种情况我们只能找到最大值后才计算。可惜有一位离正解很近的 julao 忘记了这种情况被砍掉了 15 = =<\\/p>\n<p>再就是状态的设计。题目中规定要完成每首歌，并且每首歌都只能打一次，那么我们设 <code>dp[i]<\\/code> 表示<strong>当前已完成的歌曲编号的二进制状态为 i 的情况下，能取得的分数的最大值<\\/strong>。<\\/p>\n<p>那么转移方程就显然了：<code>dp[i] = max(dp[i], dp[i &amp; (~j)] + limit[j] - curTime[i])<\\/code>，其中 <code>j<\\/code> 是当前考虑的歌曲编号，那么 <code>i &amp; (~j)<\\/code> 就是打第 j 首歌之前的状态，<code>limit[j]<\\/code> 表示能获得奖励分数的规定时间，<code>curTime[i]<\\/code> 就是打完第 j 首歌之后的总用时。<\\/p>\n<p>我们可以看到完成的歌曲的二进制状态为 i 时所用的时间 <code>curTime[i]<\\/code> 与打歌的顺序无关，所以我们可以预处理计算出这个 <code>curTime<\\/code> 数组:<\\/p>\n<pre><code class=\"cpp\">for (int i = 0; i &lt; (1 &lt;&lt; 22); i++)\n{\n  for (int j = 0; j &lt; n; j++)\n  {\n    \\/\\/ 状态 i 已经包含了第 j 首歌\n    if (i &amp; j) {\n      continue;\n    }\n    curTime[i | j] = curTime[i] + cost[j];\n  }\n}\n<\\/code><\\/pre>\n<p>当然你也可以不做这一步，直接在 DP 的时候更新当前状态的时间也没有问题。<\\/p>\n<p>接下来我们就可以写出 DP 的主过程了。Wait, 在此之前，细心的各位想必已经注意到了题目中的一个需求，如果多种打歌顺序都可获得最大值的话，那么要输出字典序最小的方案。这个怎么解决呢？再细心看一下题目会发现每首歌在给出的时候已经强调按照字典序排好了，所以我们只需要把正序枚举 j from 1 to n 改成逆序枚举 j from n to 1，这样就可以保证在遇到字典序更小的最优解的时候替换掉当前解。<\\/p>\n<pre><code class=\"cpp\">    for (int i = 0; i &lt;= (1 &lt;&lt; n); i++)\n    {\n        for (int j = n; j &gt;= 0; j--)\n        {\n            int cur = 1 &lt;&lt; j;\n            if (i &amp; cur) {\n                int prev = i &amp; (~cur);\n                int getscore = rest[j] - curTime[prev] - cost[j];\n                if (getscore &lt; 0) {\n                    getscore = 0;     \\/\\/ 记得把不能得到分数的情况修改掉\n                }\n                \\/\\/ 注意这里的条件是 &lt;=，因为当得分相等的时候取字典序更小的更优\n                if (dp[i].score &lt;= dp[prev].score + getscore) {\n                    dp[i].score = dp[prev].score + getscore;\n                    dp[i].cur = j;\n                    dp[i].prev = prev;\n                }\n            }\n        }\n    }\n<\\/code><\\/pre>\n<p>最后我们顺着 <code>dp[(1 &lt;&lt; n) - 1]<\\/code> 的状态一路推回去输出方案。在此之前别忘了再判断一下 m 与 <code>dp[(1 &lt;&lt; n) - 1]<\\/code> 的大小关系。还有一个要注意的地方是输出顺序的问题，因为是从最后一个推回去的，但是应该从第一个输出到最后一个，所以这个时候做一个 DFS 或者丢进栈里就完美啦。<\\/p>\n<h1 id=\"附上蒟蒻的标程\"><a href=\"#附上蒟蒻的标程\" class=\"headerlink\" title=\"附上蒟蒻的标程\"><\\/a>附上蒟蒻的标程<\\/h1><pre><code class=\"cpp\">#include &lt;cstdio&gt; \n#include &lt;cstring&gt;\n#include &lt;stack&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\nconst int MAXS = (1 &lt;&lt; 24);\nconst int MAXN = 25;\n\nstruct State {\n    int cur;\n    int prev;\n    int score;\n};\nState dp[MAXS + 20];\n\nint n, m, t;\nint sum;\nint cost[MAXN], rest[MAXN];\nint curTime[MAXS + 20];\nchar name[MAXN][110];\n\nint main()\n{\n    memset(curTime, 0, sizeof curTime);\n    memset(dp, 0, sizeof dp);\n\n    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t);\n    for (int i = 0; i &lt; n; i++)\n    {\n        scanf(&quot;%s%d%d&quot;, name[i], &amp;cost[i], &amp;rest[i]);\n        sum += cost[i];\n    }\n\n    if (t &lt; sum) {\n        printf(&quot;No Answer&quot;);\n        return 0;\n    }\n\n    for (int i = 0; i &lt; (1 &lt;&lt; n); i++)\n    {\n        for (int j = n; j &gt;= 0; j--)\n        {\n            if (i &amp; (1 &lt;&lt; j)) {\n                continue;\n            }\n            int next = i | (1 &lt;&lt; j);\n            curTime[next] = curTime[i] + cost[j];\n        }\n    }\n\n    for (int i = 0; i &lt;= (1 &lt;&lt; n); i++)\n    {\n        for (int j = n; j &gt;= 0; j--)\n        {\n            int cur = 1 &lt;&lt; j;\n            if (i &amp; cur) {\n                int prev = i &amp; (~cur);\n                int getscore = rest[j] - curTime[prev] - cost[j];\n                if (getscore &lt; 0) {\n                    getscore = 0;\n                }\n                if (dp[i].score &lt;= dp[prev].score + getscore) {\n                    dp[i].score = dp[prev].score + getscore;\n                    dp[i].cur = j;\n                    dp[i].prev = prev;\n                }\n            }\n        }\n    }\n\n    int state = (1 &lt;&lt; n) - 1;\n\n    if (dp[state].score &gt;= m) {\n        printf(&quot;%d\\n&quot;, dp[state].score);\n    } else {\n        printf(&quot;No Answer&quot;);\n        return 0;\n    }\n\n    stack&lt;int&gt; S;\n    while (state != 0)\n    {\n        S.push(dp[state].cur);\n        state = dp[state].prev;\n    }\n\n    while (!S.empty())\n    {\n        int id = S.top();\n        S.pop();\n        printf(&quot;%s&quot;, name[id]);\n        if (!S.empty()) {\n            printf(&quot;\\n&quot;);\n        }\n    }\n\n    return 0;\n}\n<\\/code><\\/pre>\n",
      "excerpt": "<p>复赛在即，我们学校里面的四个撒币不知道是谁突发奇想，说要出一套模拟题。于是我们四个人分别出了一道要多恶心有多恶心的题= =本来嘛是要在学校内部自己测的，不过人太少，不好玩，于是就连夜 py 到洛谷上搞了公开赛。从早上 8 点到中午 12 点，虽然出了很多的锅，不过还是要记录一下我的第一次出题经历（<\\/p>",
      "slug": "my-first-contest-problem",
      "published": true,
      "layout": "post",
      "path": "blog/post/my-first-contest-problem/",
      "permalink": "https://kirainmoe.com/blog/post/my-first-contest-problem/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "algorithm",
          "slug": "algorithm",
          "path": "tags/algorithm/",
          "permalink": "https://kirainmoe.com/tags/algorithm/",
          "length": 8
        }
      ],
      "categories": []
    },
    {
      "title": "浅谈 KMP 字符串匹配算法",
      "date": "2017-10-17T05:01:43.000Z",
      "modified": "2018-01-07T05:18:28.578Z",
      "content": "<p>因为上周末 MFE 群里有位成员提到了这个算法，所以那天晚上就稍微认识了一下这个算法，感觉 KMP 对于匹配字符串上的做法还是好神奇的，值得水篇文章整理一下。<\\/p>\n<a id=\"more\"><\\/a>\n<blockquote>\n<p>很久没有更文了w 最近真的是非常非常非常忙qwq，刚刚送走了第二次阶段考就迎来了 NOIP 的初赛，然后接下来的一整个月都要在忙碌的准备中度过，11 月回来又是期中考qwq 所以你们会发现我的解题报告停更了半个月，这篇文章权当是补偿吧（ <\\/p>\n<\\/blockquote>\n<h1 id=\"KMP-算法\"><a href=\"#KMP-算法\" class=\"headerlink\" title=\"KMP 算法\"><\\/a>KMP 算法<\\/h1><blockquote>\n<p>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现，因此人们称它为克努特——莫里斯——普拉特操作（简称KMP算法）。KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个next()函数，函数本身包含了模式串的局部匹配信息。时间复杂度O(m+n)。<\\/p>\n<\\/blockquote>\n<p>以上摘自百科，这段话已经详尽地阐明了什么是 KMP 算法、它的应用场景和高效性的核心原因。下面就不再多做介绍了w。<\\/p>\n<h1 id=\"原始的字符串匹配方法\"><a href=\"#原始的字符串匹配方法\" class=\"headerlink\" title=\"原始的字符串匹配方法\"><\\/a>原始的字符串匹配方法<\\/h1><p>首先回忆一下，如果我们要匹配两个字符串，一般是怎么做的？我想大部分的人应该会想到这样的答案：<\\/p>\n<ul>\n<li>用两个下标指针 i, j 分别指向我们要匹配的目标字符串 (target) 和给我们的模式串 (pattern)。<\\/li>\n<li>从 i = 0 作为起点开始，如果 target[i] == pattern[j]，就一步一步向右移动 i, j 指针。<\\/li>\n<li>当 target[i] != pattern[j] 的时候，就让 i 的起点右移一位，让 j = 0.<\\/li>\n<li>重新开始尝试匹配，直到匹配成功（返回 target 与 pattern 匹配的起始为止）或者 i = target.length 时仍然没有结果为止（此时 target 与 pattern 不匹配，返回 -1）。<\\/li>\n<\\/ul>\n<p>当然，这样的方法确实是正确的说，但是我们还需要考虑<s>这个效率 efficiency<\\/s>。很明显这个方法的时间复杂度是 O(n*m) 的~ 要是数据量很大的话就可能会超时哟（<\\/p>\n<p>那么有没有什么好一点的方法来优化我们匹配两个字符串的方式呢？<\\/p>\n<h1 id=\"优化的思想\"><a href=\"#优化的思想\" class=\"headerlink\" title=\"优化的思想\"><\\/a>优化的思想<\\/h1><p>下文中，我们把目标串 target 记作 T, 模式串 pattern 记作 P. 首先，让我们考虑这样两个字符串：<\\/p>\n<pre><code>target (T): ABCABCABDAB\npattern(P): ABCABD\n<\\/code><\\/pre><p>我们用上面的方法匹配的时候，让 i = j = 0，然后当 T[i] == P[j] 的时候，我们不断让 i, j 右移，直到 i = j = 5 的时候，我们发现 T[i](C) != P[j](D) 了。<\\/p>\n<p>按照我们上面的思路，我们会把 i 和 j 回溯：<\\/p>\n<pre><code> ↓ i = 1\nABCABCABDAB\n ABCABD\n ↑ j = 0\n<\\/code><\\/pre><p>这时候第一个字符就不匹配了，所以 i 继续右移，直到 i = 3, j = 0 的时候往下匹配，最后 i = 8, j = 5 的时候匹配成功：<\\/p>\n<pre><code>   ↓ i = 3\nABCABCABDAB\n   ABCABD\n   ↑ j = 0\n\n......\n\n        ↓ i = 8\nABCABCABDAB\n   ABCABD\n        ↑ j = 5\n<\\/code><\\/pre><p>但是我们发现了一件有趣的事情，就是，如果这件事让我们人为来做的话，当 i, j 从 0 开始匹配到 5 失败的时候，我们不会让 i = 1, 2, … 这样一直试到匹配为止。<br>因为我们发现我们在 i = 5 的时候匹配失败，P[0] = A, 但是 i = 5 的前面只有 i = 3 的时候 T[i] = A，所以 i = 1, 2 的时候我们根本不需要去匹配。我们能这么想，是因为我们已经知道匹配过的 i = 0~5 的情况了——这也正是 KMP 算法的精髓所在，<strong>KMP 算法高效的原因之一正是由于它能够利用已经匹配到的有效信息。<\\/strong><\\/p>\n<p>所以呢，上面提到的三个人就想到了一个方案：i 指针可以不动呀，我们只要移动 j 指针就可以了。<\\/p>\n<pre><code>     ↓ i = 5\nABCABCABDAB\nABCABD\n     ↑ j = 5\n<\\/code><\\/pre><p>这个时候让 i 不动，只移动 j：<\\/p>\n<pre><code>     ↓ i = 5\nABCABCABDAB\n   ABCABD\n     ↑ j = 2\n<\\/code><\\/pre><p>哎，你会发现这样比一起移动 i 和 j 快多了，对吗？这就是 KMP 算法的思想：<\\/p>\n<blockquote>\n<p>利用已经部分匹配这个有效信息，保持 i 指针不回溯，通过修改 j 指针，让模式串尽量地移动到有效的位置。<\\/p>\n<\\/blockquote>\n<h1 id=\"KMP-算法的灵魂-——-j-指针移动的位置\"><a href=\"#KMP-算法的灵魂-——-j-指针移动的位置\" class=\"headerlink\" title=\"KMP 算法的灵魂 —— j 指针移动的位置\"><\\/a>KMP 算法的灵魂 —— j 指针移动的位置<\\/h1><p>但是有人会问，我们要怎么知道 j 指针移动到哪个地方才合适呢？因为 j 的下一个位置很关键，如果 j 的下一个位置太提前，那么这个想法无异于没有优化；如果太靠后，那么两个字符串就无法匹配了。所以 j 指针的下一个位置是很重要的。KMP 算法中，用一个叫 <strong>next 数组<\\/strong> 的东西来记录 j 指针的下一个位置。<\\/p>\n<p>next 数组也是 KMP 的难点所在。如果你觉得 next 数组的求解很难理解，这里有几篇文章可以辅助你理解；下面我也会理一下从这几篇文章里整理出来的比较容易理解的东西：<\\/p>\n<blockquote>\n<p><a href=\"http:\\/\\/www.cnblogs.com\\/yjiyjige\\/p\\/3263858.html\" target=\"_blank\" rel=\"external\">http:\\/\\/www.cnblogs.com\\/yjiyjige\\/p\\/3263858.html<\\/a><br><a href=\"http:\\/\\/blog.csdn.net\\/henuyx\\/article\\/details\\/44653799\" target=\"_blank\" rel=\"external\">http:\\/\\/blog.csdn.net\\/henuyx\\/article\\/details\\/44653799<\\/a><\\/p>\n<\\/blockquote>\n<p>我们用 k 表示当 T[i] 与 P[j] 不匹配的时候，j 要移动的下一个位置，则 next[j] = k. 现在你可以猜到，<strong>next[j] 存储的是：当 T[i] 与 P[j] 匹配失败时，j 将要移动的下一个位置。<\\/strong><\\/p>\n<p>我们还是举上面那个例子吧：<\\/p>\n<pre><code>ABCABD\n     ↑ j = 5，匹配失败\n\nABCABD\n  ↑ j = 2，把 j 移动到这个位置\n<\\/code><\\/pre><p>有没有发现什么？没错， P[0~1] 和 P[3~4] 是重合的！<\\/p>\n<p>再比如说：<\\/p>\n<pre><code>       ↓ i = 7\nABCDABCDNAIVE\nABCDABCB\n       ↑ j = 7\n<\\/code><\\/pre><p>这个时候又匹配失败了。虽然我们作为人类，很容易看出这两个字符串无论怎么移动都不能匹配。不过我们这个时候还是要<s>假装尝试一下<\\/s>，我们会这样移动 j 指针：<\\/p>\n<pre><code>移动前：\n       ↓ i = 7\nABCDABCDNAIVE\nABCDABCB\n       ↑ j = 7\n移动后：\n       ↓ i = 7\nABCDABCDNAIVE\n    ABCDABCB\n       ↑ j = 3\n<\\/code><\\/pre><p>哎，是不是还是刚才的那个规律呢，模式串的 P[0~2] 和 P[4~6] 是重合的，而恰恰又是 j 移动的位置 3 把它们隔开了。<\\/p>\n<p>现在我们可以总结出这样的性质了：<strong>当 T[i] 与 P[j] 匹配失败的时候，j 移动到下一个位置 k，k 即为使得 <code>P[0, k-1] = P[j-k, j-1] (或者说 P[k+1, j-1])<\\/code> 的那个值。<\\/strong><\\/p>\n<p>引用一下一篇文章的证明：<\\/p>\n<blockquote>\n<p>当T[i] != P[j]时<br>有T[i-j ~ i-1] == P[0 ~ j-1]<br>由P[0 ~ k-1] == P[j-k ~ j-1]<br>必然：T[i-k ~ i-1] == P[0 ~ k-1]<\\/p>\n<\\/blockquote>\n<p>进一步我们还可以发现，这个 k 的位置完全取决于模式串 P 自身的性质，与目标串 T 无关。所以我们就可以预处理计算出对于每一个 j 的 k 值了。就如我们刚才所说的我们把 k 存储在 next 数组当中，那么接下来我们就来计算 next 数组。<\\/p>\n<h1 id=\"next-数组的计算\"><a href=\"#next-数组的计算\" class=\"headerlink\" title=\"next 数组的计算\"><\\/a>next 数组的计算<\\/h1><p>先温习一下 next 数组的含义和作用：<\\/p>\n<blockquote>\n<p> next[j] 存储的是：当 T[i] 与 P[j] 匹配失败时，j 将要移动的下一个位置。<\\/p>\n<\\/blockquote>\n<p>接下来我们分类讨论一下：<\\/p>\n<ol>\n<li>当 j = 0 的时候，显然 j 已经不能再往前移动了，我们这个时候应该保持 j 不动，然后向右移动 i 指针继续匹配。所以我们让 next[0] = -1，告诉 KMP 主算法已经不能再移动 j 指针了。<\\/li>\n<li>当 j = 1 的时候，显然 j 只能移动到 0，所以 next[1] = 0.<\\/li>\n<li>那么其他情况呢？如果 P[j] = P[k] 的话，那么 next[j+1] = next[j] + 1.<\\/li>\n<li>最后一种情况就是 P[j] != P[k]，那么我们就让 k = next[k], 重复这个步骤直到符合上面三个条件之一为止。<\\/li>\n<\\/ol>\n<p>至于为什么这样做，这里主要介绍一下 3 和 4：<\\/p>\n<h3 id=\"为什么-P-j-P-k-的时候，next-j-1-next-j-1-呢？\"><a href=\"#为什么-P-j-P-k-的时候，next-j-1-next-j-1-呢？\" class=\"headerlink\" title=\"为什么 P[j] = P[k] 的时候，next[j+1] = next[j] + 1 呢？\"><\\/a>为什么 P[j] = P[k] 的时候，next[j+1] = next[j] + 1 呢？<\\/h3><p>考虑这样一个字符串：<\\/p>\n<pre><code>index 0 1 2 3 4 5 6 7 8\nstr   A B C D A B C D E\nnext -1 0 0 0 0 0 0 3 4\n<\\/code><\\/pre><p>通过计算我们可以发现 next[7] = 3, 因为 3 的左边和右边都是 ABC，这个时候我们发现 P[7] = P[3] = D.<\\/p>\n<p>所以，我们发现，当 j = j+1 = 8 之后，next[8] = 4 = next[7] + 1. 这个规律也是可以证明的。这个证明同样是引用：<\\/p>\n<blockquote>\n<p>因为在P[j]之前已经有P[0 ~ k-1] == p[j-k ~ j-1]。（next[j] == k）<br>这时候现有P[k] == P[j]，我们可以得到P[0 ~ k-1] + P[k] == p[j-k ~ j-1] + P[j]。<br>即：P[0 ~ k] == P[j-k ~ j]，即next[j+1] == k + 1 == next[j] + 1。<\\/p>\n<\\/blockquote>\n<h3 id=\"那-P-j-P-k-的时候呢？\"><a href=\"#那-P-j-P-k-的时候呢？\" class=\"headerlink\" title=\"那 P[j] != P[k] 的时候呢？\"><\\/a>那 P[j] != P[k] 的时候呢？<\\/h3><p>如果没有赋值的时候，next[j] 默认是等于 0 的，否则 k 就是上一次计算的 k 值。<br>这样，当 P[j] != P[k] 的时候，我们就一直让 k = next[k]，直到 k 符合上面的条件之一为止。<\\/p>\n<p>鉴于……这个东西我也讲不清楚qwq 所以我找到了一篇总结的挺好的文章：<a href=\"https:\\/\\/www.zhihu.com\\/question\\/21474082。\" target=\"_blank\" rel=\"external\">https:\\/\\/www.zhihu.com\\/question\\/21474082。<\\/a> 虽然内容不长，但是我就不贴过来了。<\\/p>\n<h2 id=\"那么，我们可以整理出计算-next-数组的整个过程了：\"><a href=\"#那么，我们可以整理出计算-next-数组的整个过程了：\" class=\"headerlink\" title=\"那么，我们可以整理出计算 next 数组的整个过程了：\"><\\/a>那么，我们可以整理出计算 next 数组的整个过程了：<\\/h2><pre><code>初始化 next[] = 0\nnext[0] ← -1\nj ← 0, k ← -1, len ← (pattern 长度 - 1)\nwhile j &lt; len do\n  if k = -1 || pattern[j] = pattern[k] then\n    j ← j+1, k ← k+1\n    next[j] = k\n  else\n    k ← next[k]\n<\\/code><\\/pre><p>下面是一个用 C++ 实现的方式：<\\/p>\n<pre><code class=\"cpp\">void calcNextArr()\n{\n  next[0] = -1;\n  int j = 0, k = -1, len = strlen(pattern) - 1;\n  while (j &lt; len)\n  {\n    if (k == -1 || pattern[j] == pattern[k]) {\n      next[++j] = ++k;\n      \\/\\/ 如果要做时间复杂度优化，就加上下面的代码\n      if (pattern[j] == pattern[k]) {\n        next[j] = next[k];\n      }\n    } else {\n      k = next[k];\n    }\n  }\n}\n<\\/code><\\/pre>\n<h2 id=\"优化-next-数组的求解\"><a href=\"#优化-next-数组的求解\" class=\"headerlink\" title=\"优化 next 数组的求解\"><\\/a>优化 next 数组的求解<\\/h2><p>注意到我们在实现上面的伪代码的时候多了两句：<\\/p>\n<pre><code class=\"cpp\">if (pattern[j] == pattern[k]) {\n  next[j] = next[k];\n}\n<\\/code><\\/pre>\n<p>为什么要加这一句呢？我们可以看出如果 P[j] = P[k] 的时候，让 next[j] = next[k]. 但是我们上文不是说到，如果 P[j] = P[k] 的时候，next[j+1] = next[j] + 1 嘛，为什么又回去了呐？考虑这样的一个模式串：<\\/p>\n<pre><code>ABCABDNAIVE\nABCABCABDAB\n     ↑ j = 5\n<\\/code><\\/pre><p>如上，当我们在 j = 5 的地方匹配失败的时候，按照我们上面的算法，next[j] = 2，所以 j 会回溯到 2 的地方，指向 C. 但是我们发现就算 j 回溯到 j = 2 的时候，P[j] 仍然等于 C，依旧不能和目标串匹配啊。所以我们还是要把 j 继续回溯，那么这时候 next[j] = 0. 相信大家想到了，只要我们让 j = 5 的时候直接跳回 0，就可以省去多跳一步的步骤了，这就是这段代码的作用。<\\/p>\n<h1 id=\"KMP-主算法\"><a href=\"#KMP-主算法\" class=\"headerlink\" title=\"KMP 主算法\"><\\/a>KMP 主算法<\\/h1><p>了解了 next[] 数组之后，你已经完全了解 KMP 不远了。 接下来是 KMP 算法的整个流程<br>：<\\/p>\n<pre><code>T ← 目标串，P ← 模式串\ni ← 0, j ← 0\nnext[] ← calcNext(P)                   \\/\\/ 对模式串 P 计算其 next 数组的值\nwhile i &lt; T.length &amp;&amp; j &lt; P.length do\n  \\/\\/ 如果 j 已经指向模式串的起点了，就把 i 下移一位，j 置零；或者 T[i] 和 P[j] 匹配了，那么就把 i, j 一起下移一位\n  if j == -1 || T[i] == P[j] then\n    i ← i+1, j ← j+1\n  \\/\\/ 如果不匹配，那就让 j 回溯到 next[j] 位置\n  else\n    j ← next[j]\nif j &gt;= P.length                  \\/\\/ 此时匹配成功\n  return i-j                      \\/\\/ i-j 即为 T 与 P 匹配时 T 串开始的位置\nelse\n  return -1                       \\/\\/ 否则返回不匹配，用 -1 表示\n<\\/code><\\/pre><p>仍旧是一份 C++ 实现的模板：<\\/p>\n<pre><code class=\"cpp\">int KMP()\n{\n  int i = 0, j = 0;\n  int tlen = strlen(target), plen = strlen(pattern);\n  while (i &lt; tlen &amp;&amp; j &lt; plen)\n  {\n    if (j == -1 || target[i] == pattern[j]) {\n      i++, j++;\n    } else {\n      j = next[j];\n    }\n  }\n\n  if (j == plen) {\n    return i - j;\n  } else {\n    return -1;\n  }\n}\n<\\/code><\\/pre>\n<h1 id=\"解决实际问题\"><a href=\"#解决实际问题\" class=\"headerlink\" title=\"解决实际问题\"><\\/a>解决实际问题<\\/h1><h2 id=\"HDU2087\"><a href=\"#HDU2087\" class=\"headerlink\" title=\"HDU2087\"><\\/a>HDU2087<\\/h2><p>地址在这里：<a href=\"http:\\/\\/acm.hdu.edu.cn\\/showproblem.php?pid=2087\" target=\"_blank\" rel=\"external\">http:\\/\\/acm.hdu.edu.cn\\/showproblem.php?pid=2087<\\/a><\\/p>\n<p>分析题目我们可以发现这就是一道简单的裸题字符串匹配，我们当然可以直接上 KMP 啦。下面是这题的 AC 代码：<\\/p>\n<pre><code class=\"cpp\">#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n\nconst int MAXN = 1e3 + 10;\nint n[MAXN];\nchar target[MAXN], pattern[MAXN];\n\nvoid init()\n{\n  memset(target, 0, sizeof target);\n  memset(pattern, 0, sizeof pattern);\n  memset(n, 0, sizeof n);\n}\n\nvoid calcNext()\n{\n  n[0] = -1;\n  int i = 0, k = -1, len = strlen(pattern) - 1;\n  while (i &lt; len)\n  {\n    if (k == -1 || pattern[i] == pattern[k]) {\n      n[++i] = ++k;\n      if (pattern[i] == pattern[k]) {\n        n[i] = n[k];\n      }\n    } else {\n      k = n[k];\n    }\n  }\n}\n\nint KMP()\n{\n  int ans = 0, i = 0, j = 0;\n  int tlen = strlen(target), plen = strlen(pattern);\n\n  while (i &lt; tlen)\n  {\n    if (j == -1 || target[i] == pattern[j]) {\n      i++, j++;\n    } else {\n      j = n[j];\n    }\n    if (j == plen) {\n      j = 0;\n      ans++;\n    }    \n  }\n  return ans;\n}\n\nint main()\n{\n  while (~scanf(&quot;%s&quot;, target))\n  {\n    if (target[0] == &#39;#&#39;)\n      break;\n    scanf(&quot;%s&quot;, pattern);\n    calcNext();\n    int ans = KMP();\n    printf(&quot;%d\\n&quot;, ans);\n    init();\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h2 id=\"luogu-3375\"><a href=\"#luogu-3375\" class=\"headerlink\" title=\"luogu 3375\"><\\/a>luogu 3375<\\/h2><p>这题也是个 KMP，可能有多个匹配，那么它要输出每个匹配的位置；以及这题的 next 数组不能优化，因为他还要输出= =我就是用了优化的 next 数组然后 WA 了好多次（<br>总之写起来大概像下面这样：<\\/p>\n<pre><code class=\"cpp\">#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nconst int MAXN = 1000050;\nint next[MAXN], n[MAXN];\nint len1, len2;\nchar target[MAXN], pattern[MAXN];\n\nvoid calcNext()\n{\n    int j = 0, k = -1;\n    next[0] = -1, n[0] = -1;\n    while (j &lt; len2)\n    {\n        if (k == -1 || pattern[j] == pattern[k]) {\n            next[++j] = ++k;\n            n[j] = k;\n            if (pattern[j] == pattern[k]) {\n                n[j] = n[k];\n            }\n        } else {\n            k = next[k];\n        }\n    }\n}\n\nvoid kmp()\n{\n    int i = 0, j = 0;\n    while (i &lt; len1)\n    {\n        if (j == -1 || target[i] == pattern[j]) {\n            i++, j++;\n        } else {\n            j = n[j];\n        }\n\n        if (j == len2) {\n            printf(&quot;%d\\n&quot;, i - j + 1);\n            j = n[j];\n        }\n    }\n}\n\nint main()\n{\n    scanf(&quot;%s%s&quot;, target, pattern);\n    len1 = strlen(target);\n    len2 = strlen(pattern);\n    calcNext();\n    kmp();\n    for (int i = 1; i &lt;= len2; i++)\n    {\n        printf(&quot;%d &quot;, next[i]);\n    }    \n    printf(&quot;\\n&quot;);\n    return 0;\n}\n<\\/code><\\/pre>\n<p>至此，我们对 KMP 的算法就有了一个比较完整的了解了。<\\/p>\n",
      "excerpt": "<p>因为上周末 MFE 群里有位成员提到了这个算法，所以那天晚上就稍微认识了一下这个算法，感觉 KMP 对于匹配字符串上的做法还是好神奇的，值得水篇文章整理一下。<\\/p>",
      "slug": "kmp-algorithm-for-matching-string",
      "published": true,
      "layout": "post",
      "path": "blog/post/kmp-algorithm-for-matching-string/",
      "permalink": "https://kirainmoe.com/blog/post/kmp-algorithm-for-matching-string/",
      "tags": [
        {
          "name": "algorithm",
          "slug": "algorithm",
          "path": "tags/algorithm/",
          "permalink": "https://kirainmoe.com/tags/algorithm/",
          "length": 8
        },
        {
          "name": "kmp",
          "slug": "kmp",
          "path": "tags/kmp/",
          "permalink": "https://kirainmoe.com/tags/kmp/",
          "length": 1
        }
      ],
      "categories": []
    }
  ],
  "menu": {
    "Home": "/",
    "Guestbook": "/pages/guestbook/",
    "Friends": "/pages/friends/",
    "About": "https://about.me/kirainmoe"
  },
  "socials": {
    "twitter": "https://twitter.com/yume_kankawa",
    "github": "https://github.com/kirainmoe",
    "weibo": "https://weibo.com/returnnnn",
    "medium": "https://medium.com/@kotori",
    "lastfm": "https://www.last.fm/user/kirainmoe"
  },
  "avatar": "https://secure.gravatar.com/avatar/c47187d311099868de825697fa419654?s=200&r=G",
  "menuIcon": {
    "Home": "home",
    "Guestbook": "book",
    "Friends": "users",
    "Archives": "tags",
    "About": "id-card-o"
  },
  "disqus": "yume-diary",
  "prev": 0,
  "next": 0
}</script>
  <!-- hook node of React -->
  <div id="himawari-app"></div>

  
    <!-- scripts list from theme config.yml -->
    
      <script src="https://unpkg.com/muse-player/dist/assets/muse-player.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/prism.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-clike.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-php.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-css.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-c.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-cpp.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-javascript.min.js"></script>
    
      <script src="/common.js"></script>
    
      <script src="/main.js"></script>
    
  

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-111347233-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-111347233-1');
  </script>

</body>
</html>
