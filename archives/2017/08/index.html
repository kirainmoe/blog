<!-- Himawari no Yakusoku -->

<!DOCTYPE html>
<html lang="Zh-cn">
<head>
  <meta charset="UTF-8">
  <meta name="theme-color" content="#FF98A8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Archives: 8/2017: 2017 [ YumeのDiary ]</title>
  <meta name="description" content="6 年間、共に歩んでくれたあなたへ。">
  <link rel="manifest" href="/manifest.json">
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    
      <link rel="stylesheet" href="/himawari.css">
    
  
</head>
<body>
  
  <!-- infos -->
  <script type="text/json" id="himawari-json">{
  "title": "YumeのDiary",
  "siteTitle": "YumeのDiary",
  "description": "6 年間、共に歩んでくれたあなたへ。",
  "author": "Yume Kankawa",
  "route": "year",
  "format": "blog/:layout/:title/",
  "posts": [
    {
      "title": "八月のif",
      "date": "2017-08-26T10:27:16.000Z",
      "modified": "2018-01-07T05:18:27.776Z",
      "content": "<p>炎夏的阳光在远处悠悠荡荡地摇曳<br>注视着西下的夕阳 心中无限遐思<br>倘若当初我们没有相遇相识<br>等待着我们的会是怎样的夏天呢<br><a id=\"more\"><\\/a><br>想象着 （这不一样的夏天）<br>大家追寻着 （各自的梦想）<br>可是真的会 变成那样吗<br>到底还是会 在某一天 走到一起的吧<\\/p>\n<p>这熠熠生辉的 八月的遐想<br>来探索这转瞬即逝的夏天的秘密吧<br>就这样下去 屏住呼吸就好<br>放弃那遐想吧 把当下紧紧拥入怀中吧<\\/p>\n<hr>\n<p><em>算下来已经很久没有在自己的博客里写过日记了。自从换了 Hexo 之后惊喜地发现某辣鸡爬虫站（对，就是那个叫什么推酷的）终于不爬我的文章了，所以就可以没有后顾之忧地在这里写一点什么乱七八糟的东西了。一直以来都认认真真并且很谨慎地在写博客的每一篇文章，是时候加点什么不一样的东西了。<\\/em><br>这个八月很快就要结束了。八月，对于很多孩子们来说大概是很令人享受的暑假时光，只不过这个八月对我来说似乎并没有什么特别的地方，除了过完这个月距离 2017 年高考倒计时又少了好几天罢了。<br>是的，过完这个八月，我就真的正式踏进高三的门了。所以从另一个角度来说，这也是我人生中意义最非凡的一个八月之一了吧。<br>过去的二十多天里经历了很多的事情。接踵而来的来自四面八方的打击，失去了陪伴自己很久的东西……以及其它无法一一列举的让人不愉快的事情。我大概就是那种只有在心情很糟糕的时候才会有想法的人，所以说每次情绪低落的时候，我都会想写点什么东西。有时候把自己的想法通过文字表达出来会让自己好受很多，但是自己的文笔又非常烂，以至于总是有时候心血来潮想到哪里写到哪里的时候突然就不知道往下要怎么动笔了，只好又把自己的那些负情绪咽回去。<\\/p>\n<hr>\n<p><div id=\"muse-container\"><\\/div><\\/p>\n<script type=\"text\\/javascript\">\n    var playlist = [{\n        title: '八月のif',\n        artist: 'Poppin\\'Party',\n        cover: 'https:\\/\\/dn-iidream.qbox.me\\/_20170820_081434.jpg',\n        src: 'https:\\/\\/dn-iidream.qbox.me\\/%E5%85%AB%E6%9C%88%E3%81%AEif-Poppin%20Party.mp3',\n        lyric: '[by:吟梦]\\n[00:20.58](香澄) 陽炎がゆらゆら揺れてる\\n[00:27.06]沈む太陽を見つめながら考えてた\\n[00:36.49](沙綾) 私達もしも出会えてなかったなら\\n[00:42.84]どんな夏が待っていたんだろう\\n[00:50.18](香澄) 違う夏\\n[00:52.43](沙綾) 探してた\\n[00:54.28](香澄) それぞれ\\n[00:56.29](香澄＆沙綾) 夢追いかけた\\n[00:58.53](香澄) でもホントに\\n[01:00.50](沙綾) そうなのかな\\n[01:02.19](香澄) やっぱりね\\n[01:04.20](沙綾) いつかは\\n[01:06.20](香澄＆沙綾) 出会ってたのかな\\n[01:10.66]煌めいた八月のif\\n[01:18.37](香澄) 短い夏の\\n[01:20.90](沙綾) 秘密捜し\\n[01:23.62](香澄＆沙綾) に行こうよ\\n[01:26.36](香澄＆沙綾) 息を止めてそのままでいて\\n[01:34.22](香澄) もしかじゃない\\n[01:35.71](沙綾) 今を\\n[01:37.38](香澄＆沙綾) 抱きしめている',\n        translation: '炎夏的阳光在远处悠悠荡荡地摇曳\\n注视着西下的夕阳 心中无限遐思\\n倘若当初我们没有相遇相识\\n等待着我们的会是怎样的夏天呢\\n想象着\\n这不一样的夏天\\n大家追寻着\\n各自的梦想\\n可是真的会\\n变成那样吗\\n到底还是会\\n在某一天\\n走到一起的吧\\n这熠熠生辉的 八月的遐想\\n来探索\\n这转瞬即逝的夏天的\\n秘密吧\\n就这样下去 屏住呼吸就好\\n放弃那遐想吧\\n把当下\\n紧紧拥入怀中吧'\n    }];\n    var player = MUSE.render(playlist, document.getElementById('muse-container'), {\n        layout: 'muse-layout-landscape'\n    });\n    MUSE.changeState(player.id, 'volume', 0.75);\n\n\n    function is_pc() {\n        var userAgentInfo = navigator.userAgent;\n        var Agents = [\"Android\", \"iPhone\",\n        \"SymbianOS\", \"Windows Phone\",\n        \"iPad\", \"iPod\"];\n        var flag = true;\n        for (var v = 0; v < Agents.length; v++) {\n            if (userAgentInfo.indexOf(Agents[v]) > 0) {\n                flag = false;\n                break;\n            }\n        }\n        return flag;\n    }\n\n    if (is_pc()) {\n        MUSE.togglePlay(player.id);\n    }\n<\\/script>\n\n<p>这是 《BanG Dream! OVA》 里的一首插曲《八月のif》，可以算是目前为止 Poppin’Party 的歌里我最喜欢的一首了，尽管还没有出完整版。<br>抛开作画崩什么的，真心觉得这部动漫 &amp; 企划不错。推 PPP 让我找到了刚开始推缪那一会的那种感觉，这也是我对<s>梦幻少女乐队<\\/s>这个企划评价很高的原因之一。也许有梦想之人的故事是最能打动人的了吧，无论是追逐那一束的光的穗乃果和 μ’s，还是幻想、仰望着星空的香澄和 popipa.<\\/p>\n<p>真正的梦想，应该就是像这样，哪怕是在别人眼中的再不切实际、再难以达成，也要咬紧牙关去尝试实现它的吧。这样的梦想不仅仅是一种单纯的利益驱动型的动力，更多的是一种信仰。<\\/p>\n<p>我？大概也有一个藏了很久的所谓“不切实际”的梦呢。<\\/p>\n<hr>\n<p>初中毕业快要三年，初中班级群总是安安静静的，最长的纪录是半年没人讲一句话，最后打破沉默的是同学的 QQ 号被盗之后群发的诈骗信息。今天，这个沉默了很久的群突然在会话列表里冒了出来。初中的班主任（之前也是从来不怎么说话的）发了一条信息。<\\/p>\n<p>她说，亲爱的同学们，你们已经是高三的学生了，大家要用自己的智慧和勤奋去走进人生的大礼堂。要杀出气魄，杀出豪迈。<br>看到她说的话那会儿我还是被震撼到了。震撼的不只是毕业三年她仍然记得我们，记得她当年带过的班级（当时我们那一届和她的关系确实还不错），我对其中一句话很有感触，宁可是不快乐的少年，也不要委曲求全的成年。<\\/p>\n<p>高三确实很累。有很多漏洞需要去修补，有很多东西需要去巩固，于此同时你还要继续接触和吸收很多新的内容，日复一日，直到第二年的六月，将会是一个很枯燥很无聊的过程。每每想到这将会是个很漫长的过程，就很想放弃。可是从另一个角度想，努力熬过这个漫长、无聊、“不快乐”的过程，总比明年委曲求全来的值得。这可能就是人为什么要把眼光放的远一点的原因吧，如果只图去追求眼前的片刻的安逸，将来真的会后悔和愧疚比这一段时间长不知道多少倍。<\\/p>\n<hr>\n<p>感觉自己度过了一个很奇葩的高中三年，比起班级里其他普通的高中同学来说我算是比较特殊的，因为过去的两年当中一直在“学业”和“竞赛”的两头徘徊。最终竞赛的结果大都不尽人意，倒是给我带来了一些很珍贵和难忘的经历。今年 11 月过后，算是可以抛开除了学业之外的全部的杂念了。也算是一种解脱吧。<br>自己的拖延症和总是把事情做一半就丢下的问题，是时候该改一改了。<br>总是觉得自己的时间不够用，也许是时候对自己的时间有更严格的规划了。<\\/p>\n<p>虽然身边的人都很理解很支持，但是无论周围的人怎样说“高三你不是一个人”，归根结底高三还是自己一个人的战役。无论是挑灯夜读还是最终坐在考场上的那个人都是你自己，不是其他任何一个人。<br>一定要学会适应这种孤独呢。<\\/p>\n<p>我有时候在想，我如果能像我对待和接触前端这么热忱，能像我写博客这么谨慎和一丝不苟去对待我的学习就好了。也许我真的应该这么尝试着做一下。<\\/p>\n<hr>\n<p>从六点半开始对着编辑器，想了很多事情，一直在删删改改，最后才发现把我脑子里那些零碎的感觉和想法拼凑出来也不过是篇连事情都讲不清楚的语无伦次日记。这一刻我有些犹豫要不要删掉这一篇乱七八糟毫无逻辑的日记，但是想了想我还是决定留下它。正如我说的那样，“博客是将我本人性格最真实地体现得最淋漓尽致的地方”。<\\/p>\n<p>好了，那就这样吧，反正没有人看。如果有人忍着各种吐槽耐心地看我说一堆废话读到这儿的话，那么希望你和我能在接下来的日子里努力朝着自己的梦想前行，让这个八月的遐想成为现实吧。<\\/p>\n<p>共勉。<\\/p>\n",
      "excerpt": "<p>炎夏的阳光在远处悠悠荡荡地摇曳<br>注视着西下的夕阳 心中无限遐思<br>倘若当初我们没有相遇相识<br>等待着我们的会是怎样的夏天呢<br>",
      "slug": "hachigatsu-no-if",
      "published": true,
      "layout": "post",
      "path": "blog/post/hachigatsu-no-if/",
      "permalink": "https://kirainmoe.com/blog/post/hachigatsu-no-if/",
      "tags": [
        {
          "name": "diary",
          "slug": "diary",
          "path": "tags/diary/",
          "permalink": "https://kirainmoe.com/tags/diary/",
          "length": 3
        },
        {
          "name": "life",
          "slug": "life",
          "path": "tags/life/",
          "permalink": "https://kirainmoe.com/tags/life/",
          "length": 1
        }
      ],
      "categories": []
    },
    {
      "title": "每周解题报告 (3rd, 8/14~8/20)",
      "date": "2017-08-20T06:43:46.000Z",
      "modified": "2018-01-07T05:18:35.157Z",
      "content": "<p>这周主要是尝试了一些新的东西（ 做了一些之前一直想看但是一直没看懂和没做的题目。依旧是做 HDU 的题。虽然写得不是很熟练，不过慢慢来应该也是可以的。<br>另外下周由于要阶段考试这样子，可能就没有时间做题目了。<\\/p>\n<a id=\"more\"><\\/a>\n<div class=\"muse-app\"><\\/div>\n\n<script type=\"text\\/javascript\">\nvar playList = [{\n    title: 'やくそく',\n    artist: '三森すずこ \\/ 花澤香菜',\n    src: 'https:\\/\\/api.kotori.love\\/netease\\/mp3?id=488256626',\n    cover: 'http:\\/\\/p1.music.126.net\\/9uq04GzHBnhhJCgQTccq_Q==\\/19012755067719433.jpg',\n    lyric: '[by:lyricshare]\\n[00:25.93]さよならじゃない今未来が始まるんだ\\n[00:37.23]淡い蕾は花開いて祝福を歌う\\n[00:48.93]秘密の場所に埋めたのは\\n[00:54.65]密かな夢と宝の地図\\n[01:00.94]時間巡りを閉じ込めた\\n[01:06.41]小さなガラスの欠片だった\\n[01:11.87]あの時 君は君は勇気を得た\\n[01:17.79]友を信じ抜く勇気を得た\\n[01:23.80]永遠に消えない誇りになるだろう\\n[01:29.83]最後の鐘が響き出す\\n[01:35.33]たとえ涙が落ちてしまうとしても\\n[01:41.03]下を向いたりしないと誓おう\\n[01:47.39]そっと重ねた思い出の数だけ\\n[01:53.20]光ゆらめいて背中を押した\\n[02:05.22]流れ続ける砂時計のような時よ\\n[02:16.67]翼広げてさあ飛び立とう地平線の果て\\n[02:28.44]あどけなかった横顔が\\n[02:34.10]凛々しくなったはいつの日か\\n[02:40.03]速まる日々に負けぬよう\\n[02:45.85]毎日夢中で追いかけてた\\n[02:51.57]あの時君は君は希望を見た\\n[02:57.28]暗闇に浮かぶ 希望を見た\\n[03:03.14]行き先照らす明かりになるだろう\\n[03:09.24]もう迷うことはないんだ\\n[03:14.94]いつか傷つくことがあるとしても\\n[03:20.64]友がくれた言葉を胸に\\n[03:27.03]傷を癒して進み続けるよ\\n[03:32.70]きっとその先でまた会えるから\\n[04:01.90]あの時君は君は勇気を得た\\n[04:07.50]友を信じ抜く勇気を得た\\n[04:13.36]永遠に消えない誇りになるだろう\\n[04:19.78]最後の鐘が響き出す\\n[04:24.82]たとえ 涙が落ちてしまうとしても\\n[04:30.82]下を向いたりしないと誓おう\\n[04:37.28]そっと重ねた思い出の数だけ\\n[04:42.95]光ゆらめいて背中を押した\\n[04:54.83]あのね ありがとう またあの場所で',\n    translation: '这并不是永别 未来从现在才开始\\n含苞待放的花蕾盛开 颂唱祝福之歌\\n在秘密场所里埋藏的是\\n潜藏于心的梦想与藏宝图\\n将反复的时间紧闭门中\\n化成了小小的玻璃碎片\\n那时候 是你让我获得了勇气\\n让我获得了坚信朋友的勇气\\n它会成为我永不消逝的骄傲吧\\n终结的钟声响起\\n让我们发誓 即便再流下眼泪\\n也不再低下头\\n只有那默默积累下的记忆\\n在虚渺的光芒中一直支持着我\\n时间仿佛不断流逝的沙漏\\n张开双翼 向着地平线的尽头翱翔吧\\n你那天真烂漫的侧脸\\n不知在何时已变得如此冷酷严峻\\n为了不输给忙碌的生活\\n每日都不顾一切地追赶\\n在那时 是你让我看见了希望\\n让我看见了在黑暗中浮现的希望\\n它会成为我通向终点的照明灯吧\\n我已经不会再次迷失自我了\\n即便在未来某刻会受伤\\n朋友托付于我的咒语 也会在我心中\\n治愈着我的伤痕 让我向前迈进\\n一定会在前方再次相遇吧\\n那时候 是你让我获得了勇气\\n让我获得了坚信朋友的勇气\\n它会成为我永不消逝的骄傲吧\\n终结的钟声响起\\n让我们发誓 即便再流下眼泪\\n也不再低下头\\n只有那默默积累下的记忆\\n在虚渺的光芒中一直支持着我\\n我想对你说 谢谢你 让我们再次在那个地方相遇吧'\n}];\n\nMUSE.render(playList, document.querySelector('.muse-app'));\n<\\/script>\n\n<h1 id=\"8-200-HDU5489-Removed-Interval\"><a href=\"#8-200-HDU5489-Removed-Interval\" class=\"headerlink\" title=\"8\\/200, HDU5489, Removed Interval\"><\\/a>8\\/200, HDU5489, Removed Interval<\\/h1><h2 id=\"题意-amp-扯淡\"><a href=\"#题意-amp-扯淡\" class=\"headerlink\" title=\"题意 &amp; 扯淡\"><\\/a>题意 &amp; 扯淡<\\/h2><p>题意就是已知一个数列，从中删除连续的 n 个数，然后要使得删除完之后它的最长上升子序列最大。n &lt;= 1e5.<\\/p>\n<p>这题好像有很多的解法，有用传统 LIS 做的，还有用 LIS + BIT 或者 LIS + Segment Tree 做的……后面两种做法没能理解（说实话，第一种做法也没怎么能理解），所以我还是硬着头皮看了一下直接做的。<\\/p>\n<h2 id=\"所谓题解\"><a href=\"#所谓题解\" class=\"headerlink\" title=\"所谓题解\"><\\/a>所谓题解<\\/h2><p>因为要从数列中删除一些数之后求 LIS，然后就是我们枚举删除的数的终点，然后对终点右边的第一个数为起点求一次 LIS<br>然后再从最左边到删除的起点求一次 <strong>最大的数不超过终点右边第一个数<\\/strong> 的 LIS<br>从右往左的这个 LIS 必须在枚举起点之前预处理求出，所以：<br>从右往左求 LIS 可以用负数的方法来做，然后倒着求回来，一直从 n 求到 l 为止。<\\/p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"><\\/a>代码<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nusing namespace std;\n\nconst int MAXN = 1e5 + 10;\nconst int INF = 1e9 + 7;\n\nint kases, tmp;\nint n, l;\nint a[MAXN], b[MAXN], dp[MAXN], LIS[MAXN];\n\nint main()\n{\n  scanf(&quot;%d&quot;, &amp;kases);\n\n  while (kases--)\n  {\n    tmp++;\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;l);\n\n    fill(dp, dp + MAXN, INF);\n\n    for (int i = 0; i &lt; n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;a[i]);\n      b[i] = -a[i];\n    }\n\n    \\/\\/ reverse LIS\n    int pos = 0;\n    fill(LIS, LIS + MAXN, INF);\n\n    for (int i = l; i &gt;= l; i--)\n    {\n      pos = lower_bound(LIS, LIS + n, b[i]) - LIS;\n      LIS[pos] = b[i];\n      dp[i] = pos + 1;\n    }\n\n    int ans = 0, maxlen = 0;\n    fill(LIS, LIS + MAXN, INF);\n    for (int i = l; i &lt; n; i++)\n    {\n      pos = lower_bound(LIS, LIS + n, a[i]) - LIS;      \\/\\/ from left to right\n      ans = max(ans, pos + 1 + dp[i] - 1);        \\/\\/ &gt;=\n\n      pos = lower_bound(LIS, LIS + n, a[i - l]) - LIS;    \\/\\/ update left LIS\n      LIS[pos] = a[i-l];\n      maxlen = max(maxlen, pos + 1);\n    }\n    ans = max(ans, maxlen);\n    printf(&quot;Case #%d: %d\\n&quot;, tmp, ans);\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"9-200-HDU1074-Doing-Homework\"><a href=\"#9-200-HDU1074-Doing-Homework\" class=\"headerlink\" title=\"9\\/200, HDU1074, Doing Homework\"><\\/a>9\\/200, HDU1074, Doing Homework<\\/h1><h2 id=\"扯淡\"><a href=\"#扯淡\" class=\"headerlink\" title=\"扯淡\"><\\/a>扯淡<\\/h2><p>DP，而且不是一般的 DP……是状压 DP 的说。这种 DP 也不是很好理解也很难想……主要还是要写题积累经验。算是我的第一道状压吧 QAQ，之前一直以为状压 DP 涉及各种二进制和位操作挺可怕的……看理论什么的也一直看不太懂。<\\/p>\n<h2 id=\"题解\"><a href=\"#题解\" class=\"headerlink\" title=\"题解\"><\\/a>题解<\\/h2><p>嘛……这是我有生以来写过的第一道状态压缩 DP 的题……第一眼看到 N &lt;= 15 就有种不好的预感 2333……<\\/p>\n<p>状态压缩嘛，就是把 DP 中用到的状态用二进制来表示，然后就这道题目理解了一下状态压缩 DP 的基本的写法，下面是我稍微总结的一下状态压缩 DP 的框架：<\\/p>\n<pre><code>const MAXN = 最大的状态点数目\nconst MAXS = 1 &lt;&lt; MAXN            \\/\\/ 最多的状态数，表示 2^MAXN 个\nvar dp[MAXS]                \\/\\/ DP 数组\n\nread n\n\nfor (i = 1...(1 &lt;&lt; n))            \\/\\/ 枚举每个用二进制表示的状态\n    for (j = 0....n)            \\/\\/ 枚举每一个点\n        var cur = 1 &lt;&lt; j        \\/\\/ 当前点用二进制表示后的整数\n    if (i &amp; cur)            \\/\\/ 判断当前状态是否合法，即当前枚举的状态 (i) 必须包含当前枚举的点 (cur)\n            var last = i - cur        \\/\\/ 这一步是可选的，如果你要获得当前状态的上一个状态\n                    \\/\\/ 那么可以用当前枚举的状态减去当前枚举的点的二进制状态\n\n            dp equation            \\/\\/ 那么现在就可以开始你的 DP 方程了\n\nprint dp[(1 &lt;&lt; n) - 1]            \\/\\/ 最终答案就是 dp[(1 &lt;&lt; n) - 1] 了\n<\\/code><\\/pre><p>然后说回到这一题上吧。题意就是某人要做好多的作业，每个作业有一个上交期限 deadline 和需要花费的时间 cost。如果每超过一天上交就扣一分，然后让你求出扣分最少的方案并输出字典序最小的方案。<\\/p>\n<p>由于最多只有 15 个状态点，那么用二进制表示这 15 个状态点的话，十进制的数不会超过 2^15 = 32768，所以我们想到用状压 DP 来解。那么，设整数 i 为用二进制表示了当前状态然后转换后的十进制数，然后我们就可以开一个数组 dp[1…MAXS] 来表示对于每个状态扣的分最少是多少，这里我们用二进制来表示状态，即用 0 来表示未完成这个作业，1 表示已完成这个作业。然后我们就可以从低位向高位填充来表示是否坐过这个作业了。<\\/p>\n<p>例如说有 5 门作业，你做了 第一门、第二门和第五门，那么用二进制表示就是 10011，然后转成十进制数就是 19.<\\/p>\n<p>我们用 i 枚举当前状态，然后再枚举一维 j 表示当前枚举的状态点（每一科的作业），当 i 状态包含了当前状态点的时候我们就可以根据我们的 DP 方程对 dp 数组进行更新。具体地，我们可以判断 i &amp; (1 &lt;&lt; j) 是否等于 1 的结果来看，如果等于 1 的话那么 i 状态就完成了第 j 门功课。<\\/p>\n<p>dp 方程如下（不要忘记转移的同时更新时间）：<\\/p>\n<pre><code>dp[i].score = dp[prev].score + max(dp[prev].time + lesson[j].cost - lesson[j].deadline, 0)\n<\\/code><\\/pre><p>我们记 curscore = 在完成第 j 门作业前的上一个状态（可以用 i - (1 &lt;&lt; j) 来求得上一个状态）已经花费掉的时间 + 做当前作业需要花费的时间 - 当前作业的 deadline，那么 curscore 有两种情况：1. 当 curscore &gt; 0 的时候，就是当前决策会被扣掉的分数；2. 当 curscore &lt;= 0 的时候，表明当前决策还不会被扣分，但是提早上交作业也不会加分，所以我们要把它设为 0.<\\/p>\n<p>然后呢看题目要求除了输出最小代价之外还要输出方案，那么我们可以用一个结构体来表示当个状态，除了记录代价 score 和所用时间 times 外还需要记录上一个状态 prev 和当前的科目 subject. 利用最终答案是 dp[(1 &lt;&lt; n) - 1] 这个性质，我们就可以通过 prev 回溯回去输出方案了，具体的做法就是从最终状态往前搜寻，并把它们加入一个栈中。然后你知道怎么做了。<\\/p>\n<p>还有一个要注意的地方就是边界处理，不然会无限 WA。<\\/p>\n<h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"><\\/a>代码<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \n\nusing namespace std;\n\nconst int MAXN = 15;\nconst int MAXS = 1 &lt;&lt; MAXN;\nconst int INF = 1e9 + 7;\n\nstruct Lesson {\n  int deadline;\n  int need;\n  char name[105];\n};\n\nstruct State {\n  int day;\n  int doing;\n  int score;\n  int previous;\n};\n\nLesson les[MAXN];\nState dp[MAXS];\n\nint cases;\nint n, l;\n\nint main()\n{\n  scanf(&quot;%d&quot;, &amp;cases);\n  while (cases--)\n  {\n    memset(dp, 0, sizeof(dp));\n\n    scanf(&quot;%d&quot;, &amp;n);\n\n    for (int i = 0; i &lt; n; i++)\n    {\n      cin &gt;&gt; les[i].name &gt;&gt; les[i].deadline &gt;&gt; les[i].need;\n    }\n\n    int terminal = 1 &lt;&lt; n;\n\n    \\/\\/ state-compressing\n    for (int i = 1; i &lt; terminal; i++)\n    {\n      dp[i].score = INF;\n      for (int j = n - 1; j &gt;= 0; j--)\n      {\n        int current = 1 &lt;&lt; j;\n        if (i &amp; current)\n        {\n          int prev = i - current;     \\/\\/ previous state\n          int score = dp[prev].day + les[j].need - les[j].deadline;\n          if (score &lt; 0)\n            score = 0;\n\n          int newState = score + dp[prev].score;\n          if (newState &lt; dp[i].score)\n          {\n            dp[i].score = newState;\n            dp[i].day = dp[prev].day + les[j].need;\n            dp[i].previous = prev;\n            dp[i].doing = j;\n          }\n        }\n      } \\/\\/ for j = n-1 =&gt; 0\n    } \\/\\/ for i = 1 =&gt; terminal\n\n    printf(&quot;%d\\n&quot;, dp[terminal - 1].score);\n\n    \\/\\/ print solutions\n    stack&lt;int&gt; solutions;\n    int cur = terminal - 1;\n    while (cur != 0)\n    {\n      solutions.push(dp[cur].doing);\n      cur = dp[cur].previous;\n    }\n\n    while (!solutions.empty())\n    {\n      printf(&quot;%s\\n&quot;, les[solutions.top()].name);\n      solutions.pop();\n    }\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"10-100-HDU3192-Hamburger-Magi\"><a href=\"#10-100-HDU3192-Hamburger-Magi\" class=\"headerlink\" title=\"10\\/100, HDU3192, Hamburger Magi\"><\\/a>10\\/100, HDU3192, Hamburger Magi<\\/h1><h2 id=\"题意-amp-扯淡-1\"><a href=\"#题意-amp-扯淡-1\" class=\"headerlink\" title=\"题意 &amp; 扯淡\"><\\/a>题意 &amp; 扯淡<\\/h2><p>第二道状压。具体的题意看题解吧，其实这些解题报告都是我把写完一题的时候 YY 出来的题解拼出来的，所以就不想浪费时间排版什么的了，看得懂找得到就行。<\\/p>\n<h2 id=\"题解-1\"><a href=\"#题解-1\" class=\"headerlink\" title=\"题解\"><\\/a>题解<\\/h2><p>感觉状态压缩的题目写的还是不太多，然后就没有那种感觉……不过经过上一题之后看到这道题就有些靠谱的思路了，虽然因为掉进了上一题的思维定式里然后 WA 了好几回 QAQ……<\\/p>\n<p>这一题的话，题意大概就是要做汉堡包，然后每个汉堡包有自己的价值 v（下文用 val 表示） 和制作所需要的能量 e（用 cost 表示），总共可以消耗的能量为 E. 再然后就是有些种类的汉堡包可能有“依赖”，也即在做他们之前需要有些汉堡包已经做好了。每种汉堡包最多做一个，然后综合上述条件，求出满足题意的最大价值 maxVal. 1 &lt;= n &lt;= 15.<\\/p>\n<p>老规律，看到 n &lt;= 15 就想到状态压缩 DP。这道题和上一题有个比较不一样的地方在于，上一题是根据当前枚举到的状态作为已知，而当前状态的先前一个状态未知，所以是从后向前推的；这道题是把当前枚举到的状态作为已知，当前状态的下一个状态未知，然后要从前向后推。<\\/p>\n<p>我们记 i 为当前汉堡种类的状态，用 j 表示下一个状态相较当前状态多做的汉堡种类，在 DP 之前我们先要判断条件是否合适。由于这题当中有一个“依赖”的概念，又有一个能量的限定，所以我们在判断 DP 状态是否合法的时候要注意一下。由于前一个“依赖”的限定是硬性的，也就是这个限制只能在我们 DP 下一个状态之前先判断当前状态能否推出下一个状态；但是对于“能量”这个限定就显得比较宽松，我们既可以边 DP 边剪枝，把所需能量大于总能量的解答直接剪掉；也可以暂时不剪掉，但是记录它们的花费（尽管有时候该花费已经超过了总能量），然后在 DP 完成之后循环一遍 dp 数组，这个时候就可以很方便地根据 dp[i].cost 来判断状态是否合法了，因为这个值已经固定下来不会改变了，所以我们可以在状态合法的前提下更新答案。网上的题解大致也分这两种写法，我觉得后面一种比较好理解也好写，所以我们用第二种做法。<\\/p>\n<p>至于判断依赖是否满足的话，我们遍历 j 的每一个依赖 deps[j][x]，如果 (i &amp; (1 &lt;&lt; j 的每一个依赖))，说明当前状态合法，可以由当前状态推向下一个状态；反之则不能从当前状态通过做第 j 个汉堡包达到下一个状态。<\\/p>\n<p>DP 方程如下，设 items[j] 为第 j 种汉堡的信息，i 为在 n 个不同的状态点的二进制状态转换成的十进制数，那么：<\\/p>\n<pre><code>dp[i | (1 &lt;&lt; j)].val = dp[i].val + items[j].val, dp[i | (1 &lt;&lt; j)].cost = dp[i].cost + items[j].cost;\n<\\/code><\\/pre><p>这里的 (1 &lt;&lt; j) 表示一个“只做当前枚举的第 j 个汉堡的二进制状态”，i 是当前状态，由于 (1 &lt;&lt; j) 二进制下只有第 j 位是 1 其他都是 0（注意这里 j 的下标是从 0 开始的），所以 i 与 1 &lt;&lt; j 按位或返回的结果就是下一个状态。<\\/p>\n<p>做完 DP 之后循环一遍 dp 数组更新 ans 就可以了： <code>ans = max(ans, dp[i].val), 其中 dp[i].cost &lt;= E.<\\/code><\\/p>\n<h2 id=\"代码-2\"><a href=\"#代码-2\" class=\"headerlink\" title=\"代码\"><\\/a>代码<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt;\nusing namespace std;\n\nconst int MAXN = 15;\nconst int MAXS = 1 &lt;&lt; 15;\nconst int INF = 1e9 + 7;\n\nstruct Hamburger {\n  int val;\n  int cost;\n  int dep;\n  int deps[15];\n};\nHamburger items[MAXN];\n\nstruct State {\n  int val;\n  int cost;\n};\nState dp[MAXS];\n\nint cases;\nint n, e;\n\nint main()\n{\n  scanf(&quot;%d&quot;, &amp;cases);\n\n  while (cases--)\n  {\n    memset(items, 0, sizeof(items));\n    memset(dp, -1, sizeof(dp));\n\n    scanf(&quot;%d%d&quot;, &amp;n, &amp;e);\n    for (int i = 0; i &lt; n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;items[i].val);\n    }\n    for (int i = 0; i &lt; n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;items[i].cost);\n    }\n    for (int i = 0; i &lt; n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;items[i].dep);\n      if (items[i].dep &gt; 0)\n      {\n        for (int j = 0; j &lt; items[i].dep; j++)\n        {\n          scanf(&quot;%d&quot;, &amp;items[i].deps[j]);\n          items[i].deps[j]--;\n        }\n      }\n    } \\/\\/ end read\n\n    int end = 1 &lt;&lt; n;\n    int ans = 0;\n\n    dp[0].cost = 0, dp[0].val = 0;\n\n    for (int i = 0; i &lt; end; i++)\n    {\n      if (dp[i].cost == -1)\n        continue;\n\n      for (int j = 0; j &lt; n; j++)\n      {\n        int cur = 1 &lt;&lt; j;\n        if (!(i &amp; cur))\n        {\n          int next = i | cur;\n\n          bool flag = true;\n          if (items[j].dep &gt; 0)\n          {\n            for (int x = 0; x &lt; items[j].dep; x++)\n            {\n              int depState = 1 &lt;&lt; items[j].deps[x];\n              if (!(i &amp; depState)) {\n                flag = false;\n                break;\n              }\n            } \\/\\/ for x = 0 -&gt; items[j].dep\n          } \\/\\/ if items[j].dep &gt; 0\n\n          if (flag)\n          {\n            dp[next].val = dp[i].val + items[j].val;\n            dp[next].cost = dp[i].cost + items[j].cost;\n          }\n\n        } \\/\\/ if i &amp; cur\n      } \\/\\/ for j = 0 -&gt; n\n    } \\/\\/ for i = 1 -&gt; end\n\n    for (int i = 0; i &lt; end; i++)\n    {\n      if (dp[i].cost &lt;= e)\n        ans = max(ans, dp[i].val);\n    }\n\n    printf(&quot;%d\\n&quot;, ans);\n\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"11-200-HDU1520-Anniversary-Party\"><a href=\"#11-200-HDU1520-Anniversary-Party\" class=\"headerlink\" title=\"11\\/200, HDU1520, Anniversary Party\"><\\/a>11\\/200, HDU1520, Anniversary Party<\\/h1><h2 id=\"题意-amp-扯淡-2\"><a href=\"#题意-amp-扯淡-2\" class=\"headerlink\" title=\"题意 &amp; 扯淡\"><\\/a>题意 &amp; 扯淡<\\/h2><p>树形 DP 入门题，是之前突然想学学树形 DP 的时候找到的。题意大概就是一个宴会上要邀请员工，每个员工都有一个开心指数，只有在宴会上见不到自己的直属上司的时候才会开心，然后要求出开心指数的最大值。<\\/p>\n<h2 id=\"题解-2\"><a href=\"#题解-2\" class=\"headerlink\" title=\"题解\"><\\/a>题解<\\/h2><p>这道题有个很坑的地方就是它一个样例有好多个子任务，但是它什！么！都！没！说！ <\\/p>\n<ul>\n<li>然后我交了 7 遍还是不知道为什么 WA 的……找了个 std 一看，卧槽要处理多组数据……<\\/li>\n<\\/ul>\n<p>设 dp[i][0] 为不邀请第 i 个人的最大值， dp[i][1] 为邀请第 i 个人的最大值。如果我们邀请了第 i 个人，那么我们就不能邀请第 i 个人的直接下属，但是他的直接下属的下属是可以邀请的……然后按照这个思路转移方程就出来了。<\\/p>\n<p>首先要建树，然后这里我采用的是用图的保存方法，直接用了 vector<int>[MAXN] 数组来存第 i 个人的直接下属。首先找到树根，也就是入度为 0 的（没有父亲或者说父亲是本身的）那个节点 Q，然后以此节点为起点做一遍 DFS，边 DFS 边状态转移，之后输出答案就好了。<\\/int><\\/p>\n<p>状态转移方程如下：<\\/p>\n<pre><code>dp[i][0] = max(dp[k1][0], dp[k1][1]) + ... + max(dp[kx][0], dp[kx][1])\n\\/\\/ 其中 k1 ... kx 是第 i 个员工的所有直属下属的下标\n\ndp[i][1] = dp[k1][0] + dp[k2][0] + ... + dp[kx][0]\n\\/\\/ 假如第 i 个员工要出席宴会，这种情况下他的直接下属都不能参加\n<\\/code><\\/pre><p>然后答案就是 <code>ans = max(dp[Q][0], dp[Q][1]);<\\/code>.<\\/p>\n<h2 id=\"代码-3\"><a href=\"#代码-3\" class=\"headerlink\" title=\"代码\"><\\/a>代码<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nusing namespace std;\n\nconst int MAXN = 6010;\nint n;\nint rate[MAXN], p[MAXN];\nint dp[MAXN][2];\nvector&lt;int&gt; T[MAXN];\n\nvoid dfs(int s)\n{\n  if (T[s].size() == 0)\n  {\n    dp[s][1] = rate[s];\n    dp[s][0] = 0;\n    return;\n  }\n\n  for (int i = 0; i &lt; T[s].size(); i++)\n  {\n    int cur = T[s][i];\n    dfs(cur);\n    dp[s][0] += max(dp[cur][1], dp[cur][0]);\n    dp[s][1] += dp[cur][0];\n  }\n  dp[s][1] += rate[s];\n  return;\n}\n\nint main()\n{\n  while (scanf(&quot;%d&quot;, &amp;n) != EOF)\n  {\n    memset(rate, 0, sizeof(rate));\n    memset(p, 0, sizeof(p));\n    memset(dp, 0, sizeof(dp));\n\n    for (int i = 0; i &lt;= MAXN; i++)\n    {\n      T[i].clear();\n    }\n\n    for (int i = 1; i &lt;= n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;rate[i]);\n    }\n\n    int x, y;\n    while (scanf(&quot;%d%d&quot;, &amp;x, &amp;y) != EOF &amp;&amp; x != 0 &amp;&amp; y != 0)\n    {\n      T[y].push_back(x);\n      p[x] = y;\n    }\n\n    int s;\n    for (int i = 1; i &lt;= n; i++)\n    {\n      if (p[i] == 0)\n      {\n        s = i;\n        break;\n      }\n    }\n\n    dfs(s);\n    int ans = max(dp[s][0], dp[s][1]);\n    printf(&quot;%d\\n&quot;, ans);    \n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"12-200-HDU1166-敌兵布阵\"><a href=\"#12-200-HDU1166-敌兵布阵\" class=\"headerlink\" title=\"12\\/200, HDU1166, 敌兵布阵\"><\\/a>12\\/200, HDU1166, 敌兵布阵<\\/h1><p>题意自己看原题吧 Orz 反正是中文的，这题用 BIT 和单点修改的线段树都可以做，是个裸的板子题。记一下这道题的板子代码以防将来需要。<\\/p>\n<h2 id=\"BIT-version\"><a href=\"#BIT-version\" class=\"headerlink\" title=\"BIT version\"><\\/a>BIT version<\\/h2><p>因为只有单点修改，所以用树状数组完全可以胜任。<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt;\n\nconst int MAXN = 50005;\nint n;\nint c[MAXN];\n\nint lowbit(int x)\n{\n  return x &amp; (-x);\n}\n\nvoid add(int i, int value)\n{\n  while (i &lt;= n)\n  {\n    c[i] += value;\n    i += lowbit(i);\n  }\n}\n\nint sum(int x)\n{\n  int res = 0;\n  while (x &gt; 0)\n  {\n    res += c[x];\n    x -= lowbit(x);\n  }\n  return res;\n}\n\nint main()\n{\n  int t;\n  scanf(&quot;%d&quot;, &amp;t);\n\n  for (int i = t; i &gt; 0; i--)\n  {\n    printf(&quot;Case %d:\\n&quot;, t - i + 1);\n    scanf(&quot;%d&quot;, &amp;n);\n    memset(c, 0, sizeof(c));\n\n    for (int j = 1; j &lt;= n; j++)\n    {\n      int x;\n      scanf(&quot;%d&quot;, &amp;x);\n      add(j, x);\n    }\n\n    char str[10];\n    int x, y;\n    while (scanf(&quot;%s&quot;, str) != EOF &amp;&amp; str[0] != &#39;E&#39;)\n    {\n      scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\n      if (str[0] == &#39;Q&#39;) {\n        int res = sum(y) - sum(x-1);\n        printf(&quot;%d\\n&quot;, res);\n      }\n\n      if (str[0] == &#39;A&#39;) {\n        add(x, y);\n      }\n\n      if (str[0] == &#39;S&#39;) {\n        add(x, -y);\n      }\n    }\n\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n<h2 id=\"Segment-Tree-version\"><a href=\"#Segment-Tree-version\" class=\"headerlink\" title=\"Segment Tree version\"><\\/a>Segment Tree version<\\/h2><p>线段树的单点修改区间查询版也可以做这题，如下。写起来会比树状数组的版本麻烦一些。记得一个很重要的地方就是线段树的数组要开到 MAXN 的 4 倍。<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nconst int MAXN = 50010;\n\nint n;\nint kases, tmp;\n\nstruct SegTree\n{\n  int sum[MAXN &lt;&lt; 2];\n\n  void pushUp(int root) \n  {\n    sum[root] = sum[root * 2] + sum[root * 2 + 1];\n  }\n\n  void build(int left, int right, int root)\n  {\n    if (left == right)\n    {\n      scanf(&quot;%d&quot;, &amp;sum[root]);\n      return;\n    }\n    int middle = (left + right) \\/ 2;\n    build(left, middle, root * 2);\n    build(middle + 1, right, root * 2 + 1); \n\n    pushUp(root);\n  }\n\n  void update(int left, int right, int root, int pos, int addVal)\n  {\n    if (left == right)\n    {\n      sum[root] += addVal;\n      return;\n    }\n    int middle = (left + right) \\/ 2;\n\n    if (pos &lt;= middle)\n    {\n      update(left, middle, root * 2, pos, addVal);\n    }\n    else\n    {\n      update(middle + 1, right, root * 2 + 1, pos, addVal);\n    }\n\n    pushUp(root);\n  }\n\n  int query(int from, int to, int left, int right, int root)\n  {\n    if (from &lt;= left &amp;&amp; right &lt;= to)\n    {\n      return sum[root];\n    }\n\n    int middle = (left + right) \\/ 2;\n\n    int res = 0;\n    if (to &lt;= middle)\n    {\n      res += query(from, to, left, middle, root * 2);\n    }\n    else if (from &gt; middle)\n    {\n      res += query(from, to, middle + 1, right, root * 2 + 1);\n    }\n    else\n    {\n      res += query(from, to, left, middle, root * 2) + query(from, to, middle + 1, right, root * 2 + 1);\n    }\n\n    return res;\n  }\n\n  void init()\n  {\n    for (int i = 0; i &lt; MAXN; i++)\n    {\n      sum[i] = 0;\n    }\n  }\n};\n\nSegTree tree;\n\nint main()\n{\n  scanf(&quot;%d&quot;, &amp;kases);\n\n  while (kases--) \n  {\n    tmp++;\n    printf(&quot;Case %d:\\n&quot;, tmp);\n\n    scanf(&quot;%d&quot;, &amp;n);\n\n    tree.init();\n    tree.build(1, n, 1);\n\n    char commands[20];\n    while (scanf(&quot;%s&quot;, commands) != EOF &amp;&amp; commands[0] != &#39;E&#39;)\n    {\n      if (commands[0] == &#39;Q&#39;)\n      {\n        int x, y;\n        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n\n        int res = tree.query(x, y, 1, n, 1);\n        printf(&quot;%d\\n&quot;, res);\n      }\n\n      if (commands[0] == &#39;A&#39;)\n      {\n        int x, y;\n        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n        tree.update(1, n, 1, x, y);\n      }\n\n      if (commands[0] == &#39;S&#39;)\n      {\n        int x, y;\n        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n        tree.update(1, n, 1, x, -y);\n      }\n    }\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n",
      "excerpt": "<p>这周主要是尝试了一些新的东西（ 做了一些之前一直想看但是一直没看懂和没做的题目。依旧是做 HDU 的题。虽然写得不是很熟练，不过慢慢来应该也是可以的。<br>另外下周由于要阶段考试这样子，可能就没有时间做题目了。<\\/p>",
      "slug": "practicing-record-3rd-8-14-8-20",
      "published": true,
      "layout": "post",
      "path": "blog/post/practicing-record-3rd-8-14-8-20/",
      "permalink": "https://kirainmoe.com/blog/post/practicing-record-3rd-8-14-8-20/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "algorithm",
          "slug": "algorithm",
          "path": "tags/algorithm/",
          "permalink": "https://kirainmoe.com/tags/algorithm/",
          "length": 8
        }
      ],
      "categories": []
    },
    {
      "title": "每周解题报告 (2nd, 8/7~8/13)",
      "date": "2017-08-13T08:46:17.000Z",
      "modified": "2018-01-07T05:18:34.286Z",
      "content": "<p>这一周主要在看 DP 的题目，嘛，都是一些我觉得很好<s>但是我写不出来的<\\/s>题。本周的话做的都是 HDU 的题，虽然看了一下 Codeforces 上的一两道这样子。感觉收获还是蛮多的。<\\/p>\n<a id=\"more\"><\\/a>\n<h1 id=\"偶然学到的黑科技\"><a href=\"#偶然学到的黑科技\" class=\"headerlink\" title=\"偶然学到的黑科技\"><\\/a>偶然学到的黑科技<\\/h1><p>在开始正式的记题之前，想先记一下这周做题和看题解的时候新学到的东西。<\\/p>\n<h2 id=\"STL-的-unique\"><a href=\"#STL-的-unique\" class=\"headerlink\" title=\"STL 的 unique()\"><\\/a>STL 的 unique()<\\/h2><p>STL 中提供了一个很方便的去重函数 unique(), 其功能是去除相邻的重复元素（只保留一个），所以使用前需要对数组进行排序。用 unique 之后对于有序数组就不用手动循环去重了。<\\/p>\n<h2 id=\"STL-lower-bound-和-upper-bound\"><a href=\"#STL-lower-bound-和-upper-bound\" class=\"headerlink\" title=\"STL lower_bound() 和 upper_bound()\"><\\/a>STL lower_bound() 和 upper_bound()<\\/h2><p>lower_bound(arr, arr + n, val) 返回在有序数组 arr 的 [0, n) 区间中的第一个不小于 val 的值的地址。<\\/p>\n<p>相反的，upper_bound(arr, arr + n, val) 则返回第一个不小于 val 的值的地址。<\\/p>\n<p>所以，我们可以利用这个好东西：<\\/p>\n<h2 id=\"四行写出最长上升子序列-LIS-的-O-nlogn-解法\"><a href=\"#四行写出最长上升子序列-LIS-的-O-nlogn-解法\" class=\"headerlink\" title=\"四行写出最长上升子序列 (LIS) 的 O(nlogn) 解法\"><\\/a>四行写出最长上升子序列 (LIS) 的 O(nlogn) 解法<\\/h2><p>LIS 的话，传统的写法是 O(n^2) 的，用二分优化过后可以降到 O(nlogn). 至于具体的原理我就不想详细在这里记录了，不然文章又要很长。<\\/p>\n<p>设 arr[] 为要求 LIS 的数列，lis[] 为保存 LIS 的数组。那么我们可以通过下面的代码来求 LIS：<\\/p>\n<pre><code class=\"cpp\">fill(lis, lis + n, INF);\nfor (int i = 0; i &lt; n; i++)\n    *lower_bound(lis, lis + n, arr[i]) = arr[i];\nint len = lower_bound(lis, lis + n, INF) - lis;            \\/\\/ LIS 的长度\n<\\/code><\\/pre>\n<p>简单快捷。<\\/p>\n<h1 id=\"4-200-HDU1024-Max-Sum-Plus-Plus\"><a href=\"#4-200-HDU1024-Max-Sum-Plus-Plus\" class=\"headerlink\" title=\"4\\/200, HDU1024, Max Sum Plus Plus\"><\\/a>4\\/200, HDU1024, Max Sum Plus Plus<\\/h1><h2 id=\"题意-amp-扯淡\"><a href=\"#题意-amp-扯淡\" class=\"headerlink\" title=\"题意 &amp; 扯淡\"><\\/a>题意 &amp; 扯淡<\\/h2><p>DP, 最大 m 子段和。没错题目很眼熟，是 P1003 的升级版，原题是最大连续子段和，这题是 n 子段和。是个挺不错的题目，之所以这么说是因为<s>我不会<\\/s>它的时间和空间限制挺严格的，尤其是空间限制是 32M….emmm….<\\/p>\n<p>题意还是给你一个很长的数列 a1….an，然后让你找出它的 m 个子序列使得这些子序列的总和最大，输出这个总和。1 &lt;= n &lt;= 1e6, m 的范围未知。注意就是求出的区间不能相交。<\\/p>\n<p>和上一题比一个比较人道的地方就是这一题不用输出位置了。但是反而比上一题更难了。看到 32M 的内存限制，反正你想到的不是正解的解法表示状态都需要二维，肯定就 GG 了。这道题的正解是用滚动数组优化，非常巧妙，<s>以至于我到现在还不是很理解。<\\/s><\\/p>\n<p>说的不太清楚，如果没明白的可以看看别人写的。直接从 notepad 复制过来的，不想理通顺了，凑合着看吧。<\\/p>\n<h2 id=\"开始正文\"><a href=\"#开始正文\" class=\"headerlink\" title=\"开始正文\"><\\/a>开始正文<\\/h2><p>虽然这道题的数据范围感人，n &lt;= 1e6, m 未知，内存 32M. 基本上告诉我们的信息就是二维的数组都开不下了，那么肯定要做一些黑科技的优化。但是这道题直接看正解是很难理解的，包括我现在看了正解还是有些地方不太明白，下面的解析是我按自己的理解 YY 的，可能有些地方并不一定对。<\\/p>\n<p>在正解之前，我们先来理解不做没优化的情况。如果抛开限制不谈，那么这道题的状态还是很好表示的。用 dp[i][j] 表示当子区间个数为 i，选取第 j 个数的时候的最大值。<\\/p>\n<p>对于 dp[i][j] 的值有两种决策：<\\/p>\n<p>1.将第 j 个数合并到第 i 个区间，区间个数不变，最大和为 dp[i][j-1]+a[j].<br>2.将第 j 个数单独划一个区间，此时区间个数由 i-1 变为 i，最大和为当区间长度为 i-1 的时候能取到的最大值 (也就是 dp[i-1][k]) 加上 a[j].<\\/p>\n<p>我们可以得到这样的状态转移方程：<\\/p>\n<pre><code>dp[i][j] = max(dp[i][j-1] + a[j], dp[i-1][k] + a[j]), 其中 k∈[i-1, j-1]\n<\\/code><\\/pre><p>也即<\\/p>\n<pre><code>dp[i-1][k] = max(dp[i-1][i-1], dp[i-1][i], ....., dp[i-1][j-1]).\n<\\/code><\\/pre><p>意思是，<strong>dp[i][j] 的取值只和 dp[i][j-1] 和 dp[i-1][k] 有关<\\/strong>。由于 i = 1 =&gt; m，那么我们事实上可以将数组降成两个一维的，也就是运用滚动数组来解这道题目：<\\/p>\n<p>设 d[j] 表示第 j 个数一定取的时候的最大值(dp[i][j])，premax[j] 表示 max(dp[i][i], …, dp[i][j])。那么原方程就可以化为 <code>dp[j] = max(dp[j-1] + a[j], premax[j-1] + a[j]);<\\/code><\\/p>\n<p>我们首先枚举区间的数量，用 curmax 表示当区间个数为 i 的时候能取得的最大值是多少，初始值为 -INF。<\\/p>\n<p>接着，我们枚举剩余的所有没有划分区间的数，每次枚举首先计算 dp[j]，然后再将 premax[j-1] 设为 curmax，然后更新 curmax 的值为 max(curmax, dp[j]). curmax 在这里的作用就相当于表示了 max(dp[i-1][i-1], …, dp[i-1][j-1])，我们可以利用滚动数组边 DP 边计算 curmax，然后把 curmax 更新给 premax 来保存. 全部计算完之后最后的结果就是最后一次更新后的 curmax 值了。<\\/p>\n<p>核心的伪代码如下：<\\/p>\n<pre><code>initialize curmax\nfor (i = 1 =&gt; m)\n    let curmax = -infinity\n    for (j = i =&gt; n)\n        calculate dp[j] = max(dp[j-1] + a[j], premax[j-1] + a[j])\n        update    premax[j-1] = curmax\n        update    curmax = max(dp[j], curmax)\nprint curmax\n<\\/code><\\/pre><h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"><\\/a>代码<\\/h2><pre><code class=\"cpp\">\\/**\n* HDU1024 DP 最大连续 m 区间和 \n*\\/\n#include &lt;bits\\/stdc++.h&gt;\nusing namespace std;\n\nconst int MAXN = 1e6 + 10;\nconst int INF = 1e9 + 7;\n\nint n, m;\nint a[MAXN];\nint dp[MAXN];\nint premax[MAXN];\n\nint main()\n{\n  while (scanf(&quot;%d%d&quot;, &amp;m, &amp;n) != EOF)\n  {\n    for (int i = 1; i &lt;= n; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;a[i]);\n    }\n\n    for (int i = 0; i &lt;= n; i++)\n    {\n      dp[i] = 0;\n      premax[i] = 0;\n    }\n\n         \\/\\/ start solution\n    int curmax;\n    for (int i = 1; i &lt;= m; i++)\n    {\n      curmax = -INF;\n      for (int j = i; j &lt;= n; j++)\n      {\n        dp[j] = max(dp[j-1] + a[j], premax[j-1] + a[j]);\n        premax[j-1] = curmax;\n        curmax = max(curmax, dp[j]);\n      }\n    }\n\n    printf(&quot;%d\\n&quot;, curmax);\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"5-200-HDU1028-Ignatius-and-the-Princess-III\"><a href=\"#5-200-HDU1028-Ignatius-and-the-Princess-III\" class=\"headerlink\" title=\"5\\/200, HDU1028, Ignatius and the Princess III\"><\\/a>5\\/200, HDU1028, Ignatius and the Princess III<\\/h1><h2 id=\"题意-amp-扯淡-1\"><a href=\"#题意-amp-扯淡-1\" class=\"headerlink\" title=\"题意 &amp; 扯淡\"><\\/a>题意 &amp; 扯淡<\\/h2><p>依旧是 DP，虽然传闻有母函数的做法，但是本蒟蒻不知道也不会写什么母函数。题意大概就是给你一个整数 n，然后你看看这个整数 n 有多少种划分方法，例如说:<\\/p>\n<blockquote>\n<p>4 = 4<br>  = 3 + 1<br>  = 2 + 2<br>  = 2 + 1 + 1<br>  = 1 + 1 + 1 +1<\\/p>\n<\\/blockquote>\n<p>所以 4 有 5 种划分方法。<\\/p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"><\\/a>正文<\\/h2><p>题意就是整数划分嘛，给定一个整数 n，求 n 有多少种分法，然后不能重复。<\\/p>\n<p>一开始都没想到是 DP 题……为什么可以用 DP 呢，一定是因为有重复计算的步骤啦。比如说我们要划分整数 4，把 4 划分到 3+1 的时候，显然 3 还能再往下划分，那么我们就可以直接利用之前已经计算过的结果了。<\\/p>\n<p>网上现成的 DP 题解大概有两种说法，但是状态转移方程是一样的。这个方程挺好写，但是不好想。<\\/p>\n<p>第一种解法是设 dp[i][j] 为将整数 i 划分为<strong>最多 j 个数的和<\\/strong>的时候最多的方案数量。我觉得这种方案不太好理解，尤其是分类讨论的时候。所以以下分析以第二种解法为基础：设 dp[i][j] 为将整数 i 划分为<strong>不超过 j 的数的和<\\/strong>的时候最多的方案数量。<\\/p>\n<p>  1) 显然，当 i = 1 的时候，区间长度只能是 1，那么只有一种方法，也即 dp[1][1] = 1.<\\/p>\n<p>  2) 当 i &lt; j 的时候，由于不可能出现“目标数是 i，但是 j(j &gt; i) 是 i 的一个加数”的情况，所以我们让 dp[i][j] = dp[i][i].<\\/p>\n<p>  3) 当 i = j 的时候，dp[i][j] = dp[i][j-1] + 1<\\/p>\n<p>   (1) 用不超过 j 的整数划分的时候，我们考虑是否要分出 j 这个数，如果要分的话由于 n = m 那么只有一种方案，就是 m 本身（对应状态转移方程中的 1），如果不分，那么就是继承 dp[i][j-1] 的结果，即把 i 分成最大加数不超过 j-1 的多少份。<\\/p>\n<p>  (2) 如果我们用第一种解法来理解这个式子，那么 dp[i][j] = 将 i 分成 j-1 段的方案数最大值 + 将 i 分成 j 段的方案数，由于 i = j，那么将 i 分成 j 段只有一种方案，就是有 j 个 1 的情况。<\\/p>\n<p>  4) 当 i &gt; j 的时候，也是最不好理解的一个部分。这个时候我们可以发现一个包含 i 个数的集合 U={1, 2, 3, …, i} 可以被 j 划分为两部分：一个是 A={j}，一个是 CU(A). 那么这个时候我们可以考虑是否要分出 j 这个数：如果要分出 j，那么我们只要计算剩下来的数的分离方案数，就是 dp[i-j][j]；如果不分，那么答案还是把 i 分成不超过 j-1 的结果，也就是 dp[i][j-1]. 将两种方案相加，我们得到了 dp[i][j] = dp[i-j][j] + dp[i][j-1];<\\/p>\n<p>“这样我们就完美地解决了这个问题。”<\\/p>\n<h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"><\\/a>代码<\\/h2><pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt;\nconst int MAXN = 120 + 5;\nint n;\nint dp[MAXN][MAXN];\n\nint main()\n{\n  while (scanf(&quot;%d&quot;, &amp;n) != EOF)\n  {\n    memset(dp, 0, sizeof(dp));\n    for (int i = 1; i &lt;= n; i++)\n    {\n      for (int j = 1; j &lt;= n; j++)\n      {\n        if (i &lt; j)\n        {\n          dp[i][j] = dp[i][i];\n        }\n        if (i == j)\n        {\n          dp[i][j] = dp[i][j-1] + 1;\n        }\n        if (i &gt; j)\n        {\n          dp[i][j] = dp[i][j-1] + dp[i-j][j];\n        }\n      }\n    }\n    printf(&quot;%d\\n&quot;, dp[n][n]);\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"6-200-HDU1025-Constructing-Roads-In-JGShining’s-Kingdom\"><a href=\"#6-200-HDU1025-Constructing-Roads-In-JGShining’s-Kingdom\" class=\"headerlink\" title=\"6\\/200, HDU1025 Constructing Roads In JGShining’s Kingdom\"><\\/a>6\\/200, HDU1025 Constructing Roads In JGShining’s Kingdom<\\/h1><p>还是 DP。懒得翻题意了，自己戳原链接看好了QAQ：<a href=\"http:\\/\\/acm.hdu.edu.cn\\/showproblem.php?pid=1025\" target=\"_blank\" rel=\"external\">http:\\/\\/acm.hdu.edu.cn\\/showproblem.php?pid=1025<\\/a><\\/p>\n<p>也就是在上文提到的最长上升子序列了，但是这一题的话用 O(n^2) 的解法是会 T 的。有两组数嘛，首先对一组排序（当然要保持和另外一组的对应关系），然后对另一组数做 LIS 就可以了。为什么是 LIS 自己画个图就知道了。<\\/p>\n<p>甚至可以，不用排序：在输入的时候只保存一组数据，而把另一组数作为数组的 key 即可，因为两组数是一一对应的，没有一对多的情况。<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt;\nusing namespace std;\n\nconst int MAXN = 5 * 1e5 + 10;\nconst int INF = 1e9 + 10;\n\nint n;\nint ans = 0, kases = 0;\nint maps[MAXN];\nint dp[MAXN];\nint LIS[MAXN];\nint main()\n{\n  while (scanf(&quot;%d&quot;, &amp;n) == 1)\n  {\n    kases++;\n\n    \\/\\/ read data\n    for (int i = 1; i &lt;= n; i++)\n    {\n      int x, y;\n      scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n      maps[x] = y;\n    }\n\n    \\/\\/ initialize\n    for (int i = 0; i &lt;= n; i++)\n    {\n      dp[i] = 0;\n      LIS[i] = INF;\n    }\n    dp[0] = 0;\n\n    \\/\\/ LIS\n    for (int i = 1; i &lt;= n; i++)\n    {\n      *lower_bound(LIS + 1, LIS + 1 + n, maps[i]) = maps[i];\n    }\n    ans = lower_bound(LIS + 1, LIS + 1 + n, INF) - LIS - 1;\n\n    printf(&quot;Case %d:\\n&quot;, kases);\n    printf(&quot;My king, at most %d &quot;, ans);\n    if (ans == 1)\n    {\n      printf(&quot;road can be built.\\n&quot;);\n    }\n    else\n    {\n      printf(&quot;roads can be built.\\n&quot;);\n    }\n    printf(&quot;\\n&quot;);\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n<p>以下是自己写的时候顺手 YY 的注释:<\\/p>\n<blockquote>\n<p>\\/**<\\/p>\n<ul>\n<li>附 nlogn 版的 LIS 写法：<\\/li>\n<li>设 LIS[MAXN] 为此数列的取得 LIS 最大值时的 LIS 一种可能的情况；<\\/li>\n<li>首先把 LIS 数组设为 INF：fill(LIS + 1， LIS + 1 + n, INF) ;<\\/li>\n<li>然后遍历数列，利用 lower_bound 函数二分查找到 LIS 中第一个不大于 a[i] 的值的位置 pos，<\\/li>\n<li>然后把 LIS[pos] 设为 a[i]. 也即 *lower_bound(LIS + 1, LIS + 1 , n, a[i]) = a[i];<\\/li>\n<li>最后统计 LIS 中不是 INF 的值的个数就可以了，即 ans = lower_bound(LIS + 1, LIS + 1 + n, INF);<br>*\\/<\\/li>\n<\\/ul>\n<\\/blockquote>\n<h1 id=\"6-1-HDU1029-Ignatius-and-the-Princess-IV\"><a href=\"#6-1-HDU1029-Ignatius-and-the-Princess-IV\" class=\"headerlink\" title=\"6.1, HDU1029, Ignatius and the Princess IV\"><\\/a>6.1, HDU1029, Ignatius and the Princess IV<\\/h1><p>之所以是 6.1 是因为这题实在是太。水。了。不是一般的水。要不是某个题目分类的帖子里说这题是 DP，我才不会做呢（<\\/p>\n<pre><code class=\"cpp\">\\/**\n* HDU1029 水题，谁说是 DP 的给我出来我保证打不死你 \n* 明明是这么简单的计数题！！ \n*\\/\n#include &lt;bits\\/stdc++.h&gt; \nconst int MAXN = 1e6 + 5;\nint data[MAXN];\nint main()\n{\n  int n, flag;\n  while (scanf(&quot;%d&quot;, &amp;n) != EOF)\n  {\n    bool state = true;\n    flag = (n + 1) \\/ 2;\n\n    memset(data, 0, sizeof(data));\n\n    for (int i = 0; i &lt; n; i++)\n    {\n      int x;\n      scanf(&quot;%d&quot;, &amp;x);\n      data[x]++;\n      if (data[x] &gt;= flag &amp;&amp; state)\n      {\n        printf(&quot;%d\\n&quot;, x);\n        state = false;\n      }\n    }\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"6-5-200-HDU1232-畅通工程\"><a href=\"#6-5-200-HDU1232-畅通工程\" class=\"headerlink\" title=\"6.5\\/200, HDU1232, 畅通工程\"><\\/a>6.5\\/200, HDU1232, 畅通工程<\\/h1><p>畅通工程系列的第一题，这是一道裸的并查集 OvO. 只要理解并查集的都会写啦。题目有个“温馨提示”，但是并不影响我们做题，管他什么多条道路连接的输入合不合法呢。<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \n\nconst int MAXN = 1e3 + 10;\nint p[MAXN];\nint n, m;\nint cnt = 0;\n\nvoid init()\n{\n  cnt = 0;\n  for (int i = 0; i &lt; MAXN; i++)\n  {\n    p[i] = i;\n  }\n}\n\nint find(int x)\n{\n  return x == p[x] ? x : p[x] = find(p[x]);\n}\n\nvoid unions(int x, int y)\n{\n  int px = find(x),\n      py = find(y);\n  if (px == py)\n  {\n    return;\n  }\n  else\n  {\n    p[px] = py;\n    cnt++;\n  }\n}\n\nint main()\n{\n  while (scanf(&quot;%d&quot;, &amp;n) != EOF &amp;&amp; n != 0)\n  {\n    init(); \n    scanf(&quot;%d&quot;, &amp;m);\n    for (int i = 0; i &lt; m; i++)\n    {\n      int x, y;\n      scanf(&quot;%d%d&quot;, &amp;x, &amp;y);\n      unions(x, y);\n    }\n    printf(&quot;%d\\n&quot;, (n - 1 - cnt));\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<p>剩下的是一些旧题重做的，然后就不贴上来了。<\\/p>\n",
      "excerpt": "<p>这一周主要在看 DP 的题目，嘛，都是一些我觉得很好<s>但是我写不出来的<\\/s>题。本周的话做的都是 HDU 的题，虽然看了一下 Codeforces 上的一两道这样子。感觉收获还是蛮多的。<\\/p>",
      "slug": "practicing-record-2nd-8-7-8-13",
      "published": true,
      "layout": "post",
      "path": "blog/post/practicing-record-2nd-8-7-8-13/",
      "permalink": "https://kirainmoe.com/blog/post/practicing-record-2nd-8-7-8-13/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "algorithm",
          "slug": "algorithm",
          "path": "tags/algorithm/",
          "permalink": "https://kirainmoe.com/tags/algorithm/",
          "length": 8
        }
      ],
      "categories": []
    },
    {
      "title": "每周解题报告 (1st, 8/3~8/6)",
      "date": "2017-08-07T04:49:06.000Z",
      "modified": "2018-01-07T05:18:33.532Z",
      "content": "<p>RT. 接下来打算在 11 月份之前刷个 200 题的算法题（包括线上和线下）……然后想着就是开个帖子来整理和记录题解什么的，大概能碰到电脑的话那就每周一篇这样子。<\\/p>\n<p>这一阶段的话主要是挑 <a href=\"http:\\/\\/acm.hdu.edu.cn\\/\" target=\"_blank\" rel=\"external\">HDUOJ<\\/a> 的题目来做（因为可以找到详细的题目分类），会从简单的题目开始（<s>比如 A+B Problem<\\/s>），然后辅以一些 Codeforces 的题。之前那个 LeetCode 的记录帖就这么弃坑了（<\\/p>\n<a id=\"more\"><\\/a>\n<h1 id=\"1-200-HDU1003-Max-Sum\"><a href=\"#1-200-HDU1003-Max-Sum\" class=\"headerlink\" title=\"1\\/200, HDU1003, Max Sum\"><\\/a>1\\/200, HDU1003, Max Sum<\\/h1><p>题意大概是给一个很长的数列，有正有负，然后要求这个数列的子序列的和的最大值。然后范围大概是 1e5 以内。有个比较迷的地方就是不仅要求最大值，而且还要求出取得最大值的时候，子区间的位置。时间 1s, 内存 64M.<\\/p>\n<p>第一反应是不是区间 DP 的题啊，然后看了一下数据范围果断把这个白痴的想法扔回肚子里去了。子序列最大值倒是会求啊，但是一开始没有反应过来要怎么统计位置。后来想了一下，开不下二维数组那我开一维的总可以了吧。所以这就是一道最大连续子区间和的动态规划问题了。<\\/p>\n<p>设 <code>dp[i]<\\/code> 表示以 <code>a[i]<\\/code> 为区间终点时能取到的和的最大值，然后开两个辅助数组 <code>left[i]<\\/code> 和 <code>right[i]<\\/code> 来表示当取到这个最大值的时候的区间左界和右界分别在哪里，然后最后 for 一遍统计最大值就做完了。需要注意这里一个地方就是数据可正可负，那么考虑一种情况就是假设 <code>dp[i-1]<\\/code> 小于 0 的时候，那么无论 <code>a[i]<\\/code> 是正数还是负数，显然只取 <code>a[i]<\\/code> 的结果会比取 <code>d[i-1] + a[i]<\\/code> 的结果更优，所以遇到这种情况就要重置一下区间的左右界。<\\/p>\n<p>还有一个要注意的地方就是输出的格式，当时做的时候各种 PE……<\\/p>\n<p>转移方程为 <code>dp[i] = max(dp[i-1] + a[i], a[i])<\\/code>.<\\/p>\n<p>Code:<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nconst int INF = 1e9 + 7;\nconst int MAXN = 1e5 + 10;\n\nint n, sn;\nint a[MAXN];\nint dp[MAXN];\nint left[MAXN], right[MAXN];\n\nvoid init()\n{\n  for (int i = 0; i &lt; MAXN; i++)\n  {\n    dp[i] = -INF;\n    left[i] = 0;\n    right[i] = 0;\n  }\n}\n\nint main()\n{\n  scanf(&quot;%d&quot;, &amp;n);\n  sn = n;\n\n  int tmp = 1;\n  while (sn--)\n  {\n    printf(&quot;Case %d:\\n&quot;, tmp++);\n    init();\n\n    int num;\n    scanf(&quot;%d&quot;, &amp;num);\n    for (int i = 0; i &lt; num; i++)\n    {\n      scanf(&quot;%d&quot;, &amp;a[i]);\n    }\n\n    dp[0] = a[0], left[0] = 0, right[0] = 0;\n    for (int i = 1; i &lt;= num; i++) \n    {\n      \\/\\/ 遇到负数的时候重新计数 \n      if (dp[i-1] &lt; 0)\n      {\n        left[i] = right[i] = i;\n        dp[i] = a[i];\n        continue;\n      }\n\n      dp[i] = dp[i-1] + a[i];\n      left[i] = left[i-1];\n      right[i] = i;\n    }\n\n    int maximum = -INF;   \\/\\/ 维护最大值\n    int l, r;\n    for (int i = 0; i &lt; num; i++) \n    {\n      if (dp[i] &gt; maximum)\n      {\n        maximum = dp[i];\n        l = left[i], r = right[i];\n      }\n    }\n\n    printf(&quot;%d %d %d\\n&quot;, maximum, l+1, r+1);\n\n    if (tmp-1 != n)\n      printf(&quot;\\n&quot;);\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"2-200-HDU1004-Let-the-Balloon-Raise\"><a href=\"#2-200-HDU1004-Let-the-Balloon-Raise\" class=\"headerlink\" title=\"2\\/200, HDU1004, Let the Balloon Raise\"><\\/a>2\\/200, HDU1004, Let the Balloon Raise<\\/h1><p>题意就是已知有 n 个气球和它们的颜色，然后要问最受欢迎的气球（也就是出现次数最多的颜色种类）是哪个，颜色用字符串表示且长度不超过 15，有多个子任务，且对于每个子任务保证只有一个合法答案。<\\/p>\n<p>嘛，简单的字符串计数嘛。这个用什么方法达到都可以的，你开心就好了。在这里我是用一个奇怪的做法，首先用 STL 的 string 保存每个气球的颜色，然后再按字典序用 <code>sort()<\\/code> 排序一下，最后就可以很方便地统计出出现次数最多的那种气球来了。<\\/p>\n<p>Code:<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nusing namespace std;\nconst int MAXN = 1010;\nstring balloons[MAXN];\nint main()\n{\n  int num;\n  int maximum, tmp, handle;\n\n  while (scanf(&quot;%d&quot;, &amp;num) != EOF &amp;&amp; num != 0)\n  { \n    for (int i = 0; i &lt; num; i++)\n    {\n      cin &gt;&gt; balloons[i];\n    }\n    sort(balloons, balloons + num);\n\n    maximum = 0, tmp = 0, handle = 0;\n    for (int i = 1; i &lt; num; i++)\n    {\n      if (balloons[i] != balloons[i-1])\n      {\n        tmp = 1;\n      }\n      else\n      {\n        tmp++;\n      }\n\n      if (tmp &gt; maximum)\n      {\n        maximum = tmp;\n        handle = i;\n      }\n    }\n    cout &lt;&lt; balloons[handle]  &lt;&lt; endl;\n  }\n\n  return 0;\n}\n<\\/code><\\/pre>\n<h1 id=\"3-200-HDU1005-Number-Sequence\"><a href=\"#3-200-HDU1005-Number-Sequence\" class=\"headerlink\" title=\"3\\/200, HDU1005, Number Sequence\"><\\/a>3\\/200, HDU1005, Number Sequence<\\/h1><p>题意是对于一个函数 f(n), 满足 f(1) = 1, f(2) = 1, f(n) = (A <em> f(n-1) + B <\\/em> f(n-2)) % 7, 然后求对于给定的 A, B 和 N, f(N) 的值是多少。1 &lt;= n &lt;= 1e8, 有多个子任务。<\\/p>\n<p>看数据范围我想没人敢一个一个算过去吧……而且还有好多个子任务，直接就 T 了。<\\/p>\n<p>这题的话一看我就猜到是递推……手推了 7 个之后发现好像没有什么规律……开始怀疑人生.jpg 后来才知道，因为结果要模 7，那么对于 f(n-1) 有 7 种可能的值 (0-6)，对于 f(n-2) 也是有 7 种可能的值，那么 f(n-1) 和 f(n-2) 一共有 7^2=49 种不同的组合可能，也就是最多 49 次就会出现一个循环节……找到循环节，接下来就可以直接算 f(N) 了，然后就做完了。<\\/p>\n<p>做的时候不知道为啥各种 RE，把计算输出的那部分改了一下就 AC 了。<\\/p>\n<pre><code class=\"cpp\">#include &lt;bits\\/stdc++.h&gt; \nint arr[55];\nint main()\n{\n  arr[0] = 1, arr[1] = 1;\n\n  int a, b, n;\n  int pot = 0;\n  while (scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;n) != EOF &amp;&amp; n != 0)\n  {\n    int pot;\n    for (int i = 2; i &lt;= 54; i++)\n    {\n      arr[i] = (a * arr[i-1] + b * arr[i-2]) % 7;\n      if (arr[i] == 1 &amp;&amp; arr[i-1] == 1)\n      {\n        pot = i;\n        break;\n      }\n    }\n\n    n = n % (pot-1);\n\n    if (n == 0)\n    {\n      printf(&quot;%d\\n&quot;, arr[pot-2]);\n    }\n    else\n    {\n      printf(&quot;%d\\n&quot;, arr[n-1]);\n    }\n  }\n  return 0;\n}\n<\\/code><\\/pre>\n",
      "excerpt": "<p>RT. 接下来打算在 11 月份之前刷个 200 题的算法题（包括线上和线下）……然后想着就是开个帖子来整理和记录题解什么的，大概能碰到电脑的话那就每周一篇这样子。<\\/p>\n<p>这一阶段的话主要是挑 <a href=\"http:\\/\\/acm.hdu.edu.cn\\/\">HDUOJ<\\/a> 的题目来做（因为可以找到详细的题目分类），会从简单的题目开始（<s>比如 A+B Problem<\\/s>），然后辅以一些 Codeforces 的题。之前那个 LeetCode 的记录帖就这么弃坑了（<\\/p>",
      "slug": "practicing-record-1st-8-3-8-6",
      "published": true,
      "layout": "post",
      "path": "blog/post/practicing-record-1st-8-3-8-6/",
      "permalink": "https://kirainmoe.com/blog/post/practicing-record-1st-8-3-8-6/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "algorithm",
          "slug": "algorithm",
          "path": "tags/algorithm/",
          "permalink": "https://kirainmoe.com/tags/algorithm/",
          "length": 8
        }
      ],
      "categories": []
    },
    {
      "title": "一次搭建内部 Online Judge 及调优的笔记",
      "date": "2017-08-05T13:05:18.000Z",
      "modified": "2018-01-07T05:18:32.715Z",
      "content": "<p>嗯，就是搭 OJ 这破事把我拽进了 Python 和 docker 的大坑中……<br>为了给本校 OI 学员的交流和练(gao)习(shi)提供条件，便有了搭建 OJ 的这么一个想法。以前一直以为这种事情就和装个 WordPress 什么的差不多嘛，真正跳进去才发现，woc 这水居然这么深。<br>关于 OJ 的选择，这里我用的是青岛大学 (QingdaoU) 的开源项目 <a href=\"https:\\/\\/github.com\\/QingdaoU\\/OnlineJudge\" target=\"_blank\" rel=\"external\">qduoj<\\/a>。<\\/p>\n<a id=\"more\"><\\/a>\n<p>之所以选 qduoj 呢是因为<s>好看<\\/s>这个 OJ 的架构比较让人满意，网页端采用了 Python Django，判题端的沙箱做得还可以，然后整个项目跑在 docker 中，可以最大限度地减少对宿主机留下的后遗症，以及在判题方面有更高的安全保障。<\\/p>\n<p>我是在一台 Xeon E3 的 ThinkServer 上部署的 Online Judge，操作系统是 Arch Linux, 运行截至写本文之日最新版的 docker. 这个环境可以供各位参考一下，<s>毕竟 Arch Linux 大法好<\\/s>.<\\/p>\n<h1 id=\"Installation\"><a href=\"#Installation\" class=\"headerlink\" title=\"Installation\"><\\/a>Installation<\\/h1><p>部署之前，先按照项目 README 中的一步一步走就是了。项目需要 docker 和 docker-compose，由于我用的是 Arch，所以通过下面的命令安装依赖：<\\/p>\n<pre><code class=\"shell\"># pacman -S git python-pip docker docker-compose\n<\\/code><\\/pre>\n<p>安装完之后我们启动 docker 服务：<\\/p>\n<pre><code class=\"shell\"># systemctl start docker\n<\\/code><\\/pre>\n<p>然后就是把项目克隆到本地，这一步就不多说了，然后接下来是关键的一步，同时也是这个项目的第一个坑：<\\/p>\n<p>首先我们来看看原文 (README) 中是怎么说的：<\\/p>\n<blockquote>\n<p>启动服务：运行 docker-compose up -d ，不需要其他的步骤，大约一分钟之后 web 界面就可以访问了，默认开放80和443端口。其中443端口是自签名证书。<\\/p>\n<p>这就结束了：超级管理员用户名是root，默认密码是password@root，请及时修改。登录\\/admin，添加一个判题服务器，地址为judger，端口为8080，密码是上面自定义的rpc_token。修改custom_settings.py可以自定义站点信息。<\\/p>\n<\\/blockquote>\n<p>天真的我照做了，然后一切正常，打开浏览器访问 <a href=\"http:\\/\\/localhost\\/\" target=\"_blank\" rel=\"external\">http:\\/\\/localhost\\/<\\/a> ，然后喜闻乐见地 connection reset 了。对于一个对 docker 和 python 一窍不通的萌新来说，没有什么比用当场懵逼形容更合适不过的了……<\\/p>\n<p>于是翻 issues, 查找 docker 的玩法，调出了 oj_web_server 这个容器的 log，从 log 中发现找不到 WEBSITE_INFO 的 attribute，WEBSITE_INFO 在 custom_settings.py 当中有定义，初步推断应该是容器内的 django 读不到放在容器外的 custom_settings.py.<\\/p>\n<p>然后打开 docker-compose.yml 一看，似乎没什么不对啊。于是乎在群内求助，经由<a href=\"https:\\/\\/boot.pw\\/\" target=\"_blank\" rel=\"external\">田师傅<\\/a>的指导，将 docker-compose.yml 中的 <code>$PWD<\\/code> 变量统统改成 <code>.\\/<\\/code> 之后，重新 <code>docker-compose up -d<\\/code>，终于在浏览器中看到了这个 OJ 的真容。大概可能也许是原项目对 <code>$PWD<\\/code> 的环境变量使用有问题吧 OvO……或者是不同发行版不兼容……或者是我少配置了什么……谁知道呢。<\\/p>\n<h1 id=\"一些优化\"><a href=\"#一些优化\" class=\"headerlink\" title=\"一些优化\"><\\/a>一些优化<\\/h1><p>搭好了之后，就是魔改它的时间了……想了想，这是个基于 docker 的项目诶，想要魔改似乎很麻烦的说。<\\/p>\n<p>鉴于每次在容器中修改之后再 commit 的方法十分麻烦，这里我直接把容器里的代码部分复制出来，然后再用 docker 的数据卷机制从宿主机映射回去，这样就可以很方便地修改了，同时容器中也会实时更新：<\\/p>\n<pre><code class=\"shell\"># docker cp oj_web_server:\\/code \\/home\\/username\\/code\n<\\/code><\\/pre>\n<p>然后再修改 docker-compose.yml，按照其中的其它映射数据卷的配置的格式抄一遍，把复制出来的目录映射回去镜像里就可以了。<\\/p>\n<h1 id=\"填坑\"><a href=\"#填坑\" class=\"headerlink\" title=\"填坑\"><\\/a>填坑<\\/h1><p>生产过程中还是在不停地踩坑……大部分是在判题的部分踩的。<\\/p>\n<h3 id=\"添加题目的时候标题等字段必须有英文，且不能出现公式字符\"><a href=\"#添加题目的时候标题等字段必须有英文，且不能出现公式字符\" class=\"headerlink\" title=\"添加题目的时候标题等字段必须有英文，且不能出现公式字符\"><\\/a>添加题目的时候标题等字段必须有英文，且不能出现公式字符<\\/h3><p>这个只能说似乎防 XSS 的机制做得好像太严格了，稍微修改一下问题的表达，问题不大。<\\/p>\n<h3 id=\"编译失败，Compile-Error，后面是一大串-JSON\"><a href=\"#编译失败，Compile-Error，后面是一大串-JSON\" class=\"headerlink\" title=\"编译失败，Compile Error，后面是一大串 JSON\"><\\/a>编译失败，Compile Error，后面是一大串 JSON<\\/h3><p>大概像这样的：<\\/p>\n<pre><code class=\"json\">Compile error: Compile error, info: {&#39;cpu_time&#39;: 1203, &#39;exit_status&#39;: 0, &#39;signal&#39;: 0, &#39;flag&#39;: 3, &#39;memory&#39;: 164458496, &#39;real_time&#39;: 1263}\n<\\/code><\\/pre>\n<p>当我看到标程 CE 的时候，又是一脸懵逼状。<\\/p>\n<p>参考这个 issue: <a href=\"https:\\/\\/github.com\\/QingdaoU\\/OnlineJudge\\/issues\\/40\" target=\"_blank\" rel=\"external\">https:\\/\\/github.com\\/QingdaoU\\/OnlineJudge\\/issues\\/40<\\/a> ，原来是评测机里限制了编译时候的资源，包括 CPU 时间和内存什么的。但是可能是评测机的性能太差了，即使原作者放宽了限制依旧存在这个问题。那么只能再人为地放宽这个限制了。<\\/p>\n<p>用你喜欢的办法修改 judger 容器中的 language.py，把其中的 compile_max_cpu_time 和 compile_max_memory 稍微调大一点就好了。<\\/p>\n<h3 id=\"Compiler-Bomb\"><a href=\"#Compiler-Bomb\" class=\"headerlink\" title=\"Compiler Bomb\"><\\/a>Compiler Bomb<\\/h3><p>如果你闲着无聊的话，试试下面这件事：在一个 .c 文件中写入这段代码: <code>main[-1u]={1};<\\/code>，然后用 gcc 编译。仅对 C 语言有效，C++ 无效。<\\/p>\n<p><s>这可是你自己要作死的。<\\/s><\\/p>\n<blockquote>\n<p>编译这段代码之后，会生成16GB的文件。<\\/p>\n<\\/blockquote>\n<p>关于编译器炸弹的原理，请看这里：<a href=\"http:\\/\\/link.zhihu.com\\/?target=https%3A\\/\\/wikicoding.org\\/wiki\\/c\\/Compiler_Bomb\\/%3Futm_content%3Dbuffer7c944%26utm_medium%3Dsocial%26utm_source%3Dfacebook.com%26utm_campaign%3Dbuffer\" target=\"_blank\" rel=\"external\">http:\\/\\/link.zhihu.com\\/?target=https%3A\\/\\/wikicoding.org\\/wiki\\/c\\/Compiler_Bomb\\/%3Futm_content%3Dbuffer7c944%26utm_medium%3Dsocial%26utm_source%3Dfacebook.com%26utm_campaign%3Dbuffer<\\/a><\\/p>\n<p>网上有一篇文章说限制编译出的可执行文件的大小，然而我并没有在 gcc 的编译选项中看到任何可以限制大小的参数……<\\/p>\n<p>不过既然这个东西会生成 16GB 的文件，那么写入的话肯定需要时间对吧，既然如此我们还是可以通过限制编译所用的最大时间来防范这种攻击，超时的话直接干掉编译器返回 CE. 鉴于我并不知道判题端容器中的 gcc 似乎没有受到上文说的 compile_max_cpu_time 的限制的原因，我们直接从编译命令上下手，修改 language.py 中的 compile_command：<\\/p>\n<pre><code>&quot;compile_command&quot;: &quot;\\/usr\\/bin\\/gcc -DONLINE_JUDGE -O2 -w -fmax-errors=3 -std=c99 {src_path} -lm -o {exe_path}\\/main&quot;\n<\\/code><\\/pre><p>改成：<\\/p>\n<pre><code>&quot;compile_command&quot;: &quot;timeout 3s \\/usr\\/bin\\/gcc -DONLINE_JUDGE -O2 -w -fmax-errors=3 -std=c99 {src_path} -lm -o {exe_path}\\/main&quot;\n<\\/code><\\/pre><p>这样子给编译设置一个最长 3s 的限制（当然，根据机器性能的不同，你可以设置短一点或者长一点），超过了就直接 kill 掉 gcc.<\\/p>\n<p>（大概还有很多坑没有踩，接下来再慢慢补充吧……）<\\/p>\n",
      "excerpt": "<p>嗯，就是搭 OJ 这破事把我拽进了 Python 和 docker 的大坑中……<br>为了给本校 OI 学员的交流和练(gao)习(shi)提供条件，便有了搭建 OJ 的这么一个想法。以前一直以为这种事情就和装个 WordPress 什么的差不多嘛，真正跳进去才发现，woc 这水居然这么深。<br>关于 OJ 的选择，这里我用的是青岛大学 (QingdaoU) 的开源项目 <a href=\"https:\\/\\/github.com\\/QingdaoU\\/OnlineJudge\">qduoj<\\/a>。<\\/p>",
      "slug": "notes-of-building-an-online-judge",
      "published": true,
      "layout": "post",
      "path": "blog/post/notes-of-building-an-online-judge/",
      "permalink": "https://kirainmoe.com/blog/post/notes-of-building-an-online-judge/",
      "tags": [
        {
          "name": "oi",
          "slug": "oi",
          "path": "tags/oi/",
          "permalink": "https://kirainmoe.com/tags/oi/",
          "length": 9
        },
        {
          "name": "online judge",
          "slug": "online-judge",
          "path": "tags/online-judge/",
          "permalink": "https://kirainmoe.com/tags/online-judge/",
          "length": 1
        },
        {
          "name": "python",
          "slug": "python",
          "path": "tags/python/",
          "permalink": "https://kirainmoe.com/tags/python/",
          "length": 1
        },
        {
          "name": "docker",
          "slug": "docker",
          "path": "tags/docker/",
          "permalink": "https://kirainmoe.com/tags/docker/",
          "length": 1
        }
      ],
      "categories": []
    }
  ],
  "menu": {
    "Home": "/",
    "Guestbook": "/pages/guestbook/",
    "Friends": "/pages/friends/",
    "About": "https://about.me/kirainmoe"
  },
  "socials": {
    "twitter": "https://twitter.com/yume_kankawa",
    "github": "https://github.com/kirainmoe",
    "weibo": "https://weibo.com/returnnnn",
    "medium": "https://medium.com/@kotori",
    "lastfm": "https://www.last.fm/user/kirainmoe"
  },
  "avatar": "https://secure.gravatar.com/avatar/c47187d311099868de825697fa419654?s=200&r=G",
  "menuIcon": {
    "Home": "home",
    "Guestbook": "book",
    "Friends": "users",
    "Archives": "tags",
    "About": "id-card-o"
  },
  "disqus": "yume-diary",
  "prev": 0,
  "next": 0
}</script>
  <!-- hook node of React -->
  <div id="himawari-app"></div>

  
    <!-- scripts list from theme config.yml -->
    
      <script src="https://unpkg.com/muse-player/dist/assets/muse-player.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/prism.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-clike.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-php.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-css.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-c.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.6.0/components/prism-cpp.min.js"></script>
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.1/components/prism-javascript.min.js"></script>
    
      <script src="/common.js"></script>
    
      <script src="/main.js"></script>
    
  

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-111347233-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-111347233-1');
  </script>

</body>
</html>
